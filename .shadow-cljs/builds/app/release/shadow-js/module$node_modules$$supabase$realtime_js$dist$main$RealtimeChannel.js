["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/realtime-js/dist/main/RealtimeChannel.js"],"~:js","shadow$provide[28]=function(S,ka,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.REALTIME_CHANNEL_STATES=a.REALTIME_SUBSCRIBE_STATES=a.REALTIME_LISTEN_TYPES=a.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT=void 0;ka=S(14);const I=S(22),q=ka.__importDefault(S(26)),D=ka.__importDefault(S(24)),C=ka.__importDefault(S(27)),G=ka.__importStar(S(25)),E=S(25);var M;(function(k){k.ALL=\"*\";k.INSERT=\"INSERT\";k.UPDATE=\"UPDATE\";k.DELETE=\"DELETE\"})(M||(a.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT=M={}));var d;(function(k){k.BROADCAST=\n\"broadcast\";k.PRESENCE=\"presence\";k.POSTGRES_CHANGES=\"postgres_changes\";k.SYSTEM=\"system\"})(d||(a.REALTIME_LISTEN_TYPES=d={}));var K;(function(k){k.SUBSCRIBED=\"SUBSCRIBED\";k.TIMED_OUT=\"TIMED_OUT\";k.CLOSED=\"CLOSED\";k.CHANNEL_ERROR=\"CHANNEL_ERROR\"})(K||(a.REALTIME_SUBSCRIBE_STATES=K={}));a.REALTIME_CHANNEL_STATES=I.CHANNEL_STATES;class p{constructor(k,y={config:{}},v){var z,J;this.topic=k;this.params=y;this.socket=v;this.bindings={};this.state=I.CHANNEL_STATES.closed;this.joinedOnce=!1;this.pushBuffer=\n[];this.subTopic=k.replace(/^realtime:/i,\"\");this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:\"\",enabled:!1},private:!1},y.config);this.timeout=this.socket.timeout;this.joinPush=new q.default(this,I.CHANNEL_EVENTS.join,this.params,this.timeout);this.rejoinTimer=new D.default(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs);this.joinPush.receive(\"ok\",()=>{this.state=I.CHANNEL_STATES.joined;this.rejoinTimer.reset();this.pushBuffer.forEach(l=>l.send());this.pushBuffer=\n[]});this._onClose(()=>{this.rejoinTimer.reset();this.socket.log(\"channel\",`close ${this.topic} ${this._joinRef()}`);this.state=I.CHANNEL_STATES.closed;this.socket._remove(this)});this._onError(l=>{this._isLeaving()||this._isClosed()||(this.socket.log(\"channel\",`error ${this.topic}`,l),this.state=I.CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())});this.joinPush.receive(\"timeout\",()=>{this._isJoining()&&(this.socket.log(\"channel\",`timeout ${this.topic}`,this.joinPush.timeout),this.state=\nI.CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())});this.joinPush.receive(\"error\",l=>{this._isLeaving()||this._isClosed()||(this.socket.log(\"channel\",`error ${this.topic}`,l),this.state=I.CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())});this._on(I.CHANNEL_EVENTS.reply,{},(l,t)=>{this._trigger(this._replyEventName(t),l)});this.presence=new C.default(this);this.broadcastEndpointURL=(0,E.httpEndpointURL)(this.socket.endPoint);this.private=this.params.config.private||!1;if(!this.private&&\n((J=(z=this.params.config)===null||z===void 0?void 0:z.broadcast)===null||J===void 0?0:J.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`;}subscribe(k,y=this.timeout){var v,z,J;this.socket.isConnected()||this.socket.connect();if(this.state==I.CHANNEL_STATES.closed){const {config:{broadcast:t,presence:x,private:w}}=this.params;var l=(z=(v=this.bindings.postgres_changes)===null||v===void 0?void 0:v.map(A=>A.filter))!==null&&z!==void 0?z:[];v=!!this.bindings[d.PRESENCE]&&\nthis.bindings[d.PRESENCE].length>0||((J=this.params.config.presence)===null||J===void 0?void 0:J.enabled)===!0;J={};l={broadcast:t,presence:Object.assign(Object.assign({},x),{enabled:v}),postgres_changes:l,private:w};this.socket.accessTokenValue&&(J.access_token=this.socket.accessTokenValue);this._onError(A=>k===null||k===void 0?void 0:k(K.CHANNEL_ERROR,A));this._onClose(()=>k===null||k===void 0?void 0:k(K.CLOSED));this.updateJoinPayload(Object.assign({config:l},J));this.joinedOnce=!0;this._rejoin(y);\nthis.joinPush.receive(\"ok\",async({postgres_changes:A})=>{var L;this.socket._isManualToken()||this.socket.setAuth();if(A===void 0)k===null||k===void 0||k(K.SUBSCRIBED);else{const P=this.bindings.postgres_changes,T=(L=P===null||P===void 0?void 0:P.length)!==null&&L!==void 0?L:0;L=[];for(let Y=0;Y<T;Y++){const ha=P[Y],{filter:{event:da,schema:fa,table:ja,filter:la}}=ha,ta=A&&A[Y];if(ta&&ta.event===da&&p.isFilterValueEqual(ta.schema,fa)&&p.isFilterValueEqual(ta.table,ja)&&p.isFilterValueEqual(ta.filter,\nla))L.push(Object.assign(Object.assign({},ha),{id:ta.id}));else{this.unsubscribe();this.state=I.CHANNEL_STATES.errored;k===null||k===void 0||k(K.CHANNEL_ERROR,Error(\"mismatch between server and client bindings for postgres changes\"));return}}this.bindings.postgres_changes=L;k&&k(K.SUBSCRIBED)}}).receive(\"error\",A=>{this.state=I.CHANNEL_STATES.errored;k===null||k===void 0||k(K.CHANNEL_ERROR,Error(JSON.stringify(Object.values(A).join(\", \")||\"error\")))}).receive(\"timeout\",()=>{k===null||k===void 0||\nk(K.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(k,y={}){return await this.send({type:\"presence\",event:\"track\",payload:k},y.timeout||this.timeout)}async untrack(k={}){return await this.send({type:\"presence\",event:\"untrack\"},k)}on(k,y,v){this.state===I.CHANNEL_STATES.joined&&k===d.PRESENCE&&(this.socket.log(\"channel\",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(async()=>await this.subscribe()));return this._on(k,\ny,v)}async httpSend(k,y,v={}){var z;if(y===void 0||y===null)return Promise.reject(\"Payload is required for httpSend()\");const J={apikey:this.socket.apiKey?this.socket.apiKey:\"\",\"Content-Type\":\"application/json\"};this.socket.accessTokenValue&&(J.Authorization=`Bearer ${this.socket.accessTokenValue}`);k={method:\"POST\",headers:J,body:JSON.stringify({messages:[{topic:this.subTopic,event:k,payload:y,private:this.private}]})};v=await this._fetchWithTimeout(this.broadcastEndpointURL,k,(z=v.timeout)!==null&&\nz!==void 0?z:this.timeout);if(v.status===202)return{success:!0};z=v.statusText;try{const l=await v.json();z=l.error||l.message||z}catch(l){}return Promise.reject(Error(z))}async send(k,y={}){var v,z;if(this._canPush()||k.type!==\"broadcast\")return new Promise(x=>{var w,A,L;const P=this._push(k.type,k,y.timeout||this.timeout);k.type!==\"broadcast\"||((L=(A=(w=this.params)===null||w===void 0?void 0:w.config)===null||A===void 0?void 0:A.broadcast)===null||L===void 0?0:L.ack)||x(\"ok\");P.receive(\"ok\",()=>\nx(\"ok\"));P.receive(\"error\",()=>x(\"error\"));P.receive(\"timeout\",()=>x(\"timed out\"))});console.warn(\"Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.\");const {event:J,payload:l}=k;var t={apikey:this.socket.apiKey?this.socket.apiKey:\"\",\"Content-Type\":\"application/json\"};this.socket.accessTokenValue&&(t.Authorization=`Bearer ${this.socket.accessTokenValue}`);t={method:\"POST\",headers:t,body:JSON.stringify({messages:[{topic:this.subTopic,\nevent:J,payload:l,private:this.private}]})};try{const x=await this._fetchWithTimeout(this.broadcastEndpointURL,t,(v=y.timeout)!==null&&v!==void 0?v:this.timeout);await ((z=x.body)===null||z===void 0?void 0:z.cancel());return x.ok?\"ok\":\"error\"}catch(x){return x.name===\"AbortError\"?\"timed out\":\"error\"}}updateJoinPayload(k){this.joinPush.updatePayload(k)}unsubscribe(k=this.timeout){this.state=I.CHANNEL_STATES.leaving;const y=()=>{this.socket.log(\"channel\",`leave ${this.topic}`);this._trigger(I.CHANNEL_EVENTS.close,\n\"leave\",this._joinRef())};this.joinPush.destroy();let v=null;return(new Promise(z=>{v=new q.default(this,I.CHANNEL_EVENTS.leave,{},k);v.receive(\"ok\",()=>{y();z(\"ok\")}).receive(\"timeout\",()=>{y();z(\"timed out\")}).receive(\"error\",()=>{z(\"error\")});v.send();this._canPush()||v.trigger(\"ok\",{})})).finally(()=>{v===null||v===void 0||v.destroy()})}teardown(){this.pushBuffer.forEach(k=>k.destroy());this.pushBuffer=[];this.rejoinTimer.reset();this.joinPush.destroy();this.state=I.CHANNEL_STATES.closed;this.bindings=\n{}}async _fetchWithTimeout(k,y,v){const z=new AbortController;v=setTimeout(()=>z.abort(),v);k=await this.socket.fetch(k,Object.assign(Object.assign({},y),{signal:z.signal}));clearTimeout(v);return k}_push(k,y,v=this.timeout){if(!this.joinedOnce)throw`tried to push '${k}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;k=new q.default(this,k,y,v);this._canPush()?k.send():this._addToPushBuffer(k);return k}_addToPushBuffer(k){k.startTimeout();this.pushBuffer.push(k);\nthis.pushBuffer.length>I.MAX_PUSH_BUFFER_SIZE&&(k=this.pushBuffer.shift())&&(k.destroy(),this.socket.log(\"channel\",`discarded push due to buffer overflow: ${k.event}`,k.payload))}_onMessage(k,y,v){return y}_isMember(k){return this.topic===k}_joinRef(){return this.joinPush.ref}_trigger(k,y,v){var z,J;const l=k.toLocaleLowerCase(),{close:t,error:x,leave:w,join:A}=I.CHANNEL_EVENTS;k=[t,x,w,A];if(!(v&&k.indexOf(l)>=0&&v!==this._joinRef())){var L=this._onMessage(l,y,v);if(y&&!L)throw\"channel onMessage callbacks must return the payload, modified or unmodified\";\n[\"insert\",\"update\",\"delete\"].includes(l)?(z=this.bindings.postgres_changes)===null||z===void 0||z.filter(P=>{var T,Y,ha;return((T=P.filter)===null||T===void 0?void 0:T.event)===\"*\"||((ha=(Y=P.filter)===null||Y===void 0?void 0:Y.event)===null||ha===void 0?void 0:ha.toLocaleLowerCase())===l}).map(P=>P.callback(L,v)):(J=this.bindings[l])===null||J===void 0||J.filter(P=>{var T,Y,ha,da,fa;if([\"broadcast\",\"presence\",\"postgres_changes\"].includes(l)){if(\"id\"in P){var ja=P.id;P=(T=P.filter)===null||T===void 0?\nvoid 0:T.event;return ja&&((Y=y.ids)===null||Y===void 0?void 0:Y.includes(ja))&&(P===\"*\"||(P===null||P===void 0?void 0:P.toLocaleLowerCase())===((ha=y.data)===null||ha===void 0?void 0:ha.type.toLocaleLowerCase()))}T=(da=(ja=P===null||P===void 0?void 0:P.filter)===null||ja===void 0?void 0:ja.event)===null||da===void 0?void 0:da.toLocaleLowerCase();return T===\"*\"||T===((fa=y===null||y===void 0?void 0:y.event)===null||fa===void 0?void 0:fa.toLocaleLowerCase())}return P.type.toLocaleLowerCase()===l}).map(P=>\n{if(typeof L===\"object\"&&\"ids\"in L){const T=L.data,{schema:Y,table:ha,commit_timestamp:da,type:fa,errors:ja}=T;L=Object.assign(Object.assign({},{schema:Y,table:ha,commit_timestamp:da,eventType:fa,new:{},old:{},errors:ja}),this._getPayloadRecords(T))}P.callback(L,v)})}}_isClosed(){return this.state===I.CHANNEL_STATES.closed}_isJoined(){return this.state===I.CHANNEL_STATES.joined}_isJoining(){return this.state===I.CHANNEL_STATES.joining}_isLeaving(){return this.state===I.CHANNEL_STATES.leaving}_replyEventName(k){return`chan_reply_${k}`}_on(k,\ny,v){k=k.toLocaleLowerCase();y={type:k,filter:y,callback:v};this.bindings[k]?this.bindings[k].push(y):this.bindings[k]=[y];return this}_off(k,y){const v=k.toLocaleLowerCase();this.bindings[v]&&(this.bindings[v]=this.bindings[v].filter(z=>{var J;return!(((J=z.type)===null||J===void 0?void 0:J.toLocaleLowerCase())===v&&p.isEqual(z.filter,y))}));return this}static isEqual(k,y){if(Object.keys(k).length!==Object.keys(y).length)return!1;for(const v in k)if(k[v]!==y[v])return!1;return!0}static isFilterValueEqual(k,\ny){return(k!==null&&k!==void 0?k:void 0)===(y!==null&&y!==void 0?y:void 0)}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout();this.socket.isConnected()&&this._rejoin()}_onClose(k){this._on(I.CHANNEL_EVENTS.close,{},k)}_onError(k){this._on(I.CHANNEL_EVENTS.error,{},y=>k(y))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(k=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=I.CHANNEL_STATES.joining,this.joinPush.resend(k))}_getPayloadRecords(k){const y=\n{new:{},old:{}};if(k.type===\"INSERT\"||k.type===\"UPDATE\")y.new=G.convertChangeData(k.columns,k.record);if(k.type===\"UPDATE\"||k.type===\"DELETE\")y.old=G.convertChangeData(k.columns,k.old_record);return y}}a.default=p}","~:source","shadow$provide[28] = function(require,module,exports) {\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REALTIME_CHANNEL_STATES = exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_LISTEN_TYPES = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = void 0;\r\nconst tslib_1 = require(\"tslib\");\r\nconst constants_1 = require(\"./lib/constants\");\r\nconst push_1 = tslib_1.__importDefault(require(\"./lib/push\"));\r\nconst timer_1 = tslib_1.__importDefault(require(\"./lib/timer\"));\r\nconst RealtimePresence_1 = tslib_1.__importDefault(require(\"./RealtimePresence\"));\r\nconst Transformers = tslib_1.__importStar(require(\"./lib/transformers\"));\r\nconst transformers_1 = require(\"./lib/transformers\");\r\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\r\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\r\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\r\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\r\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\r\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\r\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\r\nvar REALTIME_LISTEN_TYPES;\r\n(function (REALTIME_LISTEN_TYPES) {\r\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\r\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\r\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\r\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\r\n})(REALTIME_LISTEN_TYPES || (exports.REALTIME_LISTEN_TYPES = REALTIME_LISTEN_TYPES = {}));\r\nvar REALTIME_SUBSCRIBE_STATES;\r\n(function (REALTIME_SUBSCRIBE_STATES) {\r\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\r\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\r\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\r\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\r\n})(REALTIME_SUBSCRIBE_STATES || (exports.REALTIME_SUBSCRIBE_STATES = REALTIME_SUBSCRIBE_STATES = {}));\r\nexports.REALTIME_CHANNEL_STATES = constants_1.CHANNEL_STATES;\r\n/** A channel is the basic building block of Realtime\r\n * and narrows the scope of data flow to subscribed clients.\r\n * You can think of a channel as a chatroom where participants are able to see who's online\r\n * and send and receive messages.\r\n */\r\nclass RealtimeChannel {\r\n    /**\r\n     * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.\r\n     *\r\n     * The topic determines which realtime stream you are subscribing to. Config options let you\r\n     * enable acknowledgement for broadcasts, presence tracking, or private channels.\r\n     *\r\n     * @example\r\n     * ```ts\r\n     * import RealtimeClient from '@supabase/realtime-js'\r\n     *\r\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\r\n     *   params: { apikey: 'public-anon-key' },\r\n     * })\r\n     * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)\r\n     * ```\r\n     */\r\n    constructor(\r\n    /** Topic name can be any string. */\r\n    topic, params = { config: {} }, socket) {\r\n        var _a, _b;\r\n        this.topic = topic;\r\n        this.params = params;\r\n        this.socket = socket;\r\n        this.bindings = {};\r\n        this.state = constants_1.CHANNEL_STATES.closed;\r\n        this.joinedOnce = false;\r\n        this.pushBuffer = [];\r\n        this.subTopic = topic.replace(/^realtime:/i, '');\r\n        this.params.config = Object.assign({\r\n            broadcast: { ack: false, self: false },\r\n            presence: { key: '', enabled: false },\r\n            private: false,\r\n        }, params.config);\r\n        this.timeout = this.socket.timeout;\r\n        this.joinPush = new push_1.default(this, constants_1.CHANNEL_EVENTS.join, this.params, this.timeout);\r\n        this.rejoinTimer = new timer_1.default(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\r\n        this.joinPush.receive('ok', () => {\r\n            this.state = constants_1.CHANNEL_STATES.joined;\r\n            this.rejoinTimer.reset();\r\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\r\n            this.pushBuffer = [];\r\n        });\r\n        this._onClose(() => {\r\n            this.rejoinTimer.reset();\r\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\r\n            this.state = constants_1.CHANNEL_STATES.closed;\r\n            this.socket._remove(this);\r\n        });\r\n        this._onError((reason) => {\r\n            if (this._isLeaving() || this._isClosed()) {\r\n                return;\r\n            }\r\n            this.socket.log('channel', `error ${this.topic}`, reason);\r\n            this.state = constants_1.CHANNEL_STATES.errored;\r\n            this.rejoinTimer.scheduleTimeout();\r\n        });\r\n        this.joinPush.receive('timeout', () => {\r\n            if (!this._isJoining()) {\r\n                return;\r\n            }\r\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\r\n            this.state = constants_1.CHANNEL_STATES.errored;\r\n            this.rejoinTimer.scheduleTimeout();\r\n        });\r\n        this.joinPush.receive('error', (reason) => {\r\n            if (this._isLeaving() || this._isClosed()) {\r\n                return;\r\n            }\r\n            this.socket.log('channel', `error ${this.topic}`, reason);\r\n            this.state = constants_1.CHANNEL_STATES.errored;\r\n            this.rejoinTimer.scheduleTimeout();\r\n        });\r\n        this._on(constants_1.CHANNEL_EVENTS.reply, {}, (payload, ref) => {\r\n            this._trigger(this._replyEventName(ref), payload);\r\n        });\r\n        this.presence = new RealtimePresence_1.default(this);\r\n        this.broadcastEndpointURL = (0, transformers_1.httpEndpointURL)(this.socket.endPoint);\r\n        this.private = this.params.config.private || false;\r\n        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\r\n            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;\r\n        }\r\n    }\r\n    /** Subscribe registers your client with the server */\r\n    subscribe(callback, timeout = this.timeout) {\r\n        var _a, _b, _c;\r\n        if (!this.socket.isConnected()) {\r\n            this.socket.connect();\r\n        }\r\n        if (this.state == constants_1.CHANNEL_STATES.closed) {\r\n            const { config: { broadcast, presence, private: isPrivate }, } = this.params;\r\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [];\r\n            const presence_enabled = (!!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] &&\r\n                this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0) ||\r\n                ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\r\n            const accessTokenPayload = {};\r\n            const config = {\r\n                broadcast,\r\n                presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),\r\n                postgres_changes,\r\n                private: isPrivate,\r\n            };\r\n            if (this.socket.accessTokenValue) {\r\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\r\n            }\r\n            this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\r\n            this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\r\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\r\n            this.joinedOnce = true;\r\n            this._rejoin(timeout);\r\n            this.joinPush\r\n                .receive('ok', async ({ postgres_changes }) => {\r\n                var _a;\r\n                // Only refresh auth if using callback-based tokens\r\n                if (!this.socket._isManualToken()) {\r\n                    this.socket.setAuth();\r\n                }\r\n                if (postgres_changes === undefined) {\r\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\r\n                    return;\r\n                }\r\n                else {\r\n                    const clientPostgresBindings = this.bindings.postgres_changes;\r\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\r\n                    const newPostgresBindings = [];\r\n                    for (let i = 0; i < bindingsLen; i++) {\r\n                        const clientPostgresBinding = clientPostgresBindings[i];\r\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\r\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\r\n                        if (serverPostgresFilter &&\r\n                            serverPostgresFilter.event === event &&\r\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) &&\r\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) &&\r\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {\r\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\r\n                        }\r\n                        else {\r\n                            this.unsubscribe();\r\n                            this.state = constants_1.CHANNEL_STATES.errored;\r\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\r\n                            return;\r\n                        }\r\n                    }\r\n                    this.bindings.postgres_changes = newPostgresBindings;\r\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\r\n                    return;\r\n                }\r\n            })\r\n                .receive('error', (error) => {\r\n                this.state = constants_1.CHANNEL_STATES.errored;\r\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\r\n                return;\r\n            })\r\n                .receive('timeout', () => {\r\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\r\n                return;\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns the current presence state for this channel.\r\n     *\r\n     * The shape is a map keyed by presence key (for example a user id) where each entry contains the\r\n     * tracked metadata for that user.\r\n     */\r\n    presenceState() {\r\n        return this.presence.state;\r\n    }\r\n    /**\r\n     * Sends the supplied payload to the presence tracker so other subscribers can see that this\r\n     * client is online. Use `untrack` to stop broadcasting presence for the same key.\r\n     */\r\n    async track(payload, opts = {}) {\r\n        return await this.send({\r\n            type: 'presence',\r\n            event: 'track',\r\n            payload,\r\n        }, opts.timeout || this.timeout);\r\n    }\r\n    /**\r\n     * Removes the current presence state for this client.\r\n     */\r\n    async untrack(opts = {}) {\r\n        return await this.send({\r\n            type: 'presence',\r\n            event: 'untrack',\r\n        }, opts);\r\n    }\r\n    on(type, filter, callback) {\r\n        if (this.state === constants_1.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\r\n            this.socket.log('channel', `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\r\n            this.unsubscribe().then(async () => await this.subscribe());\r\n        }\r\n        return this._on(type, filter, callback);\r\n    }\r\n    /**\r\n     * Sends a broadcast message explicitly via REST API.\r\n     *\r\n     * This method always uses the REST API endpoint regardless of WebSocket connection state.\r\n     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\r\n     *\r\n     * @param event The name of the broadcast event\r\n     * @param payload Payload to be sent (required)\r\n     * @param opts Options including timeout\r\n     * @returns Promise resolving to object with success status, and error details if failed\r\n     */\r\n    async httpSend(event, payload, opts = {}) {\r\n        var _a;\r\n        if (payload === undefined || payload === null) {\r\n            return Promise.reject('Payload is required for httpSend()');\r\n        }\r\n        const headers = {\r\n            apikey: this.socket.apiKey ? this.socket.apiKey : '',\r\n            'Content-Type': 'application/json',\r\n        };\r\n        if (this.socket.accessTokenValue) {\r\n            headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`;\r\n        }\r\n        const options = {\r\n            method: 'POST',\r\n            headers,\r\n            body: JSON.stringify({\r\n                messages: [\r\n                    {\r\n                        topic: this.subTopic,\r\n                        event,\r\n                        payload: payload,\r\n                        private: this.private,\r\n                    },\r\n                ],\r\n            }),\r\n        };\r\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\r\n        if (response.status === 202) {\r\n            return { success: true };\r\n        }\r\n        let errorMessage = response.statusText;\r\n        try {\r\n            const errorBody = await response.json();\r\n            errorMessage = errorBody.error || errorBody.message || errorMessage;\r\n        }\r\n        catch (_b) { }\r\n        return Promise.reject(new Error(errorMessage));\r\n    }\r\n    /**\r\n     * Sends a message into the channel.\r\n     *\r\n     * @param args Arguments to send to channel\r\n     * @param args.type The type of event to send\r\n     * @param args.event The name of the event being sent\r\n     * @param args.payload Payload to be sent\r\n     * @param opts Options to be used during the send process\r\n     */\r\n    async send(args, opts = {}) {\r\n        var _a, _b;\r\n        if (!this._canPush() && args.type === 'broadcast') {\r\n            console.warn('Realtime send() is automatically falling back to REST API. ' +\r\n                'This behavior will be deprecated in the future. ' +\r\n                'Please use httpSend() explicitly for REST delivery.');\r\n            const { event, payload: endpoint_payload } = args;\r\n            const headers = {\r\n                apikey: this.socket.apiKey ? this.socket.apiKey : '',\r\n                'Content-Type': 'application/json',\r\n            };\r\n            if (this.socket.accessTokenValue) {\r\n                headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`;\r\n            }\r\n            const options = {\r\n                method: 'POST',\r\n                headers,\r\n                body: JSON.stringify({\r\n                    messages: [\r\n                        {\r\n                            topic: this.subTopic,\r\n                            event,\r\n                            payload: endpoint_payload,\r\n                            private: this.private,\r\n                        },\r\n                    ],\r\n                }),\r\n            };\r\n            try {\r\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\r\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\r\n                return response.ok ? 'ok' : 'error';\r\n            }\r\n            catch (error) {\r\n                if (error.name === 'AbortError') {\r\n                    return 'timed out';\r\n                }\r\n                else {\r\n                    return 'error';\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return new Promise((resolve) => {\r\n                var _a, _b, _c;\r\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\r\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\r\n                    resolve('ok');\r\n                }\r\n                push.receive('ok', () => resolve('ok'));\r\n                push.receive('error', () => resolve('error'));\r\n                push.receive('timeout', () => resolve('timed out'));\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Updates the payload that will be sent the next time the channel joins (reconnects).\r\n     * Useful for rotating access tokens or updating config without re-creating the channel.\r\n     */\r\n    updateJoinPayload(payload) {\r\n        this.joinPush.updatePayload(payload);\r\n    }\r\n    /**\r\n     * Leaves the channel.\r\n     *\r\n     * Unsubscribes from server events, and instructs channel to terminate on server.\r\n     * Triggers onClose() hooks.\r\n     *\r\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\r\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\r\n     */\r\n    unsubscribe(timeout = this.timeout) {\r\n        this.state = constants_1.CHANNEL_STATES.leaving;\r\n        const onClose = () => {\r\n            this.socket.log('channel', `leave ${this.topic}`);\r\n            this._trigger(constants_1.CHANNEL_EVENTS.close, 'leave', this._joinRef());\r\n        };\r\n        this.joinPush.destroy();\r\n        let leavePush = null;\r\n        return new Promise((resolve) => {\r\n            leavePush = new push_1.default(this, constants_1.CHANNEL_EVENTS.leave, {}, timeout);\r\n            leavePush\r\n                .receive('ok', () => {\r\n                onClose();\r\n                resolve('ok');\r\n            })\r\n                .receive('timeout', () => {\r\n                onClose();\r\n                resolve('timed out');\r\n            })\r\n                .receive('error', () => {\r\n                resolve('error');\r\n            });\r\n            leavePush.send();\r\n            if (!this._canPush()) {\r\n                leavePush.trigger('ok', {});\r\n            }\r\n        }).finally(() => {\r\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\r\n        });\r\n    }\r\n    /**\r\n     * Teardown the channel.\r\n     *\r\n     * Destroys and stops related timers.\r\n     */\r\n    teardown() {\r\n        this.pushBuffer.forEach((push) => push.destroy());\r\n        this.pushBuffer = [];\r\n        this.rejoinTimer.reset();\r\n        this.joinPush.destroy();\r\n        this.state = constants_1.CHANNEL_STATES.closed;\r\n        this.bindings = {};\r\n    }\r\n    /** @internal */\r\n    async _fetchWithTimeout(url, options, timeout) {\r\n        const controller = new AbortController();\r\n        const id = setTimeout(() => controller.abort(), timeout);\r\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\r\n        clearTimeout(id);\r\n        return response;\r\n    }\r\n    /** @internal */\r\n    _push(event, payload, timeout = this.timeout) {\r\n        if (!this.joinedOnce) {\r\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\r\n        }\r\n        let pushEvent = new push_1.default(this, event, payload, timeout);\r\n        if (this._canPush()) {\r\n            pushEvent.send();\r\n        }\r\n        else {\r\n            this._addToPushBuffer(pushEvent);\r\n        }\r\n        return pushEvent;\r\n    }\r\n    /** @internal */\r\n    _addToPushBuffer(pushEvent) {\r\n        pushEvent.startTimeout();\r\n        this.pushBuffer.push(pushEvent);\r\n        // Enforce buffer size limit\r\n        if (this.pushBuffer.length > constants_1.MAX_PUSH_BUFFER_SIZE) {\r\n            const removedPush = this.pushBuffer.shift();\r\n            if (removedPush) {\r\n                removedPush.destroy();\r\n                this.socket.log('channel', `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Overridable message hook\r\n     *\r\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\r\n     * Must return the payload, modified or unmodified.\r\n     *\r\n     * @internal\r\n     */\r\n    _onMessage(_event, payload, _ref) {\r\n        return payload;\r\n    }\r\n    /** @internal */\r\n    _isMember(topic) {\r\n        return this.topic === topic;\r\n    }\r\n    /** @internal */\r\n    _joinRef() {\r\n        return this.joinPush.ref;\r\n    }\r\n    /** @internal */\r\n    _trigger(type, payload, ref) {\r\n        var _a, _b;\r\n        const typeLower = type.toLocaleLowerCase();\r\n        const { close, error, leave, join } = constants_1.CHANNEL_EVENTS;\r\n        const events = [close, error, leave, join];\r\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\r\n            return;\r\n        }\r\n        let handledPayload = this._onMessage(typeLower, payload, ref);\r\n        if (payload && !handledPayload) {\r\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\r\n        }\r\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\r\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\r\n                var _a, _b, _c;\r\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\r\n            }).map((bind) => bind.callback(handledPayload, ref));\r\n        }\r\n        else {\r\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\r\n                var _a, _b, _c, _d, _e, _f;\r\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\r\n                    if ('id' in bind) {\r\n                        const bindId = bind.id;\r\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\r\n                        return (bindId &&\r\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\r\n                            (bindEvent === '*' ||\r\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\r\n                    }\r\n                    else {\r\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\r\n                        return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\r\n                    }\r\n                }\r\n                else {\r\n                    return bind.type.toLocaleLowerCase() === typeLower;\r\n                }\r\n            }).map((bind) => {\r\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\r\n                    const postgresChanges = handledPayload.data;\r\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\r\n                    const enrichedPayload = {\r\n                        schema: schema,\r\n                        table: table,\r\n                        commit_timestamp: commit_timestamp,\r\n                        eventType: type,\r\n                        new: {},\r\n                        old: {},\r\n                        errors: errors,\r\n                    };\r\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\r\n                }\r\n                bind.callback(handledPayload, ref);\r\n            });\r\n        }\r\n    }\r\n    /** @internal */\r\n    _isClosed() {\r\n        return this.state === constants_1.CHANNEL_STATES.closed;\r\n    }\r\n    /** @internal */\r\n    _isJoined() {\r\n        return this.state === constants_1.CHANNEL_STATES.joined;\r\n    }\r\n    /** @internal */\r\n    _isJoining() {\r\n        return this.state === constants_1.CHANNEL_STATES.joining;\r\n    }\r\n    /** @internal */\r\n    _isLeaving() {\r\n        return this.state === constants_1.CHANNEL_STATES.leaving;\r\n    }\r\n    /** @internal */\r\n    _replyEventName(ref) {\r\n        return `chan_reply_${ref}`;\r\n    }\r\n    /** @internal */\r\n    _on(type, filter, callback) {\r\n        const typeLower = type.toLocaleLowerCase();\r\n        const binding = {\r\n            type: typeLower,\r\n            filter: filter,\r\n            callback: callback,\r\n        };\r\n        if (this.bindings[typeLower]) {\r\n            this.bindings[typeLower].push(binding);\r\n        }\r\n        else {\r\n            this.bindings[typeLower] = [binding];\r\n        }\r\n        return this;\r\n    }\r\n    /** @internal */\r\n    _off(type, filter) {\r\n        const typeLower = type.toLocaleLowerCase();\r\n        if (this.bindings[typeLower]) {\r\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\r\n                var _a;\r\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\r\n                    RealtimeChannel.isEqual(bind.filter, filter));\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n    /** @internal */\r\n    static isEqual(obj1, obj2) {\r\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\r\n            return false;\r\n        }\r\n        for (const k in obj1) {\r\n            if (obj1[k] !== obj2[k]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Compares two optional filter values for equality.\r\n     * Treats undefined, null, and empty string as equivalent empty values.\r\n     * @internal\r\n     */\r\n    static isFilterValueEqual(serverValue, clientValue) {\r\n        const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;\r\n        const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;\r\n        return normalizedServer === normalizedClient;\r\n    }\r\n    /** @internal */\r\n    _rejoinUntilConnected() {\r\n        this.rejoinTimer.scheduleTimeout();\r\n        if (this.socket.isConnected()) {\r\n            this._rejoin();\r\n        }\r\n    }\r\n    /**\r\n     * Registers a callback that will be executed when the channel closes.\r\n     *\r\n     * @internal\r\n     */\r\n    _onClose(callback) {\r\n        this._on(constants_1.CHANNEL_EVENTS.close, {}, callback);\r\n    }\r\n    /**\r\n     * Registers a callback that will be executed when the channel encounteres an error.\r\n     *\r\n     * @internal\r\n     */\r\n    _onError(callback) {\r\n        this._on(constants_1.CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\r\n    }\r\n    /**\r\n     * Returns `true` if the socket is connected and the channel has been joined.\r\n     *\r\n     * @internal\r\n     */\r\n    _canPush() {\r\n        return this.socket.isConnected() && this._isJoined();\r\n    }\r\n    /** @internal */\r\n    _rejoin(timeout = this.timeout) {\r\n        if (this._isLeaving()) {\r\n            return;\r\n        }\r\n        this.socket._leaveOpenTopic(this.topic);\r\n        this.state = constants_1.CHANNEL_STATES.joining;\r\n        this.joinPush.resend(timeout);\r\n    }\r\n    /** @internal */\r\n    _getPayloadRecords(payload) {\r\n        const records = {\r\n            new: {},\r\n            old: {},\r\n        };\r\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\r\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\r\n        }\r\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\r\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\r\n        }\r\n        return records;\r\n    }\r\n}\r\nexports.default = RealtimeChannel;\r\n//# sourceMappingURL=RealtimeChannel.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$supabase$realtime_js$dist$main$lib$timer","~$module$node_modules$$supabase$realtime_js$dist$main$RealtimePresence","~$module$node_modules$tslib$tslib","~$module$node_modules$$supabase$realtime_js$dist$main$lib$push","~$module$node_modules$$supabase$realtime_js$dist$main$lib$transformers","~$shadow.js","~$module$node_modules$$supabase$realtime_js$dist$main$lib$constants"]],"~:properties",["^5",["table","success","callback","bindings","body","rejoinTimer","config","params","joinPush","apikey","REALTIME_LISTEN_TYPES","postgres_changes","method","key","access_token","__esModule","private","new","eventType","schema","enabled","id","pushBuffer","event","errors","REALTIME_CHANNEL_STATES","signal","ack","subTopic","joinedOnce","value","broadcast","timeout","REALTIME_SUBSCRIBE_STATES","old","filter","self","broadcastEndpointURL","type","presence","state","messages","socket","payload","default","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","commit_timestamp","topic","headers"]],"~:compiled-at",1771869280856,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$realtime_js$dist$main$RealtimeChannel.js\",\n\"lineCount\":23,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/realtime-js/dist/main/RealtimeChannel.js\"],\n\"sourcesContent\":[\"shadow$provide[28] = function(require,module,exports) {\\n\\\"use strict\\\";\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.REALTIME_CHANNEL_STATES = exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_LISTEN_TYPES = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = void 0;\\r\\nconst tslib_1 = require(\\\"tslib\\\");\\r\\nconst constants_1 = require(\\\"./lib/constants\\\");\\r\\nconst push_1 = tslib_1.__importDefault(require(\\\"./lib/push\\\"));\\r\\nconst timer_1 = tslib_1.__importDefault(require(\\\"./lib/timer\\\"));\\r\\nconst RealtimePresence_1 = tslib_1.__importDefault(require(\\\"./RealtimePresence\\\"));\\r\\nconst Transformers = tslib_1.__importStar(require(\\\"./lib/transformers\\\"));\\r\\nconst transformers_1 = require(\\\"./lib/transformers\\\");\\r\\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\\r\\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\\r\\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\\\"ALL\\\"] = \\\"*\\\";\\r\\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\\\"INSERT\\\"] = \\\"INSERT\\\";\\r\\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\\\"UPDATE\\\"] = \\\"UPDATE\\\";\\r\\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\\\"DELETE\\\"] = \\\"DELETE\\\";\\r\\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\\r\\nvar REALTIME_LISTEN_TYPES;\\r\\n(function (REALTIME_LISTEN_TYPES) {\\r\\n    REALTIME_LISTEN_TYPES[\\\"BROADCAST\\\"] = \\\"broadcast\\\";\\r\\n    REALTIME_LISTEN_TYPES[\\\"PRESENCE\\\"] = \\\"presence\\\";\\r\\n    REALTIME_LISTEN_TYPES[\\\"POSTGRES_CHANGES\\\"] = \\\"postgres_changes\\\";\\r\\n    REALTIME_LISTEN_TYPES[\\\"SYSTEM\\\"] = \\\"system\\\";\\r\\n})(REALTIME_LISTEN_TYPES || (exports.REALTIME_LISTEN_TYPES = REALTIME_LISTEN_TYPES = {}));\\r\\nvar REALTIME_SUBSCRIBE_STATES;\\r\\n(function (REALTIME_SUBSCRIBE_STATES) {\\r\\n    REALTIME_SUBSCRIBE_STATES[\\\"SUBSCRIBED\\\"] = \\\"SUBSCRIBED\\\";\\r\\n    REALTIME_SUBSCRIBE_STATES[\\\"TIMED_OUT\\\"] = \\\"TIMED_OUT\\\";\\r\\n    REALTIME_SUBSCRIBE_STATES[\\\"CLOSED\\\"] = \\\"CLOSED\\\";\\r\\n    REALTIME_SUBSCRIBE_STATES[\\\"CHANNEL_ERROR\\\"] = \\\"CHANNEL_ERROR\\\";\\r\\n})(REALTIME_SUBSCRIBE_STATES || (exports.REALTIME_SUBSCRIBE_STATES = REALTIME_SUBSCRIBE_STATES = {}));\\r\\nexports.REALTIME_CHANNEL_STATES = constants_1.CHANNEL_STATES;\\r\\n/** A channel is the basic building block of Realtime\\r\\n * and narrows the scope of data flow to subscribed clients.\\r\\n * You can think of a channel as a chatroom where participants are able to see who's online\\r\\n * and send and receive messages.\\r\\n */\\r\\nclass RealtimeChannel {\\r\\n    /**\\r\\n     * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.\\r\\n     *\\r\\n     * The topic determines which realtime stream you are subscribing to. Config options let you\\r\\n     * enable acknowledgement for broadcasts, presence tracking, or private channels.\\r\\n     *\\r\\n     * @example\\r\\n     * ```ts\\r\\n     * import RealtimeClient from '@supabase/realtime-js'\\r\\n     *\\r\\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\\r\\n     *   params: { apikey: 'public-anon-key' },\\r\\n     * })\\r\\n     * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)\\r\\n     * ```\\r\\n     */\\r\\n    constructor(\\r\\n    /** Topic name can be any string. */\\r\\n    topic, params = { config: {} }, socket) {\\r\\n        var _a, _b;\\r\\n        this.topic = topic;\\r\\n        this.params = params;\\r\\n        this.socket = socket;\\r\\n        this.bindings = {};\\r\\n        this.state = constants_1.CHANNEL_STATES.closed;\\r\\n        this.joinedOnce = false;\\r\\n        this.pushBuffer = [];\\r\\n        this.subTopic = topic.replace(/^realtime:/i, '');\\r\\n        this.params.config = Object.assign({\\r\\n            broadcast: { ack: false, self: false },\\r\\n            presence: { key: '', enabled: false },\\r\\n            private: false,\\r\\n        }, params.config);\\r\\n        this.timeout = this.socket.timeout;\\r\\n        this.joinPush = new push_1.default(this, constants_1.CHANNEL_EVENTS.join, this.params, this.timeout);\\r\\n        this.rejoinTimer = new timer_1.default(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\\r\\n        this.joinPush.receive('ok', () => {\\r\\n            this.state = constants_1.CHANNEL_STATES.joined;\\r\\n            this.rejoinTimer.reset();\\r\\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\\r\\n            this.pushBuffer = [];\\r\\n        });\\r\\n        this._onClose(() => {\\r\\n            this.rejoinTimer.reset();\\r\\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\\r\\n            this.state = constants_1.CHANNEL_STATES.closed;\\r\\n            this.socket._remove(this);\\r\\n        });\\r\\n        this._onError((reason) => {\\r\\n            if (this._isLeaving() || this._isClosed()) {\\r\\n                return;\\r\\n            }\\r\\n            this.socket.log('channel', `error ${this.topic}`, reason);\\r\\n            this.state = constants_1.CHANNEL_STATES.errored;\\r\\n            this.rejoinTimer.scheduleTimeout();\\r\\n        });\\r\\n        this.joinPush.receive('timeout', () => {\\r\\n            if (!this._isJoining()) {\\r\\n                return;\\r\\n            }\\r\\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\\r\\n            this.state = constants_1.CHANNEL_STATES.errored;\\r\\n            this.rejoinTimer.scheduleTimeout();\\r\\n        });\\r\\n        this.joinPush.receive('error', (reason) => {\\r\\n            if (this._isLeaving() || this._isClosed()) {\\r\\n                return;\\r\\n            }\\r\\n            this.socket.log('channel', `error ${this.topic}`, reason);\\r\\n            this.state = constants_1.CHANNEL_STATES.errored;\\r\\n            this.rejoinTimer.scheduleTimeout();\\r\\n        });\\r\\n        this._on(constants_1.CHANNEL_EVENTS.reply, {}, (payload, ref) => {\\r\\n            this._trigger(this._replyEventName(ref), payload);\\r\\n        });\\r\\n        this.presence = new RealtimePresence_1.default(this);\\r\\n        this.broadcastEndpointURL = (0, transformers_1.httpEndpointURL)(this.socket.endPoint);\\r\\n        this.private = this.params.config.private || false;\\r\\n        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\\r\\n            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;\\r\\n        }\\r\\n    }\\r\\n    /** Subscribe registers your client with the server */\\r\\n    subscribe(callback, timeout = this.timeout) {\\r\\n        var _a, _b, _c;\\r\\n        if (!this.socket.isConnected()) {\\r\\n            this.socket.connect();\\r\\n        }\\r\\n        if (this.state == constants_1.CHANNEL_STATES.closed) {\\r\\n            const { config: { broadcast, presence, private: isPrivate }, } = this.params;\\r\\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [];\\r\\n            const presence_enabled = (!!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] &&\\r\\n                this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0) ||\\r\\n                ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\\r\\n            const accessTokenPayload = {};\\r\\n            const config = {\\r\\n                broadcast,\\r\\n                presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),\\r\\n                postgres_changes,\\r\\n                private: isPrivate,\\r\\n            };\\r\\n            if (this.socket.accessTokenValue) {\\r\\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\\r\\n            }\\r\\n            this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\\r\\n            this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\\r\\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\\r\\n            this.joinedOnce = true;\\r\\n            this._rejoin(timeout);\\r\\n            this.joinPush\\r\\n                .receive('ok', async ({ postgres_changes }) => {\\r\\n                var _a;\\r\\n                // Only refresh auth if using callback-based tokens\\r\\n                if (!this.socket._isManualToken()) {\\r\\n                    this.socket.setAuth();\\r\\n                }\\r\\n                if (postgres_changes === undefined) {\\r\\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\\r\\n                    return;\\r\\n                }\\r\\n                else {\\r\\n                    const clientPostgresBindings = this.bindings.postgres_changes;\\r\\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\\r\\n                    const newPostgresBindings = [];\\r\\n                    for (let i = 0; i < bindingsLen; i++) {\\r\\n                        const clientPostgresBinding = clientPostgresBindings[i];\\r\\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\\r\\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\\r\\n                        if (serverPostgresFilter &&\\r\\n                            serverPostgresFilter.event === event &&\\r\\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) &&\\r\\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) &&\\r\\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {\\r\\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\\r\\n                        }\\r\\n                        else {\\r\\n                            this.unsubscribe();\\r\\n                            this.state = constants_1.CHANNEL_STATES.errored;\\r\\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\\r\\n                            return;\\r\\n                        }\\r\\n                    }\\r\\n                    this.bindings.postgres_changes = newPostgresBindings;\\r\\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\\r\\n                    return;\\r\\n                }\\r\\n            })\\r\\n                .receive('error', (error) => {\\r\\n                this.state = constants_1.CHANNEL_STATES.errored;\\r\\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\\r\\n                return;\\r\\n            })\\r\\n                .receive('timeout', () => {\\r\\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\\r\\n                return;\\r\\n            });\\r\\n        }\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Returns the current presence state for this channel.\\r\\n     *\\r\\n     * The shape is a map keyed by presence key (for example a user id) where each entry contains the\\r\\n     * tracked metadata for that user.\\r\\n     */\\r\\n    presenceState() {\\r\\n        return this.presence.state;\\r\\n    }\\r\\n    /**\\r\\n     * Sends the supplied payload to the presence tracker so other subscribers can see that this\\r\\n     * client is online. Use `untrack` to stop broadcasting presence for the same key.\\r\\n     */\\r\\n    async track(payload, opts = {}) {\\r\\n        return await this.send({\\r\\n            type: 'presence',\\r\\n            event: 'track',\\r\\n            payload,\\r\\n        }, opts.timeout || this.timeout);\\r\\n    }\\r\\n    /**\\r\\n     * Removes the current presence state for this client.\\r\\n     */\\r\\n    async untrack(opts = {}) {\\r\\n        return await this.send({\\r\\n            type: 'presence',\\r\\n            event: 'untrack',\\r\\n        }, opts);\\r\\n    }\\r\\n    on(type, filter, callback) {\\r\\n        if (this.state === constants_1.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\\r\\n            this.socket.log('channel', `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\\r\\n            this.unsubscribe().then(async () => await this.subscribe());\\r\\n        }\\r\\n        return this._on(type, filter, callback);\\r\\n    }\\r\\n    /**\\r\\n     * Sends a broadcast message explicitly via REST API.\\r\\n     *\\r\\n     * This method always uses the REST API endpoint regardless of WebSocket connection state.\\r\\n     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\\r\\n     *\\r\\n     * @param event The name of the broadcast event\\r\\n     * @param payload Payload to be sent (required)\\r\\n     * @param opts Options including timeout\\r\\n     * @returns Promise resolving to object with success status, and error details if failed\\r\\n     */\\r\\n    async httpSend(event, payload, opts = {}) {\\r\\n        var _a;\\r\\n        if (payload === undefined || payload === null) {\\r\\n            return Promise.reject('Payload is required for httpSend()');\\r\\n        }\\r\\n        const headers = {\\r\\n            apikey: this.socket.apiKey ? this.socket.apiKey : '',\\r\\n            'Content-Type': 'application/json',\\r\\n        };\\r\\n        if (this.socket.accessTokenValue) {\\r\\n            headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`;\\r\\n        }\\r\\n        const options = {\\r\\n            method: 'POST',\\r\\n            headers,\\r\\n            body: JSON.stringify({\\r\\n                messages: [\\r\\n                    {\\r\\n                        topic: this.subTopic,\\r\\n                        event,\\r\\n                        payload: payload,\\r\\n                        private: this.private,\\r\\n                    },\\r\\n                ],\\r\\n            }),\\r\\n        };\\r\\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\\r\\n        if (response.status === 202) {\\r\\n            return { success: true };\\r\\n        }\\r\\n        let errorMessage = response.statusText;\\r\\n        try {\\r\\n            const errorBody = await response.json();\\r\\n            errorMessage = errorBody.error || errorBody.message || errorMessage;\\r\\n        }\\r\\n        catch (_b) { }\\r\\n        return Promise.reject(new Error(errorMessage));\\r\\n    }\\r\\n    /**\\r\\n     * Sends a message into the channel.\\r\\n     *\\r\\n     * @param args Arguments to send to channel\\r\\n     * @param args.type The type of event to send\\r\\n     * @param args.event The name of the event being sent\\r\\n     * @param args.payload Payload to be sent\\r\\n     * @param opts Options to be used during the send process\\r\\n     */\\r\\n    async send(args, opts = {}) {\\r\\n        var _a, _b;\\r\\n        if (!this._canPush() && args.type === 'broadcast') {\\r\\n            console.warn('Realtime send() is automatically falling back to REST API. ' +\\r\\n                'This behavior will be deprecated in the future. ' +\\r\\n                'Please use httpSend() explicitly for REST delivery.');\\r\\n            const { event, payload: endpoint_payload } = args;\\r\\n            const headers = {\\r\\n                apikey: this.socket.apiKey ? this.socket.apiKey : '',\\r\\n                'Content-Type': 'application/json',\\r\\n            };\\r\\n            if (this.socket.accessTokenValue) {\\r\\n                headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`;\\r\\n            }\\r\\n            const options = {\\r\\n                method: 'POST',\\r\\n                headers,\\r\\n                body: JSON.stringify({\\r\\n                    messages: [\\r\\n                        {\\r\\n                            topic: this.subTopic,\\r\\n                            event,\\r\\n                            payload: endpoint_payload,\\r\\n                            private: this.private,\\r\\n                        },\\r\\n                    ],\\r\\n                }),\\r\\n            };\\r\\n            try {\\r\\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\\r\\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\\r\\n                return response.ok ? 'ok' : 'error';\\r\\n            }\\r\\n            catch (error) {\\r\\n                if (error.name === 'AbortError') {\\r\\n                    return 'timed out';\\r\\n                }\\r\\n                else {\\r\\n                    return 'error';\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            return new Promise((resolve) => {\\r\\n                var _a, _b, _c;\\r\\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\\r\\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\\r\\n                    resolve('ok');\\r\\n                }\\r\\n                push.receive('ok', () => resolve('ok'));\\r\\n                push.receive('error', () => resolve('error'));\\r\\n                push.receive('timeout', () => resolve('timed out'));\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Updates the payload that will be sent the next time the channel joins (reconnects).\\r\\n     * Useful for rotating access tokens or updating config without re-creating the channel.\\r\\n     */\\r\\n    updateJoinPayload(payload) {\\r\\n        this.joinPush.updatePayload(payload);\\r\\n    }\\r\\n    /**\\r\\n     * Leaves the channel.\\r\\n     *\\r\\n     * Unsubscribes from server events, and instructs channel to terminate on server.\\r\\n     * Triggers onClose() hooks.\\r\\n     *\\r\\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\\r\\n     * channel.unsubscribe().receive(\\\"ok\\\", () => alert(\\\"left!\\\") )\\r\\n     */\\r\\n    unsubscribe(timeout = this.timeout) {\\r\\n        this.state = constants_1.CHANNEL_STATES.leaving;\\r\\n        const onClose = () => {\\r\\n            this.socket.log('channel', `leave ${this.topic}`);\\r\\n            this._trigger(constants_1.CHANNEL_EVENTS.close, 'leave', this._joinRef());\\r\\n        };\\r\\n        this.joinPush.destroy();\\r\\n        let leavePush = null;\\r\\n        return new Promise((resolve) => {\\r\\n            leavePush = new push_1.default(this, constants_1.CHANNEL_EVENTS.leave, {}, timeout);\\r\\n            leavePush\\r\\n                .receive('ok', () => {\\r\\n                onClose();\\r\\n                resolve('ok');\\r\\n            })\\r\\n                .receive('timeout', () => {\\r\\n                onClose();\\r\\n                resolve('timed out');\\r\\n            })\\r\\n                .receive('error', () => {\\r\\n                resolve('error');\\r\\n            });\\r\\n            leavePush.send();\\r\\n            if (!this._canPush()) {\\r\\n                leavePush.trigger('ok', {});\\r\\n            }\\r\\n        }).finally(() => {\\r\\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\\r\\n        });\\r\\n    }\\r\\n    /**\\r\\n     * Teardown the channel.\\r\\n     *\\r\\n     * Destroys and stops related timers.\\r\\n     */\\r\\n    teardown() {\\r\\n        this.pushBuffer.forEach((push) => push.destroy());\\r\\n        this.pushBuffer = [];\\r\\n        this.rejoinTimer.reset();\\r\\n        this.joinPush.destroy();\\r\\n        this.state = constants_1.CHANNEL_STATES.closed;\\r\\n        this.bindings = {};\\r\\n    }\\r\\n    /** @internal */\\r\\n    async _fetchWithTimeout(url, options, timeout) {\\r\\n        const controller = new AbortController();\\r\\n        const id = setTimeout(() => controller.abort(), timeout);\\r\\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\\r\\n        clearTimeout(id);\\r\\n        return response;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _push(event, payload, timeout = this.timeout) {\\r\\n        if (!this.joinedOnce) {\\r\\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\\r\\n        }\\r\\n        let pushEvent = new push_1.default(this, event, payload, timeout);\\r\\n        if (this._canPush()) {\\r\\n            pushEvent.send();\\r\\n        }\\r\\n        else {\\r\\n            this._addToPushBuffer(pushEvent);\\r\\n        }\\r\\n        return pushEvent;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _addToPushBuffer(pushEvent) {\\r\\n        pushEvent.startTimeout();\\r\\n        this.pushBuffer.push(pushEvent);\\r\\n        // Enforce buffer size limit\\r\\n        if (this.pushBuffer.length > constants_1.MAX_PUSH_BUFFER_SIZE) {\\r\\n            const removedPush = this.pushBuffer.shift();\\r\\n            if (removedPush) {\\r\\n                removedPush.destroy();\\r\\n                this.socket.log('channel', `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Overridable message hook\\r\\n     *\\r\\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\\r\\n     * Must return the payload, modified or unmodified.\\r\\n     *\\r\\n     * @internal\\r\\n     */\\r\\n    _onMessage(_event, payload, _ref) {\\r\\n        return payload;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _isMember(topic) {\\r\\n        return this.topic === topic;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _joinRef() {\\r\\n        return this.joinPush.ref;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _trigger(type, payload, ref) {\\r\\n        var _a, _b;\\r\\n        const typeLower = type.toLocaleLowerCase();\\r\\n        const { close, error, leave, join } = constants_1.CHANNEL_EVENTS;\\r\\n        const events = [close, error, leave, join];\\r\\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\\r\\n            return;\\r\\n        }\\r\\n        let handledPayload = this._onMessage(typeLower, payload, ref);\\r\\n        if (payload && !handledPayload) {\\r\\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\\r\\n        }\\r\\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\\r\\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\\r\\n                var _a, _b, _c;\\r\\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\\r\\n            }).map((bind) => bind.callback(handledPayload, ref));\\r\\n        }\\r\\n        else {\\r\\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\\r\\n                var _a, _b, _c, _d, _e, _f;\\r\\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\\r\\n                    if ('id' in bind) {\\r\\n                        const bindId = bind.id;\\r\\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\\r\\n                        return (bindId &&\\r\\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\\r\\n                            (bindEvent === '*' ||\\r\\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\\r\\n                    }\\r\\n                    else {\\r\\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\\r\\n                        return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    return bind.type.toLocaleLowerCase() === typeLower;\\r\\n                }\\r\\n            }).map((bind) => {\\r\\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\\r\\n                    const postgresChanges = handledPayload.data;\\r\\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\\r\\n                    const enrichedPayload = {\\r\\n                        schema: schema,\\r\\n                        table: table,\\r\\n                        commit_timestamp: commit_timestamp,\\r\\n                        eventType: type,\\r\\n                        new: {},\\r\\n                        old: {},\\r\\n                        errors: errors,\\r\\n                    };\\r\\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\\r\\n                }\\r\\n                bind.callback(handledPayload, ref);\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n    /** @internal */\\r\\n    _isClosed() {\\r\\n        return this.state === constants_1.CHANNEL_STATES.closed;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _isJoined() {\\r\\n        return this.state === constants_1.CHANNEL_STATES.joined;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _isJoining() {\\r\\n        return this.state === constants_1.CHANNEL_STATES.joining;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _isLeaving() {\\r\\n        return this.state === constants_1.CHANNEL_STATES.leaving;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _replyEventName(ref) {\\r\\n        return `chan_reply_${ref}`;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _on(type, filter, callback) {\\r\\n        const typeLower = type.toLocaleLowerCase();\\r\\n        const binding = {\\r\\n            type: typeLower,\\r\\n            filter: filter,\\r\\n            callback: callback,\\r\\n        };\\r\\n        if (this.bindings[typeLower]) {\\r\\n            this.bindings[typeLower].push(binding);\\r\\n        }\\r\\n        else {\\r\\n            this.bindings[typeLower] = [binding];\\r\\n        }\\r\\n        return this;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _off(type, filter) {\\r\\n        const typeLower = type.toLocaleLowerCase();\\r\\n        if (this.bindings[typeLower]) {\\r\\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\\r\\n                var _a;\\r\\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\\r\\n                    RealtimeChannel.isEqual(bind.filter, filter));\\r\\n            });\\r\\n        }\\r\\n        return this;\\r\\n    }\\r\\n    /** @internal */\\r\\n    static isEqual(obj1, obj2) {\\r\\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\\r\\n            return false;\\r\\n        }\\r\\n        for (const k in obj1) {\\r\\n            if (obj1[k] !== obj2[k]) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n    /**\\r\\n     * Compares two optional filter values for equality.\\r\\n     * Treats undefined, null, and empty string as equivalent empty values.\\r\\n     * @internal\\r\\n     */\\r\\n    static isFilterValueEqual(serverValue, clientValue) {\\r\\n        const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;\\r\\n        const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;\\r\\n        return normalizedServer === normalizedClient;\\r\\n    }\\r\\n    /** @internal */\\r\\n    _rejoinUntilConnected() {\\r\\n        this.rejoinTimer.scheduleTimeout();\\r\\n        if (this.socket.isConnected()) {\\r\\n            this._rejoin();\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Registers a callback that will be executed when the channel closes.\\r\\n     *\\r\\n     * @internal\\r\\n     */\\r\\n    _onClose(callback) {\\r\\n        this._on(constants_1.CHANNEL_EVENTS.close, {}, callback);\\r\\n    }\\r\\n    /**\\r\\n     * Registers a callback that will be executed when the channel encounteres an error.\\r\\n     *\\r\\n     * @internal\\r\\n     */\\r\\n    _onError(callback) {\\r\\n        this._on(constants_1.CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\\r\\n    }\\r\\n    /**\\r\\n     * Returns `true` if the socket is connected and the channel has been joined.\\r\\n     *\\r\\n     * @internal\\r\\n     */\\r\\n    _canPush() {\\r\\n        return this.socket.isConnected() && this._isJoined();\\r\\n    }\\r\\n    /** @internal */\\r\\n    _rejoin(timeout = this.timeout) {\\r\\n        if (this._isLeaving()) {\\r\\n            return;\\r\\n        }\\r\\n        this.socket._leaveOpenTopic(this.topic);\\r\\n        this.state = constants_1.CHANNEL_STATES.joining;\\r\\n        this.joinPush.resend(timeout);\\r\\n    }\\r\\n    /** @internal */\\r\\n    _getPayloadRecords(payload) {\\r\\n        const records = {\\r\\n            new: {},\\r\\n            old: {},\\r\\n        };\\r\\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\\r\\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\\r\\n        }\\r\\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\\r\\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\\r\\n        }\\r\\n        return records;\\r\\n    }\\r\\n}\\r\\nexports.default = RealtimeChannel;\\r\\n//# sourceMappingURL=RealtimeChannel.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"REALTIME_CHANNEL_STATES\",\"REALTIME_SUBSCRIBE_STATES\",\"REALTIME_LISTEN_TYPES\",\"REALTIME_POSTGRES_CHANGES_LISTEN_EVENT\",\"tslib_1\",\"constants_1\",\"push_1\",\"__importDefault\",\"timer_1\",\"RealtimePresence_1\",\"Transformers\",\"__importStar\",\"transformers_1\",\"CHANNEL_STATES\",\"RealtimeChannel\",\"constructor\",\"topic\",\"params\",\"config\",\"socket\",\"_a\",\"_b\",\"bindings\",\"state\",\"closed\",\"joinedOnce\",\"pushBuffer\",\"subTopic\",\"replace\",\"assign\",\"broadcast\",\"ack\",\"self\",\"presence\",\"key\",\"enabled\",\"private\",\"timeout\",\"joinPush\",\"default\",\"CHANNEL_EVENTS\",\"join\",\"rejoinTimer\",\"_rejoinUntilConnected\",\"reconnectAfterMs\",\"receive\",\"joined\",\"reset\",\"forEach\",\"pushEvent\",\"send\",\"_onClose\",\"log\",\"_joinRef\",\"_remove\",\"_onError\",\"reason\",\"_isLeaving\",\"_isClosed\",\"errored\",\"scheduleTimeout\",\"_isJoining\",\"_on\",\"reply\",\"payload\",\"ref\",\"_trigger\",\"_replyEventName\",\"broadcastEndpointURL\",\"httpEndpointURL\",\"endPoint\",\"replay\",\"subscribe\",\"callback\",\"_c\",\"isConnected\",\"connect\",\"isPrivate\",\"postgres_changes\",\"map\",\"r\",\"filter\",\"presence_enabled\",\"PRESENCE\",\"length\",\"accessTokenPayload\",\"accessTokenValue\",\"access_token\",\"e\",\"CHANNEL_ERROR\",\"CLOSED\",\"updateJoinPayload\",\"_rejoin\",\"_isManualToken\",\"setAuth\",\"undefined\",\"SUBSCRIBED\",\"clientPostgresBindings\",\"bindingsLen\",\"newPostgresBindings\",\"i\",\"clientPostgresBinding\",\"event\",\"schema\",\"table\",\"serverPostgresFilter\",\"isFilterValueEqual\",\"push\",\"id\",\"unsubscribe\",\"Error\",\"error\",\"JSON\",\"stringify\",\"values\",\"TIMED_OUT\",\"presenceState\",\"track\",\"opts\",\"type\",\"untrack\",\"on\",\"then\",\"httpSend\",\"Promise\",\"reject\",\"headers\",\"apikey\",\"apiKey\",\"options\",\"method\",\"body\",\"messages\",\"response\",\"_fetchWithTimeout\",\"status\",\"success\",\"errorMessage\",\"statusText\",\"errorBody\",\"json\",\"message\",\"args\",\"_canPush\",\"resolve\",\"_push\",\"console\",\"warn\",\"endpoint_payload\",\"cancel\",\"ok\",\"name\",\"updatePayload\",\"leaving\",\"onClose\",\"close\",\"destroy\",\"leavePush\",\"finally\",\"leave\",\"trigger\",\"teardown\",\"url\",\"controller\",\"AbortController\",\"setTimeout\",\"abort\",\"fetch\",\"signal\",\"clearTimeout\",\"_addToPushBuffer\",\"startTimeout\",\"MAX_PUSH_BUFFER_SIZE\",\"removedPush\",\"shift\",\"_onMessage\",\"_event\",\"_ref\",\"_isMember\",\"typeLower\",\"toLocaleLowerCase\",\"events\",\"indexOf\",\"handledPayload\",\"includes\",\"bind\",\"_e\",\"_f\",\"bindId\",\"bindEvent\",\"ids\",\"data\",\"_d\",\"postgresChanges\",\"commit_timestamp\",\"errors\",\"enrichedPayload\",\"eventType\",\"new\",\"old\",\"_getPayloadRecords\",\"_isJoined\",\"joining\",\"binding\",\"_off\",\"isEqual\",\"obj1\",\"obj2\",\"keys\",\"k\",\"serverValue\",\"clientValue\",\"normalizedServer\",\"normalizedClient\",\"_leaveOpenTopic\",\"resend\",\"records\",\"convertChangeData\",\"columns\",\"record\",\"old_record\"]\n}\n"]