["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/realtime-js/dist/main/RealtimeChannel.js"],"~:js","shadow$provide[28]=function(I,R,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.REALTIME_CHANNEL_STATES=a.REALTIME_SUBSCRIBE_STATES=a.REALTIME_LISTEN_TYPES=a.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT=void 0;R=I(14);const G=I(22),l=R.__importDefault(I(26)),x=R.__importDefault(I(24)),w=R.__importDefault(I(27)),z=R.__importStar(I(25)),y=I(25);var F;(function(f){f.ALL=\"*\";f.INSERT=\"INSERT\";f.UPDATE=\"UPDATE\";f.DELETE=\"DELETE\"})(F||(a.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT=F={}));var b;(function(f){f.BROADCAST=\n\"broadcast\";f.PRESENCE=\"presence\";f.POSTGRES_CHANGES=\"postgres_changes\";f.SYSTEM=\"system\"})(b||(a.REALTIME_LISTEN_TYPES=b={}));var D;(function(f){f.SUBSCRIBED=\"SUBSCRIBED\";f.TIMED_OUT=\"TIMED_OUT\";f.CLOSED=\"CLOSED\";f.CHANNEL_ERROR=\"CHANNEL_ERROR\"})(D||(a.REALTIME_SUBSCRIBE_STATES=D={}));a.REALTIME_CHANNEL_STATES=G.CHANNEL_STATES;class k{constructor(f,t={config:{}},n){var v,A;this.topic=f;this.params=t;this.socket=n;this.bindings={};this.state=G.CHANNEL_STATES.closed;this.joinedOnce=!1;this.pushBuffer=\n[];this.subTopic=f.replace(/^realtime:/i,\"\");this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:\"\",enabled:!1},private:!1},t.config);this.timeout=this.socket.timeout;this.joinPush=new l.default(this,G.CHANNEL_EVENTS.join,this.params,this.timeout);this.rejoinTimer=new x.default(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs);this.joinPush.receive(\"ok\",()=>{this.state=G.CHANNEL_STATES.joined;this.rejoinTimer.reset();this.pushBuffer.forEach(h=>h.send());this.pushBuffer=\n[]});this._onClose(()=>{this.rejoinTimer.reset();this.socket.log(\"channel\",`close ${this.topic} ${this._joinRef()}`);this.state=G.CHANNEL_STATES.closed;this.socket._remove(this)});this._onError(h=>{this._isLeaving()||this._isClosed()||(this.socket.log(\"channel\",`error ${this.topic}`,h),this.state=G.CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())});this.joinPush.receive(\"timeout\",()=>{this._isJoining()&&(this.socket.log(\"channel\",`timeout ${this.topic}`,this.joinPush.timeout),this.state=\nG.CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())});this.joinPush.receive(\"error\",h=>{this._isLeaving()||this._isClosed()||(this.socket.log(\"channel\",`error ${this.topic}`,h),this.state=G.CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())});this._on(G.CHANNEL_EVENTS.reply,{},(h,m)=>{this._trigger(this._replyEventName(m),h)});this.presence=new w.default(this);this.broadcastEndpointURL=(0,y.httpEndpointURL)(this.socket.endPoint);this.private=this.params.config.private||!1;if(!this.private&&\n((A=(v=this.params.config)===null||v===void 0?void 0:v.broadcast)===null||A===void 0?0:A.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`;}subscribe(f,t=this.timeout){var n,v,A;this.socket.isConnected()||this.socket.connect();if(this.state==G.CHANNEL_STATES.closed){const {config:{broadcast:m,presence:r,private:p}}=this.params;var h=(v=(n=this.bindings.postgres_changes)===null||n===void 0?void 0:n.map(u=>u.filter))!==null&&v!==void 0?v:[];n=!!this.bindings[b.PRESENCE]&&\nthis.bindings[b.PRESENCE].length>0||((A=this.params.config.presence)===null||A===void 0?void 0:A.enabled)===!0;A={};h={broadcast:m,presence:Object.assign(Object.assign({},r),{enabled:n}),postgres_changes:h,private:p};this.socket.accessTokenValue&&(A.access_token=this.socket.accessTokenValue);this._onError(u=>f===null||f===void 0?void 0:f(D.CHANNEL_ERROR,u));this._onClose(()=>f===null||f===void 0?void 0:f(D.CLOSED));this.updateJoinPayload(Object.assign({config:h},A));this.joinedOnce=!0;this._rejoin(t);\nthis.joinPush.receive(\"ok\",async({postgres_changes:u})=>{var C;this.socket._isManualToken()||this.socket.setAuth();if(u===void 0)f===null||f===void 0||f(D.SUBSCRIBED);else{const E=this.bindings.postgres_changes,H=(C=E===null||E===void 0?void 0:E.length)!==null&&C!==void 0?C:0;C=[];for(let K=0;K<H;K++){const P=E[K],{filter:{event:N,schema:M,table:Q,filter:U}}=P,X=u&&u[K];if(X&&X.event===N&&k.isFilterValueEqual(X.schema,M)&&k.isFilterValueEqual(X.table,Q)&&k.isFilterValueEqual(X.filter,U))C.push(Object.assign(Object.assign({},\nP),{id:X.id}));else{this.unsubscribe();this.state=G.CHANNEL_STATES.errored;f===null||f===void 0||f(D.CHANNEL_ERROR,Error(\"mismatch between server and client bindings for postgres changes\"));return}}this.bindings.postgres_changes=C;f&&f(D.SUBSCRIBED)}}).receive(\"error\",u=>{this.state=G.CHANNEL_STATES.errored;f===null||f===void 0||f(D.CHANNEL_ERROR,Error(JSON.stringify(Object.values(u).join(\", \")||\"error\")))}).receive(\"timeout\",()=>{f===null||f===void 0||f(D.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(f,\nt={}){return await this.send({type:\"presence\",event:\"track\",payload:f},t.timeout||this.timeout)}async untrack(f={}){return await this.send({type:\"presence\",event:\"untrack\"},f)}on(f,t,n){this.state===G.CHANNEL_STATES.joined&&f===b.PRESENCE&&(this.socket.log(\"channel\",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(async()=>await this.subscribe()));return this._on(f,t,n)}async httpSend(f,t,n={}){var v;if(t===void 0||t===null)return Promise.reject(\"Payload is required for httpSend()\");\nconst A={apikey:this.socket.apiKey?this.socket.apiKey:\"\",\"Content-Type\":\"application/json\"};this.socket.accessTokenValue&&(A.Authorization=`Bearer ${this.socket.accessTokenValue}`);f={method:\"POST\",headers:A,body:JSON.stringify({messages:[{topic:this.subTopic,event:f,payload:t,private:this.private}]})};n=await this._fetchWithTimeout(this.broadcastEndpointURL,f,(v=n.timeout)!==null&&v!==void 0?v:this.timeout);if(n.status===202)return{success:!0};v=n.statusText;try{const h=await n.json();v=h.error||\nh.message||v}catch(h){}return Promise.reject(Error(v))}async send(f,t={}){var n,v;if(this._canPush()||f.type!==\"broadcast\")return new Promise(r=>{var p,u,C;const E=this._push(f.type,f,t.timeout||this.timeout);f.type!==\"broadcast\"||((C=(u=(p=this.params)===null||p===void 0?void 0:p.config)===null||u===void 0?void 0:u.broadcast)===null||C===void 0?0:C.ack)||r(\"ok\");E.receive(\"ok\",()=>r(\"ok\"));E.receive(\"error\",()=>r(\"error\"));E.receive(\"timeout\",()=>r(\"timed out\"))});console.warn(\"Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.\");\nconst {event:A,payload:h}=f;var m={apikey:this.socket.apiKey?this.socket.apiKey:\"\",\"Content-Type\":\"application/json\"};this.socket.accessTokenValue&&(m.Authorization=`Bearer ${this.socket.accessTokenValue}`);m={method:\"POST\",headers:m,body:JSON.stringify({messages:[{topic:this.subTopic,event:A,payload:h,private:this.private}]})};try{const r=await this._fetchWithTimeout(this.broadcastEndpointURL,m,(n=t.timeout)!==null&&n!==void 0?n:this.timeout);await ((v=r.body)===null||v===void 0?void 0:v.cancel());\nreturn r.ok?\"ok\":\"error\"}catch(r){return r.name===\"AbortError\"?\"timed out\":\"error\"}}updateJoinPayload(f){this.joinPush.updatePayload(f)}unsubscribe(f=this.timeout){this.state=G.CHANNEL_STATES.leaving;const t=()=>{this.socket.log(\"channel\",`leave ${this.topic}`);this._trigger(G.CHANNEL_EVENTS.close,\"leave\",this._joinRef())};this.joinPush.destroy();let n=null;return(new Promise(v=>{n=new l.default(this,G.CHANNEL_EVENTS.leave,{},f);n.receive(\"ok\",()=>{t();v(\"ok\")}).receive(\"timeout\",()=>{t();v(\"timed out\")}).receive(\"error\",\n()=>{v(\"error\")});n.send();this._canPush()||n.trigger(\"ok\",{})})).finally(()=>{n===null||n===void 0||n.destroy()})}teardown(){this.pushBuffer.forEach(f=>f.destroy());this.pushBuffer=[];this.rejoinTimer.reset();this.joinPush.destroy();this.state=G.CHANNEL_STATES.closed;this.bindings={}}async _fetchWithTimeout(f,t,n){const v=new AbortController;n=setTimeout(()=>v.abort(),n);f=await this.socket.fetch(f,Object.assign(Object.assign({},t),{signal:v.signal}));clearTimeout(n);return f}_push(f,t,n=this.timeout){if(!this.joinedOnce)throw`tried to push '${f}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\nf=new l.default(this,f,t,n);this._canPush()?f.send():this._addToPushBuffer(f);return f}_addToPushBuffer(f){f.startTimeout();this.pushBuffer.push(f);this.pushBuffer.length>G.MAX_PUSH_BUFFER_SIZE&&(f=this.pushBuffer.shift())&&(f.destroy(),this.socket.log(\"channel\",`discarded push due to buffer overflow: ${f.event}`,f.payload))}_onMessage(f,t,n){return t}_isMember(f){return this.topic===f}_joinRef(){return this.joinPush.ref}_trigger(f,t,n){var v,A;const h=f.toLocaleLowerCase(),{close:m,error:r,leave:p,\njoin:u}=G.CHANNEL_EVENTS;f=[m,r,p,u];if(!(n&&f.indexOf(h)>=0&&n!==this._joinRef())){var C=this._onMessage(h,t,n);if(t&&!C)throw\"channel onMessage callbacks must return the payload, modified or unmodified\";[\"insert\",\"update\",\"delete\"].includes(h)?(v=this.bindings.postgres_changes)===null||v===void 0||v.filter(E=>{var H,K,P;return((H=E.filter)===null||H===void 0?void 0:H.event)===\"*\"||((P=(K=E.filter)===null||K===void 0?void 0:K.event)===null||P===void 0?void 0:P.toLocaleLowerCase())===h}).map(E=>E.callback(C,\nn)):(A=this.bindings[h])===null||A===void 0||A.filter(E=>{var H,K,P,N,M;if([\"broadcast\",\"presence\",\"postgres_changes\"].includes(h)){if(\"id\"in E){var Q=E.id;E=(H=E.filter)===null||H===void 0?void 0:H.event;return Q&&((K=t.ids)===null||K===void 0?void 0:K.includes(Q))&&(E===\"*\"||(E===null||E===void 0?void 0:E.toLocaleLowerCase())===((P=t.data)===null||P===void 0?void 0:P.type.toLocaleLowerCase()))}H=(N=(Q=E===null||E===void 0?void 0:E.filter)===null||Q===void 0?void 0:Q.event)===null||N===void 0?void 0:\nN.toLocaleLowerCase();return H===\"*\"||H===((M=t===null||t===void 0?void 0:t.event)===null||M===void 0?void 0:M.toLocaleLowerCase())}return E.type.toLocaleLowerCase()===h}).map(E=>{if(typeof C===\"object\"&&\"ids\"in C){const H=C.data,{schema:K,table:P,commit_timestamp:N,type:M,errors:Q}=H;C=Object.assign(Object.assign({},{schema:K,table:P,commit_timestamp:N,eventType:M,new:{},old:{},errors:Q}),this._getPayloadRecords(H))}E.callback(C,n)})}}_isClosed(){return this.state===G.CHANNEL_STATES.closed}_isJoined(){return this.state===\nG.CHANNEL_STATES.joined}_isJoining(){return this.state===G.CHANNEL_STATES.joining}_isLeaving(){return this.state===G.CHANNEL_STATES.leaving}_replyEventName(f){return`chan_reply_${f}`}_on(f,t,n){f=f.toLocaleLowerCase();t={type:f,filter:t,callback:n};this.bindings[f]?this.bindings[f].push(t):this.bindings[f]=[t];return this}_off(f,t){const n=f.toLocaleLowerCase();this.bindings[n]&&(this.bindings[n]=this.bindings[n].filter(v=>{var A;return!(((A=v.type)===null||A===void 0?void 0:A.toLocaleLowerCase())===\nn&&k.isEqual(v.filter,t))}));return this}static isEqual(f,t){if(Object.keys(f).length!==Object.keys(t).length)return!1;for(const n in f)if(f[n]!==t[n])return!1;return!0}static isFilterValueEqual(f,t){return(f!==null&&f!==void 0?f:void 0)===(t!==null&&t!==void 0?t:void 0)}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout();this.socket.isConnected()&&this._rejoin()}_onClose(f){this._on(G.CHANNEL_EVENTS.close,{},f)}_onError(f){this._on(G.CHANNEL_EVENTS.error,{},t=>f(t))}_canPush(){return this.socket.isConnected()&&\nthis._isJoined()}_rejoin(f=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=G.CHANNEL_STATES.joining,this.joinPush.resend(f))}_getPayloadRecords(f){const t={new:{},old:{}};if(f.type===\"INSERT\"||f.type===\"UPDATE\")t.new=z.convertChangeData(f.columns,f.record);if(f.type===\"UPDATE\"||f.type===\"DELETE\")t.old=z.convertChangeData(f.columns,f.old_record);return t}}a.default=k}","~:source","shadow$provide[28] = function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.REALTIME_CHANNEL_STATES = exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_LISTEN_TYPES = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = void 0;\nconst tslib_1 = require(\"tslib\");\nconst constants_1 = require(\"./lib/constants\");\nconst push_1 = tslib_1.__importDefault(require(\"./lib/push\"));\nconst timer_1 = tslib_1.__importDefault(require(\"./lib/timer\"));\nconst RealtimePresence_1 = tslib_1.__importDefault(require(\"./RealtimePresence\"));\nconst Transformers = tslib_1.__importStar(require(\"./lib/transformers\"));\nconst transformers_1 = require(\"./lib/transformers\");\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (exports.REALTIME_LISTEN_TYPES = REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (exports.REALTIME_SUBSCRIBE_STATES = REALTIME_SUBSCRIBE_STATES = {}));\nexports.REALTIME_CHANNEL_STATES = constants_1.CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nclass RealtimeChannel {\n    /**\n     * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.\n     *\n     * The topic determines which realtime stream you are subscribing to. Config options let you\n     * enable acknowledgement for broadcasts, presence tracking, or private channels.\n     *\n     * @example\n     * ```ts\n     * import RealtimeClient from '@supabase/realtime-js'\n     *\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\n     *   params: { apikey: 'public-anon-key' },\n     * })\n     * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)\n     * ```\n     */\n    constructor(\n    /** Topic name can be any string. */\n    topic, params = { config: {} }, socket) {\n        var _a, _b;\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = constants_1.CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, '');\n        this.params.config = Object.assign({\n            broadcast: { ack: false, self: false },\n            presence: { key: '', enabled: false },\n            private: false,\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new push_1.default(this, constants_1.CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new timer_1.default(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = constants_1.CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n            this.state = constants_1.CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = constants_1.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = constants_1.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('error', (reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = constants_1.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(constants_1.CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new RealtimePresence_1.default(this);\n        this.broadcastEndpointURL = (0, transformers_1.httpEndpointURL)(this.socket.endPoint);\n        this.private = this.params.config.private || false;\n        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\n            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;\n        }\n    }\n    /** Subscribe registers your client with the server */\n    subscribe(callback, timeout = this.timeout) {\n        var _a, _b, _c;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.state == constants_1.CHANNEL_STATES.closed) {\n            const { config: { broadcast, presence, private: isPrivate }, } = this.params;\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [];\n            const presence_enabled = (!!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] &&\n                this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0) ||\n                ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),\n                postgres_changes,\n                private: isPrivate,\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush\n                .receive('ok', async ({ postgres_changes }) => {\n                var _a;\n                // Only refresh auth if using callback-based tokens\n                if (!this.socket._isManualToken()) {\n                    this.socket.setAuth();\n                }\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n                else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for (let i = 0; i < bindingsLen; i++) {\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter &&\n                            serverPostgresFilter.event === event &&\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) &&\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) &&\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n                        }\n                        else {\n                            this.unsubscribe();\n                            this.state = constants_1.CHANNEL_STATES.errored;\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            })\n                .receive('error', (error) => {\n                this.state = constants_1.CHANNEL_STATES.errored;\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n                return;\n            })\n                .receive('timeout', () => {\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    /**\n     * Returns the current presence state for this channel.\n     *\n     * The shape is a map keyed by presence key (for example a user id) where each entry contains the\n     * tracked metadata for that user.\n     */\n    presenceState() {\n        return this.presence.state;\n    }\n    /**\n     * Sends the supplied payload to the presence tracker so other subscribers can see that this\n     * client is online. Use `untrack` to stop broadcasting presence for the same key.\n     */\n    async track(payload, opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'track',\n            payload,\n        }, opts.timeout || this.timeout);\n    }\n    /**\n     * Removes the current presence state for this client.\n     */\n    async untrack(opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'untrack',\n        }, opts);\n    }\n    on(type, filter, callback) {\n        if (this.state === constants_1.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\n            this.socket.log('channel', `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n            this.unsubscribe().then(async () => await this.subscribe());\n        }\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a broadcast message explicitly via REST API.\n     *\n     * This method always uses the REST API endpoint regardless of WebSocket connection state.\n     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\n     *\n     * @param event The name of the broadcast event\n     * @param payload Payload to be sent (required)\n     * @param opts Options including timeout\n     * @returns Promise resolving to object with success status, and error details if failed\n     */\n    async httpSend(event, payload, opts = {}) {\n        var _a;\n        if (payload === undefined || payload === null) {\n            return Promise.reject('Payload is required for httpSend()');\n        }\n        const headers = {\n            apikey: this.socket.apiKey ? this.socket.apiKey : '',\n            'Content-Type': 'application/json',\n        };\n        if (this.socket.accessTokenValue) {\n            headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`;\n        }\n        const options = {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({\n                messages: [\n                    {\n                        topic: this.subTopic,\n                        event,\n                        payload: payload,\n                        private: this.private,\n                    },\n                ],\n            }),\n        };\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n        if (response.status === 202) {\n            return { success: true };\n        }\n        let errorMessage = response.statusText;\n        try {\n            const errorBody = await response.json();\n            errorMessage = errorBody.error || errorBody.message || errorMessage;\n        }\n        catch (_b) { }\n        return Promise.reject(new Error(errorMessage));\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */\n    async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === 'broadcast') {\n            console.warn('Realtime send() is automatically falling back to REST API. ' +\n                'This behavior will be deprecated in the future. ' +\n                'Please use httpSend() explicitly for REST delivery.');\n            const { event, payload: endpoint_payload } = args;\n            const headers = {\n                apikey: this.socket.apiKey ? this.socket.apiKey : '',\n                'Content-Type': 'application/json',\n            };\n            if (this.socket.accessTokenValue) {\n                headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`;\n            }\n            const options = {\n                method: 'POST',\n                headers,\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private,\n                        },\n                    ],\n                }),\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? 'ok' : 'error';\n            }\n            catch (error) {\n                if (error.name === 'AbortError') {\n                    return 'timed out';\n                }\n                else {\n                    return 'error';\n                }\n            }\n        }\n        else {\n            return new Promise((resolve) => {\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve('ok');\n                }\n                push.receive('ok', () => resolve('ok'));\n                push.receive('error', () => resolve('error'));\n                push.receive('timeout', () => resolve('timed out'));\n            });\n        }\n    }\n    /**\n     * Updates the payload that will be sent the next time the channel joins (reconnects).\n     * Useful for rotating access tokens or updating config without re-creating the channel.\n     */\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = constants_1.CHANNEL_STATES.leaving;\n        const onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this._trigger(constants_1.CHANNEL_EVENTS.close, 'leave', this._joinRef());\n        };\n        this.joinPush.destroy();\n        let leavePush = null;\n        return new Promise((resolve) => {\n            leavePush = new push_1.default(this, constants_1.CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush\n                .receive('ok', () => {\n                onClose();\n                resolve('ok');\n            })\n                .receive('timeout', () => {\n                onClose();\n                resolve('timed out');\n            })\n                .receive('error', () => {\n                resolve('error');\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger('ok', {});\n            }\n        }).finally(() => {\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n        });\n    }\n    /**\n     * Teardown the channel.\n     *\n     * Destroys and stops related timers.\n     */\n    teardown() {\n        this.pushBuffer.forEach((push) => push.destroy());\n        this.pushBuffer = [];\n        this.rejoinTimer.reset();\n        this.joinPush.destroy();\n        this.state = constants_1.CHANNEL_STATES.closed;\n        this.bindings = {};\n    }\n    /** @internal */\n    async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(() => controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */\n    _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new push_1.default(this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        }\n        else {\n            this._addToPushBuffer(pushEvent);\n        }\n        return pushEvent;\n    }\n    /** @internal */\n    _addToPushBuffer(pushEvent) {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n        // Enforce buffer size limit\n        if (this.pushBuffer.length > constants_1.MAX_PUSH_BUFFER_SIZE) {\n            const removedPush = this.pushBuffer.shift();\n            if (removedPush) {\n                removedPush.destroy();\n                this.socket.log('channel', `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n            }\n        }\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */\n    _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */\n    _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */\n    _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */\n    _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = constants_1.CHANNEL_EVENTS;\n        const events = [close, error, leave, join];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n                var _a, _b, _c;\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n            }).map((bind) => bind.callback(handledPayload, ref));\n        }\n        else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n                var _a, _b, _c, _d, _e, _f;\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n                    if ('id' in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return (bindId &&\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\n                            (bindEvent === '*' ||\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\n                    }\n                    else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n                    }\n                }\n                else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind) => {\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors,\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */\n    _isClosed() {\n        return this.state === constants_1.CHANNEL_STATES.closed;\n    }\n    /** @internal */\n    _isJoined() {\n        return this.state === constants_1.CHANNEL_STATES.joined;\n    }\n    /** @internal */\n    _isJoining() {\n        return this.state === constants_1.CHANNEL_STATES.joining;\n    }\n    /** @internal */\n    _isLeaving() {\n        return this.state === constants_1.CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n    _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */\n    _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback,\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        }\n        else {\n            this.bindings[typeLower] = [binding];\n        }\n        return this;\n    }\n    /** @internal */\n    _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n                var _a;\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\n                    RealtimeChannel.isEqual(bind.filter, filter));\n            });\n        }\n        return this;\n    }\n    /** @internal */\n    static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (const k in obj1) {\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Compares two optional filter values for equality.\n     * Treats undefined, null, and empty string as equivalent empty values.\n     * @internal\n     */\n    static isFilterValueEqual(serverValue, clientValue) {\n        const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;\n        const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;\n        return normalizedServer === normalizedClient;\n    }\n    /** @internal */\n    _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */\n    _onClose(callback) {\n        this._on(constants_1.CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */\n    _onError(callback) {\n        this._on(constants_1.CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */\n    _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n    _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = constants_1.CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */\n    _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {},\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n}\nexports.default = RealtimeChannel;\n//# sourceMappingURL=RealtimeChannel.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$supabase$realtime_js$dist$main$lib$timer","~$module$node_modules$$supabase$realtime_js$dist$main$RealtimePresence","~$module$node_modules$tslib$tslib","~$module$node_modules$$supabase$realtime_js$dist$main$lib$push","~$module$node_modules$$supabase$realtime_js$dist$main$lib$transformers","~$shadow.js","~$module$node_modules$$supabase$realtime_js$dist$main$lib$constants"]],"~:properties",["^5",["table","success","callback","bindings","body","rejoinTimer","config","params","joinPush","apikey","REALTIME_LISTEN_TYPES","postgres_changes","method","key","access_token","__esModule","private","new","eventType","schema","enabled","id","pushBuffer","event","errors","REALTIME_CHANNEL_STATES","signal","ack","subTopic","joinedOnce","value","broadcast","timeout","REALTIME_SUBSCRIBE_STATES","old","filter","self","broadcastEndpointURL","type","presence","state","messages","socket","payload","default","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","commit_timestamp","topic","headers"]],"~:compiled-at",1771725993760,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$realtime_js$dist$main$RealtimeChannel.js\",\n\"lineCount\":22,\n\"mappings\":\"AAAAA,cAAA,CAAe,EAAf,CAAA,CAAqB,QAAQ,CAACC,CAAD,CAASC,CAAT,CAAgBC,CAAhB,CAAyB,CAEtDC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CACAH,EAAQI,CAAAA,uBAAR,CAAkCJ,CAAQK,CAAAA,yBAA1C,CAAsEL,CAAQM,CAAAA,qBAA9E,CAAsGN,CAAQO,CAAAA,sCAA9G,CAAuJ,IAAK,EACtJC,EAAAA,CAAUV,CAAA,CAAQ,EAAR,CAChB,OAAMW,EAAcX,CAAA,CAAQ,EAAR,CAApB,CACMY,EAASF,CAAQG,CAAAA,eAAR,CAAwBb,CAAA,CAAQ,EAAR,CAAxB,CADf,CAEMc,EAAUJ,CAAQG,CAAAA,eAAR,CAAwBb,CAAA,CAAQ,EAAR,CAAxB,CAFhB,CAGMe,EAAqBL,CAAQG,CAAAA,eAAR,CAAwBb,CAAA,CAAQ,EAAR,CAAxB,CAH3B,CAIMgB,EAAeN,CAAQO,CAAAA,YAAR,CAAqBjB,CAAA,CAAQ,EAAR,CAArB,CAJrB,CAKMkB,EAAiBlB,CAAA,CAAQ,EAAR,CACvB,KAAIS,CACH,UAAS,CAACA,CAAD,CAAyC,CAC/CA,CAAA,CAAA,GAAA,CAAgD,GAChDA,EAAA,CAAA,MAAA,CAAmD,QACnDA,EAAA,CAAA,MAAA,CAAmD,QACnDA,EAAA,CAAA,MAAA,CAAmD,QAJJ,CAAlD,CAAD,CAKGA,CALH,GAK8CP,CAAQO,CAAAA,sCALtD,CAK+FA,CAL/F,CAKwI,EALxI,EAMA,KAAID,CACH,UAAS,CAACA,CAAD,CAAwB,CAC9BA,CAAA,CAAA,SAAA;AAAqC,WACrCA,EAAA,CAAA,QAAA,CAAoC,UACpCA,EAAA,CAAA,gBAAA,CAA4C,kBAC5CA,EAAA,CAAA,MAAA,CAAkC,QAJJ,CAAjC,CAAD,CAKGA,CALH,GAK6BN,CAAQM,CAAAA,qBALrC,CAK6DA,CAL7D,CAKqF,EALrF,EAMA,KAAID,CACH,UAAS,CAACA,CAAD,CAA4B,CAClCA,CAAA,CAAA,UAAA,CAA0C,YAC1CA,EAAA,CAAA,SAAA,CAAyC,WACzCA,EAAA,CAAA,MAAA,CAAsC,QACtCA,EAAA,CAAA,aAAA,CAA6C,eAJX,CAArC,CAAD,CAKGA,CALH,GAKiCL,CAAQK,CAAAA,yBALzC,CAKqEA,CALrE,CAKiG,EALjG,EAMAL,EAAQI,CAAAA,uBAAR,CAAkCK,CAAYQ,CAAAA,cAM9C,MAAMC,EAAN,CAiBIC,WAAW,CAEXC,CAFW,CAEJC,CAAA,CAAS,CAAEC,OAAQ,EAAV,CAFL,CAEqBC,CAFrB,CAE6B,CAAA,IAChCC,CADgC,CAC5BC,CACR,KAAKL,CAAAA,KAAL,CAAaA,CACb,KAAKC,CAAAA,MAAL,CAAcA,CACd,KAAKE,CAAAA,MAAL,CAAcA,CACd,KAAKG,CAAAA,QAAL,CAAgB,EAChB,KAAKC,CAAAA,KAAL,CAAalB,CAAYQ,CAAAA,cAAeW,CAAAA,MACxC,KAAKC,CAAAA,UAAL,CAAkB,CAAA,CAClB,KAAKC,CAAAA,UAAL;AAAkB,EAClB,KAAKC,CAAAA,QAAL,CAAgBX,CAAMY,CAAAA,OAAN,CAAc,aAAd,CAA6B,EAA7B,CAChB,KAAKX,CAAAA,MAAOC,CAAAA,MAAZ,CAAqBrB,MAAOgC,CAAAA,MAAP,CAAc,CAC/BC,UAAW,CAAEC,IAAK,CAAA,CAAP,CAAcC,KAAM,CAAA,CAApB,CADoB,CAE/BC,SAAU,CAAEC,IAAK,EAAP,CAAWC,QAAS,CAAA,CAApB,CAFqB,CAG/BC,QAAS,CAAA,CAHsB,CAAd,CAIlBnB,CAAOC,CAAAA,MAJW,CAKrB,KAAKmB,CAAAA,OAAL,CAAe,IAAKlB,CAAAA,MAAOkB,CAAAA,OAC3B,KAAKC,CAAAA,QAAL,CAAgB,IAAIhC,CAAOiC,CAAAA,OAAX,CAAmB,IAAnB,CAAyBlC,CAAYmC,CAAAA,cAAeC,CAAAA,IAApD,CAA0D,IAAKxB,CAAAA,MAA/D,CAAuE,IAAKoB,CAAAA,OAA5E,CAChB,KAAKK,CAAAA,WAAL,CAAmB,IAAIlC,CAAQ+B,CAAAA,OAAZ,CAAoB,EAAA,EAAM,IAAKI,CAAAA,qBAAL,EAA1B,CAAwD,IAAKxB,CAAAA,MAAOyB,CAAAA,gBAApE,CACnB,KAAKN,CAAAA,QAASO,CAAAA,OAAd,CAAsB,IAAtB,CAA4B,EAAA,EAAM,CAC9B,IAAKtB,CAAAA,KAAL,CAAalB,CAAYQ,CAAAA,cAAeiC,CAAAA,MACxC,KAAKJ,CAAAA,WAAYK,CAAAA,KAAjB,EACA,KAAKrB,CAAAA,UAAWsB,CAAAA,OAAhB,CAAyBC,CAAD,EAAeA,CAAUC,CAAAA,IAAV,EAAvC,CACA,KAAKxB,CAAAA,UAAL;AAAkB,EAJY,CAAlC,CAMA,KAAKyB,CAAAA,QAAL,CAAc,EAAA,EAAM,CAChB,IAAKT,CAAAA,WAAYK,CAAAA,KAAjB,EACA,KAAK5B,CAAAA,MAAOiC,CAAAA,GAAZ,CAAgB,SAAhB,CAA4B,SAAQ,IAAKpC,CAAAA,KAAb,IAAsB,IAAKqC,CAAAA,QAAL,EAAtB,EAA5B,CACA,KAAK9B,CAAAA,KAAL,CAAalB,CAAYQ,CAAAA,cAAeW,CAAAA,MACxC,KAAKL,CAAAA,MAAOmC,CAAAA,OAAZ,CAAoB,IAApB,CAJgB,CAApB,CAMA,KAAKC,CAAAA,QAAL,CAAeC,CAAD,EAAY,CAClB,IAAKC,CAAAA,UAAL,EAAJ,EAAyB,IAAKC,CAAAA,SAAL,EAAzB,GAGA,IAAKvC,CAAAA,MAAOiC,CAAAA,GAAZ,CAAgB,SAAhB,CAA4B,SAAQ,IAAKpC,CAAAA,KAAb,EAA5B,CAAkDwC,CAAlD,CAEA,CADA,IAAKjC,CAAAA,KACL,CADalB,CAAYQ,CAAAA,cAAe8C,CAAAA,OACxC,CAAA,IAAKjB,CAAAA,WAAYkB,CAAAA,eAAjB,EALA,CADsB,CAA1B,CAQA,KAAKtB,CAAAA,QAASO,CAAAA,OAAd,CAAsB,SAAtB,CAAiC,EAAA,EAAM,CAC9B,IAAKgB,CAAAA,UAAL,EAAL,GAGA,IAAK1C,CAAAA,MAAOiC,CAAAA,GAAZ,CAAgB,SAAhB,CAA4B,WAAU,IAAKpC,CAAAA,KAAf,EAA5B,CAAoD,IAAKsB,CAAAA,QAASD,CAAAA,OAAlE,CAEA,CADA,IAAKd,CAAAA,KACL;AADalB,CAAYQ,CAAAA,cAAe8C,CAAAA,OACxC,CAAA,IAAKjB,CAAAA,WAAYkB,CAAAA,eAAjB,EALA,CADmC,CAAvC,CAQA,KAAKtB,CAAAA,QAASO,CAAAA,OAAd,CAAsB,OAAtB,CAAgCW,CAAD,EAAY,CACnC,IAAKC,CAAAA,UAAL,EAAJ,EAAyB,IAAKC,CAAAA,SAAL,EAAzB,GAGA,IAAKvC,CAAAA,MAAOiC,CAAAA,GAAZ,CAAgB,SAAhB,CAA4B,SAAQ,IAAKpC,CAAAA,KAAb,EAA5B,CAAkDwC,CAAlD,CAEA,CADA,IAAKjC,CAAAA,KACL,CADalB,CAAYQ,CAAAA,cAAe8C,CAAAA,OACxC,CAAA,IAAKjB,CAAAA,WAAYkB,CAAAA,eAAjB,EALA,CADuC,CAA3C,CAQA,KAAKE,CAAAA,GAAL,CAASzD,CAAYmC,CAAAA,cAAeuB,CAAAA,KAApC,CAA2C,EAA3C,CAA+C,CAACC,CAAD,CAAUC,CAAV,CAAA,EAAkB,CAC7D,IAAKC,CAAAA,QAAL,CAAc,IAAKC,CAAAA,eAAL,CAAqBF,CAArB,CAAd,CAAyCD,CAAzC,CAD6D,CAAjE,CAGA,KAAK/B,CAAAA,QAAL,CAAgB,IAAIxB,CAAmB8B,CAAAA,OAAvB,CAA+B,IAA/B,CAChB,KAAK6B,CAAAA,oBAAL,CAA4B,GAAIxD,CAAeyD,CAAAA,eAAnB,EAAoC,IAAKlD,CAAAA,MAAOmD,CAAAA,QAAhD,CAC5B,KAAKlC,CAAAA,OAAL,CAAe,IAAKnB,CAAAA,MAAOC,CAAAA,MAAOkB,CAAAA,OAAlC,EAA6C,CAAA,CAC7C,IAAI,CAAC,IAAKA,CAAAA,OAAV;CAAsB,CAACf,CAAD,CAAM,CAACD,CAAD,CAAM,IAAKH,CAAAA,MAAOC,CAAAA,MAAlB,IAA8B,IAA9B,EAAsCE,CAAtC,GAA6C,IAAK,EAAlD,CAAsD,IAAK,EAA3D,CAA+DA,CAAGU,CAAAA,SAAxE,IAAuF,IAAvF,EAA+FT,CAA/F,GAAsG,IAAK,EAA3G,CAA+G,CAA/G,CAAwHA,CAAGkD,CAAAA,MAAjJ,EACI,KAAO,0CAAyC,IAAKvD,CAAAA,KAA9C,kCAAP,CA7DgC,CAiExCwD,SAAS,CAACC,CAAD,CAAWpC,CAAA,CAAU,IAAKA,CAAAA,OAA1B,CAAmC,CAAA,IACpCjB,CADoC,CAChCC,CADgC,CAC5BqD,CACP,KAAKvD,CAAAA,MAAOwD,CAAAA,WAAZ,EAAL,EACI,IAAKxD,CAAAA,MAAOyD,CAAAA,OAAZ,EAEJ,IAAI,IAAKrD,CAAAA,KAAT,EAAkBlB,CAAYQ,CAAAA,cAAeW,CAAAA,MAA7C,CAAqD,CACjD,MAAM,CAAE,OAAQ,CAAE,UAAAM,CAAF,CAAa,SAAAG,CAAb,CAAuB,QAAS4C,CAAhC,CAAV,CAAA,CAA2D,IAAK5D,CAAAA,MACtE,KAAM6D,EAAmB,CAACzD,CAAD,CAAM,CAACD,CAAD,CAAM,IAAKE,CAAAA,QAASwD,CAAAA,gBAApB,IAA0C,IAA1C,EAAkD1D,CAAlD,GAAyD,IAAK,EAA9D,CAAkE,IAAK,EAAvE,CAA2EA,CAAG2D,CAAAA,GAAH,CAAQC,CAAD,EAAOA,CAAEC,CAAAA,MAAhB,CAAjF,IAA8G,IAA9G,EAAsH5D,CAAtH,GAA6H,IAAK,EAAlI,CAAsIA,CAAtI,CAA2I,EAC9J6D,EAAAA,CAAoB,CAAC,CAAC,IAAK5D,CAAAA,QAAL,CAAcpB,CAAsBiF,CAAAA,QAApC,CAAtBD;AACF,IAAK5D,CAAAA,QAAL,CAAcpB,CAAsBiF,CAAAA,QAApC,CAA8CC,CAAAA,MAD5CF,CACqD,CADrDA,GAED,CAACR,CAAD,CAAM,IAAKzD,CAAAA,MAAOC,CAAAA,MAAOe,CAAAA,QAAzB,IAAuC,IAAvC,EAA+CyC,CAA/C,GAAsD,IAAK,EAA3D,CAA+D,IAAK,EAApE,CAAwEA,CAAGvC,CAAAA,OAF1E+C,IAEuF,CAAA,CACvFG,EAAAA,CAAqB,EACrBnE,EAAAA,CAAS,CACXY,UAAAA,CADW,CAEXG,SAAUpC,MAAOgC,CAAAA,MAAP,CAAchC,MAAOgC,CAAAA,MAAP,CAAc,EAAd,CAAkBI,CAAlB,CAAd,CAA2C,CAAEE,QAAS+C,CAAX,CAA3C,CAFC,CAGXJ,iBAAAA,CAHW,CAIX1C,QAASyC,CAJE,CAMX,KAAK1D,CAAAA,MAAOmE,CAAAA,gBAAhB,GACID,CAAmBE,CAAAA,YADvB,CACsC,IAAKpE,CAAAA,MAAOmE,CAAAA,gBADlD,CAGA,KAAK/B,CAAAA,QAAL,CAAeiC,CAAD,EAAOf,CAAA,GAAa,IAAb,EAAqBA,CAArB,GAAkC,IAAK,EAAvC,CAA2C,IAAK,EAAhD,CAAoDA,CAAA,CAASxE,CAA0BwF,CAAAA,aAAnC,CAAkDD,CAAlD,CAAzE,CACA,KAAKrC,CAAAA,QAAL,CAAc,EAAA,EAAMsB,CAAA,GAAa,IAAb,EAAqBA,CAArB,GAAkC,IAAK,EAAvC,CAA2C,IAAK,EAAhD,CAAoDA,CAAA,CAASxE,CAA0ByF,CAAAA,MAAnC,CAAxE,CACA,KAAKC,CAAAA,iBAAL,CAAuB9F,MAAOgC,CAAAA,MAAP,CAAc,CAAEX,OAAAA,CAAF,CAAd,CAA0BmE,CAA1B,CAAvB,CACA,KAAK5D,CAAAA,UAAL,CAAkB,CAAA,CAClB,KAAKmE,CAAAA,OAAL,CAAavD,CAAb,CACA;IAAKC,CAAAA,QACAO,CAAAA,OADL,CACa,IADb,CACmB,KAAM,CAAC,CAAE,iBAAAiC,CAAF,CAAD,CAAN,EAAgC,CAC/C,IAAI1D,CAEC,KAAKD,CAAAA,MAAO0E,CAAAA,cAAZ,EAAL,EACI,IAAK1E,CAAAA,MAAO2E,CAAAA,OAAZ,EAEJ,IAAIhB,CAAJ,GAAyBiB,IAAAA,EAAzB,CACItB,CAAA,GAAa,IAAb,EAAqBA,CAArB,GAAkC,IAAK,EAAvC,EAAoDA,CAAA,CAASxE,CAA0B+F,CAAAA,UAAnC,CADxD,KAIK,CACD,MAAMC,EAAyB,IAAK3E,CAAAA,QAASwD,CAAAA,gBAA7C,CACMoB,EAAc,CAAC9E,CAAD,CAAM6E,CAAA,GAA2B,IAA3B,EAAmCA,CAAnC,GAA8D,IAAK,EAAnE,CAAuE,IAAK,EAA5E,CAAgFA,CAAuBb,CAAAA,MAA7G,IAAyH,IAAzH,EAAiIhE,CAAjI,GAAwI,IAAK,EAA7I,CAAiJA,CAAjJ,CAAsJ,CACpK+E,EAAAA,CAAsB,EAC5B,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBF,CAApB,CAAiCE,CAAA,EAAjC,CAAsC,CAClC,MAAMC,EAAwBJ,CAAA,CAAuBG,CAAvB,CAA9B,CACM,CAAE,OAAQ,CAAE,MAAAE,CAAF,CAAS,OAAAC,CAAT,CAAiB,MAAAC,CAAjB,CAAwB,OAAAvB,CAAxB,CAAV,CAAA,CAAgDoB,CADtD,CAEMI,EAAuB3B,CAAvB2B,EAA2C3B,CAAA,CAAiBsB,CAAjB,CACjD,IAAIK,CAAJ,EACIA,CAAqBH,CAAAA,KADzB,GACmCA,CADnC,EAEIxF,CAAgB4F,CAAAA,kBAAhB,CAAmCD,CAAqBF,CAAAA,MAAxD,CAAgEA,CAAhE,CAFJ,EAGIzF,CAAgB4F,CAAAA,kBAAhB,CAAmCD,CAAqBD,CAAAA,KAAxD,CAA+DA,CAA/D,CAHJ,EAII1F,CAAgB4F,CAAAA,kBAAhB,CAAmCD,CAAqBxB,CAAAA,MAAxD,CAAgEA,CAAhE,CAJJ,CAKIkB,CAAoBQ,CAAAA,IAApB,CAAyB9G,MAAOgC,CAAAA,MAAP,CAAchC,MAAOgC,CAAAA,MAAP,CAAc,EAAd;AAAkBwE,CAAlB,CAAd,CAAwD,CAAEO,GAAIH,CAAqBG,CAAAA,EAA3B,CAAxD,CAAzB,CALJ,KAOK,CACD,IAAKC,CAAAA,WAAL,EACA,KAAKtF,CAAAA,KAAL,CAAalB,CAAYQ,CAAAA,cAAe8C,CAAAA,OACxCc,EAAA,GAAa,IAAb,EAAqBA,CAArB,GAAkC,IAAK,EAAvC,EAAoDA,CAAA,CAASxE,CAA0BwF,CAAAA,aAAnC,CAAsDqB,KAAJ,CAAU,kEAAV,CAAlD,CACpD,OAJC,CAX6B,CAkBtC,IAAKxF,CAAAA,QAASwD,CAAAA,gBAAd,CAAiCqB,CACjC1B,EAAA,EAAYA,CAAA,CAASxE,CAA0B+F,CAAAA,UAAnC,CAvBX,CAV0C,CADnD,CAsCKnD,CAAAA,OAtCL,CAsCa,OAtCb,CAsCuBkE,CAAD,EAAW,CAC7B,IAAKxF,CAAAA,KAAL,CAAalB,CAAYQ,CAAAA,cAAe8C,CAAAA,OACxCc,EAAA,GAAa,IAAb,EAAqBA,CAArB,GAAkC,IAAK,EAAvC,EAAoDA,CAAA,CAASxE,CAA0BwF,CAAAA,aAAnC,CAAsDqB,KAAJ,CAAUE,IAAKC,CAAAA,SAAL,CAAepH,MAAOqH,CAAAA,MAAP,CAAcH,CAAd,CAAqBtE,CAAAA,IAArB,CAA0B,IAA1B,CAAf,EAAkD,OAAlD,CAAV,CAAlD,CAFvB,CAtCjC,CA2CKI,CAAAA,OA3CL,CA2Ca,SA3Cb,CA2CwB,EAAA,EAAM,CAC1B4B,CAAA,GAAa,IAAb,EAAqBA,CAArB,GAAkC,IAAK,EAAvC,EAAoDA,CAAA,CAASxE,CAA0BkH,CAAAA,SAAnC,CAD1B,CA3C9B,CArBiD,CAqErD,MAAO,KA1EiC,CAkF5CC,aAAa,EAAG,CACZ,MAAO,KAAKnF,CAAAA,QAASV,CAAAA,KADT,CAOV8F,WAAK,CAACrD,CAAD;AAAUsD,CAAA,CAAO,EAAjB,CAAqB,CAC5B,MAAO,OAAM,IAAKpE,CAAAA,IAAL,CAAU,CACnBqE,KAAM,UADa,CAEnBjB,MAAO,OAFY,CAGnBtC,QAAAA,CAHmB,CAAV,CAIVsD,CAAKjF,CAAAA,OAJK,EAIM,IAAKA,CAAAA,OAJX,CADe,CAU1BmF,aAAO,CAACF,CAAA,CAAO,EAAR,CAAY,CACrB,MAAO,OAAM,IAAKpE,CAAAA,IAAL,CAAU,CACnBqE,KAAM,UADa,CAEnBjB,MAAO,SAFY,CAAV,CAGVgB,CAHU,CADQ,CAMzBG,EAAE,CAACF,CAAD,CAAOtC,CAAP,CAAeR,CAAf,CAAyB,CACnB,IAAKlD,CAAAA,KAAT,GAAmBlB,CAAYQ,CAAAA,cAAeiC,CAAAA,MAA9C,EAAwDyE,CAAxD,GAAiErH,CAAsBiF,CAAAA,QAAvF,GACI,IAAKhE,CAAAA,MAAOiC,CAAAA,GAAZ,CAAgB,SAAhB,CAA4B,kBAAiB,IAAKpC,CAAAA,KAAtB,wDAA5B,CACA,CAAA,IAAK6F,CAAAA,WAAL,EAAmBa,CAAAA,IAAnB,CAAwB,KAAM,EAAN,EAAY,MAAM,IAAKlD,CAAAA,SAAL,EAA1C,CAFJ,CAIA,OAAO,KAAKV,CAAAA,GAAL,CAASyD,CAAT,CAAetC,CAAf,CAAuBR,CAAvB,CALgB,CAkBrBkD,cAAQ,CAACrB,CAAD,CAAQtC,CAAR,CAAiBsD,CAAA,CAAO,EAAxB,CAA4B,CACtC,IAAIlG,CACJ,IAAI4C,CAAJ,GAAgB+B,IAAAA,EAAhB,EAA6B/B,CAA7B,GAAyC,IAAzC,CACI,MAAO4D,QAAQC,CAAAA,MAAR,CAAe,oCAAf,CAEX;MAAMC,EAAU,CACZC,OAAQ,IAAK5G,CAAAA,MAAO6G,CAAAA,MAAZ,CAAqB,IAAK7G,CAAAA,MAAO6G,CAAAA,MAAjC,CAA0C,EADtC,CAEZ,eAAgB,kBAFJ,CAIZ,KAAK7G,CAAAA,MAAOmE,CAAAA,gBAAhB,GACIwC,CAAA,CAAA,aADJ,CACgC,UAAS,IAAK3G,CAAAA,MAAOmE,CAAAA,gBAArB,EADhC,CAGM2C,EAAAA,CAAU,CACZC,OAAQ,MADI,CAEZJ,QAAAA,CAFY,CAGZK,KAAMnB,IAAKC,CAAAA,SAAL,CAAe,CACjBmB,SAAU,CACN,CACIpH,MAAO,IAAKW,CAAAA,QADhB,CAEI2E,MAAAA,CAFJ,CAGItC,QAASA,CAHb,CAII5B,QAAS,IAAKA,CAAAA,OAJlB,CADM,CADO,CAAf,CAHM,CAcViG,EAAAA,CAAW,MAAM,IAAKC,CAAAA,iBAAL,CAAuB,IAAKlE,CAAAA,oBAA5B,CAAkD6D,CAAlD,CAA2D,CAAC7G,CAAD,CAAMkG,CAAKjF,CAAAA,OAAX,IAAwB,IAAxB,EAAgCjB,CAAhC,GAAuC,IAAK,EAA5C,CAAgDA,CAAhD,CAAqD,IAAKiB,CAAAA,OAArH,CACvB,IAAIgG,CAASE,CAAAA,MAAb,GAAwB,GAAxB,CACI,MAAO,CAAEC,QAAS,CAAA,CAAX,CAEPC,EAAAA,CAAeJ,CAASK,CAAAA,UAC5B,IAAI,CACA,MAAMC,EAAY,MAAMN,CAASO,CAAAA,IAAT,EACxBH,EAAA,CAAeE,CAAU5B,CAAAA,KAAzB;AAAkC4B,CAAUE,CAAAA,OAA5C,EAAuDJ,CAFvD,CAIJ,MAAOpH,CAAP,CAAW,EACX,MAAOuG,QAAQC,CAAAA,MAAR,CAAmBf,KAAJ,CAAU2B,CAAV,CAAf,CApC+B,CA+CpCvF,UAAI,CAAC4F,CAAD,CAAOxB,CAAA,CAAO,EAAd,CAAkB,CAAA,IACpBlG,CADoB,CAChBC,CACR,IAAK,IAAK0H,CAAAA,QAAL,EAAL,EAAwBD,CAAKvB,CAAAA,IAA7B,GAAsC,WAAtC,CAyCI,MAAO,KAAIK,OAAJ,CAAaoB,CAAD,EAAa,CAAA,IACxB5H,CADwB,CACpBC,CADoB,CAChBqD,CACZ,OAAMiC,EAAO,IAAKsC,CAAAA,KAAL,CAAWH,CAAKvB,CAAAA,IAAhB,CAAsBuB,CAAtB,CAA4BxB,CAAKjF,CAAAA,OAAjC,EAA4C,IAAKA,CAAAA,OAAjD,CACTyG,EAAKvB,CAAAA,IAAT,GAAkB,WAAlB,GAAmC,CAAC7C,CAAD,CAAM,CAACrD,CAAD,CAAM,CAACD,CAAD,CAAM,IAAKH,CAAAA,MAAX,IAAuB,IAAvB,EAA+BG,CAA/B,GAAsC,IAAK,EAA3C,CAA+C,IAAK,EAApD,CAAwDA,CAAGF,CAAAA,MAAjE,IAA6E,IAA7E,EAAqFG,CAArF,GAA4F,IAAK,EAAjG,CAAqG,IAAK,EAA1G,CAA8GA,CAAGS,CAAAA,SAAvH,IAAsI,IAAtI,EAA8I4C,CAA9I,GAAqJ,IAAK,EAA1J,CAA8J,CAA9J,CAAuKA,CAAG3C,CAAAA,GAA7M,GACIiH,CAAA,CAAQ,IAAR,CAEJrC,EAAK9D,CAAAA,OAAL,CAAa,IAAb,CAAmB,EAAA,EAAMmG,CAAA,CAAQ,IAAR,CAAzB,CACArC,EAAK9D,CAAAA,OAAL,CAAa,OAAb,CAAsB,EAAA,EAAMmG,CAAA,CAAQ,OAAR,CAA5B,CACArC,EAAK9D,CAAAA,OAAL,CAAa,SAAb,CAAwB,EAAA,EAAMmG,CAAA,CAAQ,WAAR,CAA9B,CAR4B,CAAzB,CAxCPE,QAAQC,CAAAA,IAAR,CAAa,gKAAb,CAGA;MAAM,CAAE,MAAA7C,CAAF,CAAS,QAAS8C,CAAlB,CAAA,CAAuCN,CAC7C,KAAMhB,EAAU,CACZC,OAAQ,IAAK5G,CAAAA,MAAO6G,CAAAA,MAAZ,CAAqB,IAAK7G,CAAAA,MAAO6G,CAAAA,MAAjC,CAA0C,EADtC,CAEZ,eAAgB,kBAFJ,CAIZ,KAAK7G,CAAAA,MAAOmE,CAAAA,gBAAhB,GACIwC,CAAA,CAAA,aADJ,CACgC,UAAS,IAAK3G,CAAAA,MAAOmE,CAAAA,gBAArB,EADhC,CAGM2C,EAAAA,CAAU,CACZC,OAAQ,MADI,CAEZJ,QAAAA,CAFY,CAGZK,KAAMnB,IAAKC,CAAAA,SAAL,CAAe,CACjBmB,SAAU,CACN,CACIpH,MAAO,IAAKW,CAAAA,QADhB,CAEI2E,MAAAA,CAFJ,CAGItC,QAASoF,CAHb,CAIIhH,QAAS,IAAKA,CAAAA,OAJlB,CADM,CADO,CAAf,CAHM,CAchB,IAAI,CACA,MAAMiG,EAAW,MAAM,IAAKC,CAAAA,iBAAL,CAAuB,IAAKlE,CAAAA,oBAA5B,CAAkD6D,CAAlD,CAA2D,CAAC7G,CAAD,CAAMkG,CAAKjF,CAAAA,OAAX,IAAwB,IAAxB,EAAgCjB,CAAhC,GAAuC,IAAK,EAA5C,CAAgDA,CAAhD,CAAqD,IAAKiB,CAAAA,OAArH,CACvB,QAAO,CAAChB,CAAD,CAAMgH,CAASF,CAAAA,IAAf,IAAyB,IAAzB,EAAiC9G,CAAjC,GAAwC,IAAK,EAA7C,CAAiD,IAAK,EAAtD,CAA0DA,CAAGgI,CAAAA,MAAH,EAAjE,CACA;MAAOhB,EAASiB,CAAAA,EAAT,CAAc,IAAd,CAAqB,OAH5B,CAKJ,MAAOvC,CAAP,CAAc,CACV,MAAIA,EAAMwC,CAAAA,IAAV,GAAmB,YAAnB,CACW,WADX,CAIW,OALD,CAjCM,CA2D5B5D,iBAAiB,CAAC3B,CAAD,CAAU,CACvB,IAAK1B,CAAAA,QAASkH,CAAAA,aAAd,CAA4BxF,CAA5B,CADuB,CAY3B6C,WAAW,CAACxE,CAAA,CAAU,IAAKA,CAAAA,OAAhB,CAAyB,CAChC,IAAKd,CAAAA,KAAL,CAAalB,CAAYQ,CAAAA,cAAe4I,CAAAA,OACxC,OAAMC,EAAU,EAAAA,EAAM,CAClB,IAAKvI,CAAAA,MAAOiC,CAAAA,GAAZ,CAAgB,SAAhB,CAA4B,SAAQ,IAAKpC,CAAAA,KAAb,EAA5B,CACA,KAAKkD,CAAAA,QAAL,CAAc7D,CAAYmC,CAAAA,cAAemH,CAAAA,KAAzC,CAAgD,OAAhD,CAAyD,IAAKtG,CAAAA,QAAL,EAAzD,CAFkB,CAItB,KAAKf,CAAAA,QAASsH,CAAAA,OAAd,EACA,KAAIC,EAAY,IAChB,OAkBGC,CAlBI,IAAIlC,OAAJ,CAAaoB,CAAD,EAAa,CAC5Ba,CAAA,CAAY,IAAIvJ,CAAOiC,CAAAA,OAAX,CAAmB,IAAnB,CAAyBlC,CAAYmC,CAAAA,cAAeuH,CAAAA,KAApD,CAA2D,EAA3D,CAA+D1H,CAA/D,CACZwH,EACKhH,CAAAA,OADL,CACa,IADb,CACmB,EAAA,EAAM,CACrB6G,CAAA,EACAV,EAAA,CAAQ,IAAR,CAFqB,CADzB,CAKKnG,CAAAA,OALL,CAKa,SALb,CAKwB,EAAA,EAAM,CAC1B6G,CAAA,EACAV,EAAA,CAAQ,WAAR,CAF0B,CAL9B,CASKnG,CAAAA,OATL,CASa,OATb;AASsB,EAAA,EAAM,CACxBmG,CAAA,CAAQ,OAAR,CADwB,CAT5B,CAYAa,EAAU3G,CAAAA,IAAV,EACK,KAAK6F,CAAAA,QAAL,EAAL,EACIc,CAAUG,CAAAA,OAAV,CAAkB,IAAlB,CAAwB,EAAxB,CAhBwB,CAAzB,CAkBJF,EAAAA,OAlBI,CAkBI,EAAA,EAAM,CACbD,CAAA,GAAc,IAAd,EAAsBA,CAAtB,GAAoC,IAAK,EAAzC,EAAsDA,CAAUD,CAAAA,OAAV,EADzC,CAlBV,CARyB,CAmCpCK,QAAQ,EAAG,CACP,IAAKvI,CAAAA,UAAWsB,CAAAA,OAAhB,CAAyB2D,CAAD,EAAUA,CAAKiD,CAAAA,OAAL,EAAlC,CACA,KAAKlI,CAAAA,UAAL,CAAkB,EAClB,KAAKgB,CAAAA,WAAYK,CAAAA,KAAjB,EACA,KAAKT,CAAAA,QAASsH,CAAAA,OAAd,EACA,KAAKrI,CAAAA,KAAL,CAAalB,CAAYQ,CAAAA,cAAeW,CAAAA,MACxC,KAAKF,CAAAA,QAAL,CAAgB,EANT,CASLgH,uBAAiB,CAAC4B,CAAD,CAAMjC,CAAN,CAAe5F,CAAf,CAAwB,CAC3C,MAAM8H,EAAa,IAAIC,eACjBxD,EAAAA,CAAKyD,UAAA,CAAW,EAAA,EAAMF,CAAWG,CAAAA,KAAX,EAAjB,CAAqCjI,CAArC,CACLgG,EAAAA,CAAW,MAAM,IAAKlH,CAAAA,MAAOoJ,CAAAA,KAAZ,CAAkBL,CAAlB,CAAuBrK,MAAOgC,CAAAA,MAAP,CAAchC,MAAOgC,CAAAA,MAAP,CAAc,EAAd,CAAkBoG,CAAlB,CAAd,CAA0C,CAAEuC,OAAQL,CAAWK,CAAAA,MAArB,CAA1C,CAAvB,CACvBC,aAAA,CAAa7D,CAAb,CACA,OAAOyB,EALoC,CAQ/CY,KAAK,CAAC3C,CAAD,CAAQtC,CAAR,CAAiB3B,CAAA,CAAU,IAAKA,CAAAA,OAAhC,CAAyC,CAC1C,GAAI,CAAC,IAAKZ,CAAAA,UAAV,CACI,KAAO,kBAAiB6E,CAAjB,SAA+B,IAAKtF,CAAAA,KAApC,iEAAP;AAEAiC,CAAAA,CAAY,IAAI3C,CAAOiC,CAAAA,OAAX,CAAmB,IAAnB,CAAyB+D,CAAzB,CAAgCtC,CAAhC,CAAyC3B,CAAzC,CACZ,KAAK0G,CAAAA,QAAL,EAAJ,CACI9F,CAAUC,CAAAA,IAAV,EADJ,CAII,IAAKwH,CAAAA,gBAAL,CAAsBzH,CAAtB,CAEJ,OAAOA,EAXmC,CAc9CyH,gBAAgB,CAACzH,CAAD,CAAY,CACxBA,CAAU0H,CAAAA,YAAV,EACA,KAAKjJ,CAAAA,UAAWiF,CAAAA,IAAhB,CAAqB1D,CAArB,CAEI,KAAKvB,CAAAA,UAAW0D,CAAAA,MAApB,CAA6B/E,CAAYuK,CAAAA,oBAAzC,GACUC,CADV,CACwB,IAAKnJ,CAAAA,UAAWoJ,CAAAA,KAAhB,EADxB,IAGQD,CAAYjB,CAAAA,OAAZ,EACA,CAAA,IAAKzI,CAAAA,MAAOiC,CAAAA,GAAZ,CAAgB,SAAhB,CAA4B,0CAAyCyH,CAAYvE,CAAAA,KAArD,EAA5B,CAA0FuE,CAAY7G,CAAAA,OAAtG,CAJR,CAJwB,CAoB5B+G,UAAU,CAACC,CAAD,CAAShH,CAAT,CAAkBiH,CAAlB,CAAwB,CAC9B,MAAOjH,EADuB,CAIlCkH,SAAS,CAAClK,CAAD,CAAQ,CACb,MAAO,KAAKA,CAAAA,KAAZ,GAAsBA,CADT,CAIjBqC,QAAQ,EAAG,CACP,MAAO,KAAKf,CAAAA,QAAS2B,CAAAA,GADd,CAIXC,QAAQ,CAACqD,CAAD,CAAOvD,CAAP,CAAgBC,CAAhB,CAAqB,CAAA,IACrB7C,CADqB,CACjBC,CACR,OAAM8J,EAAY5D,CAAK6D,CAAAA,iBAAL,EAAlB,CACM,CAAE,MAAAzB,CAAF,CAAS,MAAA5C,CAAT,CAAgB,MAAAgD,CAAhB;AAAuB,KAAAtH,CAAvB,CAAA,CAAgCpC,CAAYmC,CAAAA,cAC5C6I,EAAAA,CAAS,CAAC1B,CAAD,CAAQ5C,CAAR,CAAegD,CAAf,CAAsBtH,CAAtB,CACf,IAAI,EAAAwB,CAAA,EAAOoH,CAAOC,CAAAA,OAAP,CAAeH,CAAf,CAAP,EAAoC,CAApC,EAAyClH,CAAzC,GAAiD,IAAKZ,CAAAA,QAAL,EAAjD,CAAJ,CAAA,CAGA,IAAIkI,EAAiB,IAAKR,CAAAA,UAAL,CAAgBI,CAAhB,CAA2BnH,CAA3B,CAAoCC,CAApC,CACrB,IAAID,CAAJ,EAAe,CAACuH,CAAhB,CACI,KAAM,6EAAN,CAEA,CAAC,QAAD,CAAW,QAAX,CAAqB,QAArB,CAA+BC,CAAAA,QAA/B,CAAwCL,CAAxC,CAAJ,EACK/J,CADL,CACU,IAAKE,CAAAA,QAASwD,CAAAA,gBADxB,IAC8C,IAD9C,EACsD1D,CADtD,GAC6D,IAAK,EADlE,EAC+EA,CAAG6D,CAAAA,MAAH,CAAWwG,CAAD,EAAU,CAAA,IACvFrK,CADuF,CACnFC,CADmF,CAC/EqD,CACZ,QAAQ,CAACtD,CAAD,CAAMqK,CAAKxG,CAAAA,MAAX,IAAuB,IAAvB,EAA+B7D,CAA/B,GAAsC,IAAK,EAA3C,CAA+C,IAAK,EAApD,CAAwDA,CAAGkF,CAAAA,KAAnE,IAA8E,GAA9E,GAAsF,CAAC5B,CAAD,CAAM,CAACrD,CAAD,CAAMoK,CAAKxG,CAAAA,MAAX,IAAuB,IAAvB,EAA+B5D,CAA/B,GAAsC,IAAK,EAA3C,CAA+C,IAAK,EAApD,CAAwDA,CAAGiF,CAAAA,KAAjE,IAA4E,IAA5E,EAAoF5B,CAApF,GAA2F,IAAK,EAAhG,CAAoG,IAAK,EAAzG,CAA6GA,CAAG0G,CAAAA,iBAAH,EAAnM,IAA+ND,CAFpI,CAApB,CAGxEpG,CAAAA,GAHwE,CAGnE0G,CAAD,EAAUA,CAAKhH,CAAAA,QAAL,CAAc8G,CAAd;AAA8BtH,CAA9B,CAH0D,CAD/E,EAOK5C,CAPL,CAOU,IAAKC,CAAAA,QAAL,CAAc6J,CAAd,CAPV,IAOwC,IAPxC,EAOgD9J,CAPhD,GAOuD,IAAK,EAP5D,EAOyEA,CAAG4D,CAAAA,MAAH,CAAWwG,CAAD,EAAU,CAAA,IACjFrK,CADiF,CAC7EC,CAD6E,CACzEqD,CADyE,CACjEgH,CADiE,CAC7DC,CACxB,IAAI,CAAC,WAAD,CAAc,UAAd,CAA0B,kBAA1B,CAA8CH,CAAAA,QAA9C,CAAuDL,CAAvD,CAAJ,CAAuE,CACnE,GAAI,IAAJ,EAAYM,EAAZ,CAAkB,CACRG,IAAAA,EAASH,CAAK7E,CAAAA,EACdiF,EAAAA,CAAY,CAACzK,CAAD,CAAMqK,CAAKxG,CAAAA,MAAX,IAAuB,IAAvB,EAA+B7D,CAA/B,GAAsC,IAAK,EAA3C,CAA+C,IAAK,EAApD,CAAwDA,CAAGkF,CAAAA,KAC7E,OAAQsF,EAAR,GACK,CAACvK,CAAD,CAAM2C,CAAQ8H,CAAAA,GAAd,IAAuB,IAAvB,EAA+BzK,CAA/B,GAAsC,IAAK,EAA3C,CAA+C,IAAK,EAApD,CAAwDA,CAAGmK,CAAAA,QAAH,CAAYI,CAAZ,CAD7D,IAEKC,CAFL,GAEmB,GAFnB,GAGSA,CAAA,GAAc,IAAd,EAAsBA,CAAtB,GAAoC,IAAK,EAAzC,CAA6C,IAAK,EAAlD,CAAsDA,CAAUT,CAAAA,iBAAV,EAH/D,KAGmG,CAAC1G,CAAD,CAAMV,CAAQ+H,CAAAA,IAAd,IAAwB,IAAxB,EAAgCrH,CAAhC,GAAuC,IAAK,EAA5C,CAAgD,IAAK,EAArD,CAAyDA,CAAG6C,CAAAA,IAAK6D,CAAAA,iBAAR,EAH5J,EAHc,CASRS,CAAAA,CAAY,CAACH,CAAD,CAAM,CAACM,CAAD,CAAMP,CAAA,GAAS,IAAT,EAAiBA,CAAjB,GAA0B,IAAK,EAA/B,CAAmC,IAAK,EAAxC,CAA4CA,CAAKxG,CAAAA,MAAvD,IAAmE,IAAnE,EAA2E+G,CAA3E,GAAkF,IAAK,EAAvF,CAA2F,IAAK,EAAhG,CAAoGA,CAAG1F,CAAAA,KAA7G,IAAwH,IAAxH,EAAgIoF,CAAhI,GAAuI,IAAK,EAA5I,CAAgJ,IAAK,EAArJ;AAAyJA,CAAGN,CAAAA,iBAAH,EAC3K,OAAOS,EAAP,GAAqB,GAArB,EAA4BA,CAA5B,IAA2C,CAACF,CAAD,CAAM3H,CAAA,GAAY,IAAZ,EAAoBA,CAApB,GAAgC,IAAK,EAArC,CAAyC,IAAK,EAA9C,CAAkDA,CAAQsC,CAAAA,KAAhE,IAA2E,IAA3E,EAAmFqF,CAAnF,GAA0F,IAAK,EAA/F,CAAmG,IAAK,EAAxG,CAA4GA,CAAGP,CAAAA,iBAAH,EAAvJ,CAX+D,CAenE,MAAOK,EAAKlE,CAAAA,IAAK6D,CAAAA,iBAAV,EAAP,GAAyCD,CAjBwC,CAApB,CAmBlEpG,CAAAA,GAnBkE,CAmB7D0G,CAAD,EAAU,CACb,GAAI,MAAOF,EAAX,GAA8B,QAA9B,EAA0C,KAA1C,EAAmDA,EAAnD,CAAmE,CAC/D,MAAMU,EAAkBV,CAAeQ,CAAAA,IAAvC,CACM,CAAE,OAAAxF,CAAF,CAAU,MAAAC,CAAV,CAAiB,iBAAA0F,CAAjB,CAAmC,KAAA3E,CAAnC,CAAyC,OAAA4E,CAAzC,CAAA,CAAoDF,CAU1DV,EAAA,CAAiB1L,MAAOgC,CAAAA,MAAP,CAAchC,MAAOgC,CAAAA,MAAP,CAAc,EAAd,CATPuK,CACpB7F,OAAQA,CADY6F,CAEpB5F,MAAOA,CAFa4F,CAGpBF,iBAAkBA,CAHEE,CAIpBC,UAAW9E,CAJS6E,CAKpBE,IAAK,EALeF,CAMpBG,IAAK,EANeH,CAOpBD,OAAQA,CAPYC,CASO,CAAd,CAAkD,IAAKI,CAAAA,kBAAL,CAAwBP,CAAxB,CAAlD,CAZ8C,CAcnER,CAAKhH,CAAAA,QAAL,CAAc8G,CAAd,CAA8BtH,CAA9B,CAfa,CAnBoD,CAdzE,CALyB,CA0D7BP,SAAS,EAAG,CACR,MAAO,KAAKnC,CAAAA,KAAZ,GAAsBlB,CAAYQ,CAAAA,cAAeW,CAAAA,MADzC,CAIZiL,SAAS,EAAG,CACR,MAAO,KAAKlL,CAAAA,KAAZ;AAAsBlB,CAAYQ,CAAAA,cAAeiC,CAAAA,MADzC,CAIZe,UAAU,EAAG,CACT,MAAO,KAAKtC,CAAAA,KAAZ,GAAsBlB,CAAYQ,CAAAA,cAAe6L,CAAAA,OADxC,CAIbjJ,UAAU,EAAG,CACT,MAAO,KAAKlC,CAAAA,KAAZ,GAAsBlB,CAAYQ,CAAAA,cAAe4I,CAAAA,OADxC,CAIbtF,eAAe,CAACF,CAAD,CAAM,CACjB,MAAQ,cAAaA,CAAb,EADS,CAIrBH,GAAG,CAACyD,CAAD,CAAOtC,CAAP,CAAeR,CAAf,CAAyB,CAClB0G,CAAAA,CAAY5D,CAAK6D,CAAAA,iBAAL,EACZuB,EAAAA,CAAU,CACZpF,KAAM4D,CADM,CAEZlG,OAAQA,CAFI,CAGZR,SAAUA,CAHE,CAKZ,KAAKnD,CAAAA,QAAL,CAAc6J,CAAd,CAAJ,CACI,IAAK7J,CAAAA,QAAL,CAAc6J,CAAd,CAAyBxE,CAAAA,IAAzB,CAA8BgG,CAA9B,CADJ,CAII,IAAKrL,CAAAA,QAAL,CAAc6J,CAAd,CAJJ,CAI+B,CAACwB,CAAD,CAE/B,OAAO,KAbiB,CAgB5BC,IAAI,CAACrF,CAAD,CAAOtC,CAAP,CAAe,CACf,MAAMkG,EAAY5D,CAAK6D,CAAAA,iBAAL,EACd,KAAK9J,CAAAA,QAAL,CAAc6J,CAAd,CAAJ,GACI,IAAK7J,CAAAA,QAAL,CAAc6J,CAAd,CADJ,CAC+B,IAAK7J,CAAAA,QAAL,CAAc6J,CAAd,CAAyBlG,CAAAA,MAAzB,CAAiCwG,CAAD,EAAU,CACjE,IAAIrK,CACJ,OAAO,GAAG,CAACA,CAAD,CAAMqK,CAAKlE,CAAAA,IAAX,IAAqB,IAArB,EAA6BnG,CAA7B,GAAoC,IAAK,EAAzC,CAA6C,IAAK,EAAlD,CAAsDA,CAAGgK,CAAAA,iBAAH,EAAzD;AAAqFD,CAArF,EACHrK,CAAgB+L,CAAAA,OAAhB,CAAwBpB,CAAKxG,CAAAA,MAA7B,CAAqCA,CAArC,CADG,CAF0D,CAA1C,CAD/B,CAOA,OAAO,KATQ,CAYZ4H,cAAO,CAACC,CAAD,CAAOC,CAAP,CAAa,CACvB,GAAIlN,MAAOmN,CAAAA,IAAP,CAAYF,CAAZ,CAAkB1H,CAAAA,MAAtB,GAAiCvF,MAAOmN,CAAAA,IAAP,CAAYD,CAAZ,CAAkB3H,CAAAA,MAAnD,CACI,MAAO,CAAA,CAEX,KAAK,MAAM6H,CAAX,GAAgBH,EAAhB,CACI,GAAIA,CAAA,CAAKG,CAAL,CAAJ,GAAgBF,CAAA,CAAKE,CAAL,CAAhB,CACI,MAAO,CAAA,CAGf,OAAO,CAAA,CATgB,CAgBpBvG,yBAAkB,CAACwG,CAAD,CAAcC,CAAd,CAA2B,CAGhD,OAFyBD,CAAAE,GAAgB,IAAhBA,EAAwBF,CAAxBE,GAAwC,IAAK,EAA7CA,CAAiDF,CAAjDE,CAA+DrH,IAAAA,EAExF,KADyBoH,CAAAE,GAAgB,IAAhBA,EAAwBF,CAAxBE,GAAwC,IAAK,EAA7CA,CAAiDF,CAAjDE,CAA+DtH,IAAAA,EACxF,CAHgD,CAMpDpD,qBAAqB,EAAG,CACpB,IAAKD,CAAAA,WAAYkB,CAAAA,eAAjB,EACI,KAAKzC,CAAAA,MAAOwD,CAAAA,WAAZ,EAAJ,EACI,IAAKiB,CAAAA,OAAL,EAHgB,CAWxBzC,QAAQ,CAACsB,CAAD,CAAW,CACf,IAAKX,CAAAA,GAAL,CAASzD,CAAYmC,CAAAA,cAAemH,CAAAA,KAApC,CAA2C,EAA3C,CAA+ClF,CAA/C,CADe,CAQnBlB,QAAQ,CAACkB,CAAD,CAAW,CACf,IAAKX,CAAAA,GAAL,CAASzD,CAAYmC,CAAAA,cAAeuE,CAAAA,KAApC,CAA2C,EAA3C,CAAgDvD,CAAD,EAAYiB,CAAA,CAASjB,CAAT,CAA3D,CADe,CAQnBuF,QAAQ,EAAG,CACP,MAAO,KAAK5H,CAAAA,MAAOwD,CAAAA,WAAZ,EAAP;AAAoC,IAAK8H,CAAAA,SAAL,EAD7B,CAIX7G,OAAO,CAACvD,CAAA,CAAU,IAAKA,CAAAA,OAAhB,CAAyB,CACxB,IAAKoB,CAAAA,UAAL,EAAJ,GAGA,IAAKtC,CAAAA,MAAOmM,CAAAA,eAAZ,CAA4B,IAAKtM,CAAAA,KAAjC,CAEA,CADA,IAAKO,CAAAA,KACL,CADalB,CAAYQ,CAAAA,cAAe6L,CAAAA,OACxC,CAAA,IAAKpK,CAAAA,QAASiL,CAAAA,MAAd,CAAqBlL,CAArB,CALA,CAD4B,CAShCmK,kBAAkB,CAACxI,CAAD,CAAU,CACxB,MAAMwJ,EAAU,CACZlB,IAAK,EADO,CAEZC,IAAK,EAFO,CAIhB,IAAIvI,CAAQuD,CAAAA,IAAZ,GAAqB,QAArB,EAAiCvD,CAAQuD,CAAAA,IAAzC,GAAkD,QAAlD,CACIiG,CAAQlB,CAAAA,GAAR,CAAc5L,CAAa+M,CAAAA,iBAAb,CAA+BzJ,CAAQ0J,CAAAA,OAAvC,CAAgD1J,CAAQ2J,CAAAA,MAAxD,CAElB,IAAI3J,CAAQuD,CAAAA,IAAZ,GAAqB,QAArB,EAAiCvD,CAAQuD,CAAAA,IAAzC,GAAkD,QAAlD,CACIiG,CAAQjB,CAAAA,GAAR,CAAc7L,CAAa+M,CAAAA,iBAAb,CAA+BzJ,CAAQ0J,CAAAA,OAAvC,CAAgD1J,CAAQ4J,CAAAA,UAAxD,CAElB,OAAOJ,EAXiB,CA/kBhC,CA6lBA5N,CAAQ2C,CAAAA,OAAR,CAAkBzB,CAnoBoC;\",\n\"sources\":[\"node_modules/@supabase/realtime-js/dist/main/RealtimeChannel.js\"],\n\"sourcesContent\":[\"shadow$provide[28] = function(require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.REALTIME_CHANNEL_STATES = exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_LISTEN_TYPES = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = void 0;\\nconst tslib_1 = require(\\\"tslib\\\");\\nconst constants_1 = require(\\\"./lib/constants\\\");\\nconst push_1 = tslib_1.__importDefault(require(\\\"./lib/push\\\"));\\nconst timer_1 = tslib_1.__importDefault(require(\\\"./lib/timer\\\"));\\nconst RealtimePresence_1 = tslib_1.__importDefault(require(\\\"./RealtimePresence\\\"));\\nconst Transformers = tslib_1.__importStar(require(\\\"./lib/transformers\\\"));\\nconst transformers_1 = require(\\\"./lib/transformers\\\");\\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\\\"ALL\\\"] = \\\"*\\\";\\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\\\"INSERT\\\"] = \\\"INSERT\\\";\\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\\\"UPDATE\\\"] = \\\"UPDATE\\\";\\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\\\"DELETE\\\"] = \\\"DELETE\\\";\\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\\nvar REALTIME_LISTEN_TYPES;\\n(function (REALTIME_LISTEN_TYPES) {\\n    REALTIME_LISTEN_TYPES[\\\"BROADCAST\\\"] = \\\"broadcast\\\";\\n    REALTIME_LISTEN_TYPES[\\\"PRESENCE\\\"] = \\\"presence\\\";\\n    REALTIME_LISTEN_TYPES[\\\"POSTGRES_CHANGES\\\"] = \\\"postgres_changes\\\";\\n    REALTIME_LISTEN_TYPES[\\\"SYSTEM\\\"] = \\\"system\\\";\\n})(REALTIME_LISTEN_TYPES || (exports.REALTIME_LISTEN_TYPES = REALTIME_LISTEN_TYPES = {}));\\nvar REALTIME_SUBSCRIBE_STATES;\\n(function (REALTIME_SUBSCRIBE_STATES) {\\n    REALTIME_SUBSCRIBE_STATES[\\\"SUBSCRIBED\\\"] = \\\"SUBSCRIBED\\\";\\n    REALTIME_SUBSCRIBE_STATES[\\\"TIMED_OUT\\\"] = \\\"TIMED_OUT\\\";\\n    REALTIME_SUBSCRIBE_STATES[\\\"CLOSED\\\"] = \\\"CLOSED\\\";\\n    REALTIME_SUBSCRIBE_STATES[\\\"CHANNEL_ERROR\\\"] = \\\"CHANNEL_ERROR\\\";\\n})(REALTIME_SUBSCRIBE_STATES || (exports.REALTIME_SUBSCRIBE_STATES = REALTIME_SUBSCRIBE_STATES = {}));\\nexports.REALTIME_CHANNEL_STATES = constants_1.CHANNEL_STATES;\\n/** A channel is the basic building block of Realtime\\n * and narrows the scope of data flow to subscribed clients.\\n * You can think of a channel as a chatroom where participants are able to see who's online\\n * and send and receive messages.\\n */\\nclass RealtimeChannel {\\n    /**\\n     * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.\\n     *\\n     * The topic determines which realtime stream you are subscribing to. Config options let you\\n     * enable acknowledgement for broadcasts, presence tracking, or private channels.\\n     *\\n     * @example\\n     * ```ts\\n     * import RealtimeClient from '@supabase/realtime-js'\\n     *\\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\\n     *   params: { apikey: 'public-anon-key' },\\n     * })\\n     * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)\\n     * ```\\n     */\\n    constructor(\\n    /** Topic name can be any string. */\\n    topic, params = { config: {} }, socket) {\\n        var _a, _b;\\n        this.topic = topic;\\n        this.params = params;\\n        this.socket = socket;\\n        this.bindings = {};\\n        this.state = constants_1.CHANNEL_STATES.closed;\\n        this.joinedOnce = false;\\n        this.pushBuffer = [];\\n        this.subTopic = topic.replace(/^realtime:/i, '');\\n        this.params.config = Object.assign({\\n            broadcast: { ack: false, self: false },\\n            presence: { key: '', enabled: false },\\n            private: false,\\n        }, params.config);\\n        this.timeout = this.socket.timeout;\\n        this.joinPush = new push_1.default(this, constants_1.CHANNEL_EVENTS.join, this.params, this.timeout);\\n        this.rejoinTimer = new timer_1.default(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\\n        this.joinPush.receive('ok', () => {\\n            this.state = constants_1.CHANNEL_STATES.joined;\\n            this.rejoinTimer.reset();\\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\\n            this.pushBuffer = [];\\n        });\\n        this._onClose(() => {\\n            this.rejoinTimer.reset();\\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\\n            this.state = constants_1.CHANNEL_STATES.closed;\\n            this.socket._remove(this);\\n        });\\n        this._onError((reason) => {\\n            if (this._isLeaving() || this._isClosed()) {\\n                return;\\n            }\\n            this.socket.log('channel', `error ${this.topic}`, reason);\\n            this.state = constants_1.CHANNEL_STATES.errored;\\n            this.rejoinTimer.scheduleTimeout();\\n        });\\n        this.joinPush.receive('timeout', () => {\\n            if (!this._isJoining()) {\\n                return;\\n            }\\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\\n            this.state = constants_1.CHANNEL_STATES.errored;\\n            this.rejoinTimer.scheduleTimeout();\\n        });\\n        this.joinPush.receive('error', (reason) => {\\n            if (this._isLeaving() || this._isClosed()) {\\n                return;\\n            }\\n            this.socket.log('channel', `error ${this.topic}`, reason);\\n            this.state = constants_1.CHANNEL_STATES.errored;\\n            this.rejoinTimer.scheduleTimeout();\\n        });\\n        this._on(constants_1.CHANNEL_EVENTS.reply, {}, (payload, ref) => {\\n            this._trigger(this._replyEventName(ref), payload);\\n        });\\n        this.presence = new RealtimePresence_1.default(this);\\n        this.broadcastEndpointURL = (0, transformers_1.httpEndpointURL)(this.socket.endPoint);\\n        this.private = this.params.config.private || false;\\n        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\\n            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;\\n        }\\n    }\\n    /** Subscribe registers your client with the server */\\n    subscribe(callback, timeout = this.timeout) {\\n        var _a, _b, _c;\\n        if (!this.socket.isConnected()) {\\n            this.socket.connect();\\n        }\\n        if (this.state == constants_1.CHANNEL_STATES.closed) {\\n            const { config: { broadcast, presence, private: isPrivate }, } = this.params;\\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [];\\n            const presence_enabled = (!!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] &&\\n                this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0) ||\\n                ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\\n            const accessTokenPayload = {};\\n            const config = {\\n                broadcast,\\n                presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),\\n                postgres_changes,\\n                private: isPrivate,\\n            };\\n            if (this.socket.accessTokenValue) {\\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\\n            }\\n            this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\\n            this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\\n            this.joinedOnce = true;\\n            this._rejoin(timeout);\\n            this.joinPush\\n                .receive('ok', async ({ postgres_changes }) => {\\n                var _a;\\n                // Only refresh auth if using callback-based tokens\\n                if (!this.socket._isManualToken()) {\\n                    this.socket.setAuth();\\n                }\\n                if (postgres_changes === undefined) {\\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\\n                    return;\\n                }\\n                else {\\n                    const clientPostgresBindings = this.bindings.postgres_changes;\\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\\n                    const newPostgresBindings = [];\\n                    for (let i = 0; i < bindingsLen; i++) {\\n                        const clientPostgresBinding = clientPostgresBindings[i];\\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\\n                        if (serverPostgresFilter &&\\n                            serverPostgresFilter.event === event &&\\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) &&\\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) &&\\n                            RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {\\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\\n                        }\\n                        else {\\n                            this.unsubscribe();\\n                            this.state = constants_1.CHANNEL_STATES.errored;\\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\\n                            return;\\n                        }\\n                    }\\n                    this.bindings.postgres_changes = newPostgresBindings;\\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\\n                    return;\\n                }\\n            })\\n                .receive('error', (error) => {\\n                this.state = constants_1.CHANNEL_STATES.errored;\\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\\n                return;\\n            })\\n                .receive('timeout', () => {\\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\\n                return;\\n            });\\n        }\\n        return this;\\n    }\\n    /**\\n     * Returns the current presence state for this channel.\\n     *\\n     * The shape is a map keyed by presence key (for example a user id) where each entry contains the\\n     * tracked metadata for that user.\\n     */\\n    presenceState() {\\n        return this.presence.state;\\n    }\\n    /**\\n     * Sends the supplied payload to the presence tracker so other subscribers can see that this\\n     * client is online. Use `untrack` to stop broadcasting presence for the same key.\\n     */\\n    async track(payload, opts = {}) {\\n        return await this.send({\\n            type: 'presence',\\n            event: 'track',\\n            payload,\\n        }, opts.timeout || this.timeout);\\n    }\\n    /**\\n     * Removes the current presence state for this client.\\n     */\\n    async untrack(opts = {}) {\\n        return await this.send({\\n            type: 'presence',\\n            event: 'untrack',\\n        }, opts);\\n    }\\n    on(type, filter, callback) {\\n        if (this.state === constants_1.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\\n            this.socket.log('channel', `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\\n            this.unsubscribe().then(async () => await this.subscribe());\\n        }\\n        return this._on(type, filter, callback);\\n    }\\n    /**\\n     * Sends a broadcast message explicitly via REST API.\\n     *\\n     * This method always uses the REST API endpoint regardless of WebSocket connection state.\\n     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\\n     *\\n     * @param event The name of the broadcast event\\n     * @param payload Payload to be sent (required)\\n     * @param opts Options including timeout\\n     * @returns Promise resolving to object with success status, and error details if failed\\n     */\\n    async httpSend(event, payload, opts = {}) {\\n        var _a;\\n        if (payload === undefined || payload === null) {\\n            return Promise.reject('Payload is required for httpSend()');\\n        }\\n        const headers = {\\n            apikey: this.socket.apiKey ? this.socket.apiKey : '',\\n            'Content-Type': 'application/json',\\n        };\\n        if (this.socket.accessTokenValue) {\\n            headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`;\\n        }\\n        const options = {\\n            method: 'POST',\\n            headers,\\n            body: JSON.stringify({\\n                messages: [\\n                    {\\n                        topic: this.subTopic,\\n                        event,\\n                        payload: payload,\\n                        private: this.private,\\n                    },\\n                ],\\n            }),\\n        };\\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\\n        if (response.status === 202) {\\n            return { success: true };\\n        }\\n        let errorMessage = response.statusText;\\n        try {\\n            const errorBody = await response.json();\\n            errorMessage = errorBody.error || errorBody.message || errorMessage;\\n        }\\n        catch (_b) { }\\n        return Promise.reject(new Error(errorMessage));\\n    }\\n    /**\\n     * Sends a message into the channel.\\n     *\\n     * @param args Arguments to send to channel\\n     * @param args.type The type of event to send\\n     * @param args.event The name of the event being sent\\n     * @param args.payload Payload to be sent\\n     * @param opts Options to be used during the send process\\n     */\\n    async send(args, opts = {}) {\\n        var _a, _b;\\n        if (!this._canPush() && args.type === 'broadcast') {\\n            console.warn('Realtime send() is automatically falling back to REST API. ' +\\n                'This behavior will be deprecated in the future. ' +\\n                'Please use httpSend() explicitly for REST delivery.');\\n            const { event, payload: endpoint_payload } = args;\\n            const headers = {\\n                apikey: this.socket.apiKey ? this.socket.apiKey : '',\\n                'Content-Type': 'application/json',\\n            };\\n            if (this.socket.accessTokenValue) {\\n                headers['Authorization'] = `Bearer ${this.socket.accessTokenValue}`;\\n            }\\n            const options = {\\n                method: 'POST',\\n                headers,\\n                body: JSON.stringify({\\n                    messages: [\\n                        {\\n                            topic: this.subTopic,\\n                            event,\\n                            payload: endpoint_payload,\\n                            private: this.private,\\n                        },\\n                    ],\\n                }),\\n            };\\n            try {\\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\\n                return response.ok ? 'ok' : 'error';\\n            }\\n            catch (error) {\\n                if (error.name === 'AbortError') {\\n                    return 'timed out';\\n                }\\n                else {\\n                    return 'error';\\n                }\\n            }\\n        }\\n        else {\\n            return new Promise((resolve) => {\\n                var _a, _b, _c;\\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\\n                    resolve('ok');\\n                }\\n                push.receive('ok', () => resolve('ok'));\\n                push.receive('error', () => resolve('error'));\\n                push.receive('timeout', () => resolve('timed out'));\\n            });\\n        }\\n    }\\n    /**\\n     * Updates the payload that will be sent the next time the channel joins (reconnects).\\n     * Useful for rotating access tokens or updating config without re-creating the channel.\\n     */\\n    updateJoinPayload(payload) {\\n        this.joinPush.updatePayload(payload);\\n    }\\n    /**\\n     * Leaves the channel.\\n     *\\n     * Unsubscribes from server events, and instructs channel to terminate on server.\\n     * Triggers onClose() hooks.\\n     *\\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\\n     * channel.unsubscribe().receive(\\\"ok\\\", () => alert(\\\"left!\\\") )\\n     */\\n    unsubscribe(timeout = this.timeout) {\\n        this.state = constants_1.CHANNEL_STATES.leaving;\\n        const onClose = () => {\\n            this.socket.log('channel', `leave ${this.topic}`);\\n            this._trigger(constants_1.CHANNEL_EVENTS.close, 'leave', this._joinRef());\\n        };\\n        this.joinPush.destroy();\\n        let leavePush = null;\\n        return new Promise((resolve) => {\\n            leavePush = new push_1.default(this, constants_1.CHANNEL_EVENTS.leave, {}, timeout);\\n            leavePush\\n                .receive('ok', () => {\\n                onClose();\\n                resolve('ok');\\n            })\\n                .receive('timeout', () => {\\n                onClose();\\n                resolve('timed out');\\n            })\\n                .receive('error', () => {\\n                resolve('error');\\n            });\\n            leavePush.send();\\n            if (!this._canPush()) {\\n                leavePush.trigger('ok', {});\\n            }\\n        }).finally(() => {\\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\\n        });\\n    }\\n    /**\\n     * Teardown the channel.\\n     *\\n     * Destroys and stops related timers.\\n     */\\n    teardown() {\\n        this.pushBuffer.forEach((push) => push.destroy());\\n        this.pushBuffer = [];\\n        this.rejoinTimer.reset();\\n        this.joinPush.destroy();\\n        this.state = constants_1.CHANNEL_STATES.closed;\\n        this.bindings = {};\\n    }\\n    /** @internal */\\n    async _fetchWithTimeout(url, options, timeout) {\\n        const controller = new AbortController();\\n        const id = setTimeout(() => controller.abort(), timeout);\\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\\n        clearTimeout(id);\\n        return response;\\n    }\\n    /** @internal */\\n    _push(event, payload, timeout = this.timeout) {\\n        if (!this.joinedOnce) {\\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\\n        }\\n        let pushEvent = new push_1.default(this, event, payload, timeout);\\n        if (this._canPush()) {\\n            pushEvent.send();\\n        }\\n        else {\\n            this._addToPushBuffer(pushEvent);\\n        }\\n        return pushEvent;\\n    }\\n    /** @internal */\\n    _addToPushBuffer(pushEvent) {\\n        pushEvent.startTimeout();\\n        this.pushBuffer.push(pushEvent);\\n        // Enforce buffer size limit\\n        if (this.pushBuffer.length > constants_1.MAX_PUSH_BUFFER_SIZE) {\\n            const removedPush = this.pushBuffer.shift();\\n            if (removedPush) {\\n                removedPush.destroy();\\n                this.socket.log('channel', `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\\n            }\\n        }\\n    }\\n    /**\\n     * Overridable message hook\\n     *\\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\\n     * Must return the payload, modified or unmodified.\\n     *\\n     * @internal\\n     */\\n    _onMessage(_event, payload, _ref) {\\n        return payload;\\n    }\\n    /** @internal */\\n    _isMember(topic) {\\n        return this.topic === topic;\\n    }\\n    /** @internal */\\n    _joinRef() {\\n        return this.joinPush.ref;\\n    }\\n    /** @internal */\\n    _trigger(type, payload, ref) {\\n        var _a, _b;\\n        const typeLower = type.toLocaleLowerCase();\\n        const { close, error, leave, join } = constants_1.CHANNEL_EVENTS;\\n        const events = [close, error, leave, join];\\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\\n            return;\\n        }\\n        let handledPayload = this._onMessage(typeLower, payload, ref);\\n        if (payload && !handledPayload) {\\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\\n        }\\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\\n                var _a, _b, _c;\\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\\n            }).map((bind) => bind.callback(handledPayload, ref));\\n        }\\n        else {\\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\\n                var _a, _b, _c, _d, _e, _f;\\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\\n                    if ('id' in bind) {\\n                        const bindId = bind.id;\\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\\n                        return (bindId &&\\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\\n                            (bindEvent === '*' ||\\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\\n                    }\\n                    else {\\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\\n                        return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\\n                    }\\n                }\\n                else {\\n                    return bind.type.toLocaleLowerCase() === typeLower;\\n                }\\n            }).map((bind) => {\\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\\n                    const postgresChanges = handledPayload.data;\\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\\n                    const enrichedPayload = {\\n                        schema: schema,\\n                        table: table,\\n                        commit_timestamp: commit_timestamp,\\n                        eventType: type,\\n                        new: {},\\n                        old: {},\\n                        errors: errors,\\n                    };\\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\\n                }\\n                bind.callback(handledPayload, ref);\\n            });\\n        }\\n    }\\n    /** @internal */\\n    _isClosed() {\\n        return this.state === constants_1.CHANNEL_STATES.closed;\\n    }\\n    /** @internal */\\n    _isJoined() {\\n        return this.state === constants_1.CHANNEL_STATES.joined;\\n    }\\n    /** @internal */\\n    _isJoining() {\\n        return this.state === constants_1.CHANNEL_STATES.joining;\\n    }\\n    /** @internal */\\n    _isLeaving() {\\n        return this.state === constants_1.CHANNEL_STATES.leaving;\\n    }\\n    /** @internal */\\n    _replyEventName(ref) {\\n        return `chan_reply_${ref}`;\\n    }\\n    /** @internal */\\n    _on(type, filter, callback) {\\n        const typeLower = type.toLocaleLowerCase();\\n        const binding = {\\n            type: typeLower,\\n            filter: filter,\\n            callback: callback,\\n        };\\n        if (this.bindings[typeLower]) {\\n            this.bindings[typeLower].push(binding);\\n        }\\n        else {\\n            this.bindings[typeLower] = [binding];\\n        }\\n        return this;\\n    }\\n    /** @internal */\\n    _off(type, filter) {\\n        const typeLower = type.toLocaleLowerCase();\\n        if (this.bindings[typeLower]) {\\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\\n                var _a;\\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\\n                    RealtimeChannel.isEqual(bind.filter, filter));\\n            });\\n        }\\n        return this;\\n    }\\n    /** @internal */\\n    static isEqual(obj1, obj2) {\\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\\n            return false;\\n        }\\n        for (const k in obj1) {\\n            if (obj1[k] !== obj2[k]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    /**\\n     * Compares two optional filter values for equality.\\n     * Treats undefined, null, and empty string as equivalent empty values.\\n     * @internal\\n     */\\n    static isFilterValueEqual(serverValue, clientValue) {\\n        const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;\\n        const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;\\n        return normalizedServer === normalizedClient;\\n    }\\n    /** @internal */\\n    _rejoinUntilConnected() {\\n        this.rejoinTimer.scheduleTimeout();\\n        if (this.socket.isConnected()) {\\n            this._rejoin();\\n        }\\n    }\\n    /**\\n     * Registers a callback that will be executed when the channel closes.\\n     *\\n     * @internal\\n     */\\n    _onClose(callback) {\\n        this._on(constants_1.CHANNEL_EVENTS.close, {}, callback);\\n    }\\n    /**\\n     * Registers a callback that will be executed when the channel encounteres an error.\\n     *\\n     * @internal\\n     */\\n    _onError(callback) {\\n        this._on(constants_1.CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\\n    }\\n    /**\\n     * Returns `true` if the socket is connected and the channel has been joined.\\n     *\\n     * @internal\\n     */\\n    _canPush() {\\n        return this.socket.isConnected() && this._isJoined();\\n    }\\n    /** @internal */\\n    _rejoin(timeout = this.timeout) {\\n        if (this._isLeaving()) {\\n            return;\\n        }\\n        this.socket._leaveOpenTopic(this.topic);\\n        this.state = constants_1.CHANNEL_STATES.joining;\\n        this.joinPush.resend(timeout);\\n    }\\n    /** @internal */\\n    _getPayloadRecords(payload) {\\n        const records = {\\n            new: {},\\n            old: {},\\n        };\\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\\n        }\\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\\n        }\\n        return records;\\n    }\\n}\\nexports.default = RealtimeChannel;\\n//# sourceMappingURL=RealtimeChannel.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"REALTIME_CHANNEL_STATES\",\"REALTIME_SUBSCRIBE_STATES\",\"REALTIME_LISTEN_TYPES\",\"REALTIME_POSTGRES_CHANGES_LISTEN_EVENT\",\"tslib_1\",\"constants_1\",\"push_1\",\"__importDefault\",\"timer_1\",\"RealtimePresence_1\",\"Transformers\",\"__importStar\",\"transformers_1\",\"CHANNEL_STATES\",\"RealtimeChannel\",\"constructor\",\"topic\",\"params\",\"config\",\"socket\",\"_a\",\"_b\",\"bindings\",\"state\",\"closed\",\"joinedOnce\",\"pushBuffer\",\"subTopic\",\"replace\",\"assign\",\"broadcast\",\"ack\",\"self\",\"presence\",\"key\",\"enabled\",\"private\",\"timeout\",\"joinPush\",\"default\",\"CHANNEL_EVENTS\",\"join\",\"rejoinTimer\",\"_rejoinUntilConnected\",\"reconnectAfterMs\",\"receive\",\"joined\",\"reset\",\"forEach\",\"pushEvent\",\"send\",\"_onClose\",\"log\",\"_joinRef\",\"_remove\",\"_onError\",\"reason\",\"_isLeaving\",\"_isClosed\",\"errored\",\"scheduleTimeout\",\"_isJoining\",\"_on\",\"reply\",\"payload\",\"ref\",\"_trigger\",\"_replyEventName\",\"broadcastEndpointURL\",\"httpEndpointURL\",\"endPoint\",\"replay\",\"subscribe\",\"callback\",\"_c\",\"isConnected\",\"connect\",\"isPrivate\",\"postgres_changes\",\"map\",\"r\",\"filter\",\"presence_enabled\",\"PRESENCE\",\"length\",\"accessTokenPayload\",\"accessTokenValue\",\"access_token\",\"e\",\"CHANNEL_ERROR\",\"CLOSED\",\"updateJoinPayload\",\"_rejoin\",\"_isManualToken\",\"setAuth\",\"undefined\",\"SUBSCRIBED\",\"clientPostgresBindings\",\"bindingsLen\",\"newPostgresBindings\",\"i\",\"clientPostgresBinding\",\"event\",\"schema\",\"table\",\"serverPostgresFilter\",\"isFilterValueEqual\",\"push\",\"id\",\"unsubscribe\",\"Error\",\"error\",\"JSON\",\"stringify\",\"values\",\"TIMED_OUT\",\"presenceState\",\"track\",\"opts\",\"type\",\"untrack\",\"on\",\"then\",\"httpSend\",\"Promise\",\"reject\",\"headers\",\"apikey\",\"apiKey\",\"options\",\"method\",\"body\",\"messages\",\"response\",\"_fetchWithTimeout\",\"status\",\"success\",\"errorMessage\",\"statusText\",\"errorBody\",\"json\",\"message\",\"args\",\"_canPush\",\"resolve\",\"_push\",\"console\",\"warn\",\"endpoint_payload\",\"cancel\",\"ok\",\"name\",\"updatePayload\",\"leaving\",\"onClose\",\"close\",\"destroy\",\"leavePush\",\"finally\",\"leave\",\"trigger\",\"teardown\",\"url\",\"controller\",\"AbortController\",\"setTimeout\",\"abort\",\"fetch\",\"signal\",\"clearTimeout\",\"_addToPushBuffer\",\"startTimeout\",\"MAX_PUSH_BUFFER_SIZE\",\"removedPush\",\"shift\",\"_onMessage\",\"_event\",\"_ref\",\"_isMember\",\"typeLower\",\"toLocaleLowerCase\",\"events\",\"indexOf\",\"handledPayload\",\"includes\",\"bind\",\"_e\",\"_f\",\"bindId\",\"bindEvent\",\"ids\",\"data\",\"_d\",\"postgresChanges\",\"commit_timestamp\",\"errors\",\"enrichedPayload\",\"eventType\",\"new\",\"old\",\"_getPayloadRecords\",\"_isJoined\",\"joining\",\"binding\",\"_off\",\"isEqual\",\"obj1\",\"obj2\",\"keys\",\"k\",\"serverValue\",\"clientValue\",\"normalizedServer\",\"normalizedClient\",\"_leaveOpenTopic\",\"resend\",\"records\",\"convertChangeData\",\"columns\",\"record\",\"old_record\"]\n}\n"]