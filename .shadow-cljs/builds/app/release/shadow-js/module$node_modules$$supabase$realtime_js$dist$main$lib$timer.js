["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/realtime-js/dist/main/lib/timer.js"],"~:js","shadow$provide[24]=function(S,ka,a){Object.defineProperty(a,\"__esModule\",{value:!0});class I{constructor(q,D){this.timerCalc=D;this.timer=void 0;this.tries=0;this.callback=q;this.timerCalc=D}reset(){this.tries=0;clearTimeout(this.timer);this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer);this.timer=setTimeout(()=>{this.tries+=1;this.callback()},this.timerCalc(this.tries+1))}}a.default=I}","~:source","shadow$provide[24] = function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nclass Timer {\n    constructor(callback, timerCalc) {\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(() => {\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n}\nexports.default = Timer;\n//# sourceMappingURL=timer.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["callback","__esModule","timerCalc","value","tries","default","timer"]],"~:compiled-at",1771991938819,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$realtime_js$dist$main$lib$timer.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAe,EAAf,CAAA,CAAqB,QAAQ,CAACC,CAAD,CAASC,EAAT,CAAgBC,CAAhB,CAAyB,CAEtDC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAaA,MAAMC,EAAN,CACIC,WAAW,CAACC,CAAD,CAAWC,CAAX,CAAsB,CAE7B,IAAKA,CAAAA,SAAL,CAAiBA,CACjB,KAAKC,CAAAA,KAAL,CAAaC,IAAAA,EACb,KAAKC,CAAAA,KAAL,CAAa,CACb,KAAKJ,CAAAA,QAAL,CAAgBA,CAChB,KAAKC,CAAAA,SAAL,CAAiBA,CANY,CAQjCI,KAAK,EAAG,CACJ,IAAKD,CAAAA,KAAL,CAAa,CACbE,aAAA,CAAa,IAAKJ,CAAAA,KAAlB,CACA,KAAKA,CAAAA,KAAL,CAAaC,IAAAA,EAHT,CAMRI,eAAe,EAAG,CACdD,YAAA,CAAa,IAAKJ,CAAAA,KAAlB,CACA,KAAKA,CAAAA,KAAL,CAAaM,UAAA,CAAW,EAAA,EAAM,CAC1B,IAAKJ,CAAAA,KAAL,EAA0B,CAC1B,KAAKJ,CAAAA,QAAL,EAF0B,CAAjB,CAGV,IAAKC,CAAAA,SAAL,CAAe,IAAKG,CAAAA,KAApB,CAA4B,CAA5B,CAHU,CAFC,CAftB,CAuBAV,CAAQe,CAAAA,OAAR,CAAkBX,CAtCoC;\",\n\"sources\":[\"node_modules/@supabase/realtime-js/dist/main/lib/timer.js\"],\n\"sourcesContent\":[\"shadow$provide[24] = function(require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\n/**\\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\\n *\\n * @example\\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\\n *      return [1000, 5000, 10000][tries - 1] || 10000\\n *    })\\n *    reconnectTimer.scheduleTimeout() // fires after 1000\\n *    reconnectTimer.scheduleTimeout() // fires after 5000\\n *    reconnectTimer.reset()\\n *    reconnectTimer.scheduleTimeout() // fires after 1000\\n */\\nclass Timer {\\n    constructor(callback, timerCalc) {\\n        this.callback = callback;\\n        this.timerCalc = timerCalc;\\n        this.timer = undefined;\\n        this.tries = 0;\\n        this.callback = callback;\\n        this.timerCalc = timerCalc;\\n    }\\n    reset() {\\n        this.tries = 0;\\n        clearTimeout(this.timer);\\n        this.timer = undefined;\\n    }\\n    // Cancels any previous scheduleTimeout and schedules callback\\n    scheduleTimeout() {\\n        clearTimeout(this.timer);\\n        this.timer = setTimeout(() => {\\n            this.tries = this.tries + 1;\\n            this.callback();\\n        }, this.timerCalc(this.tries + 1));\\n    }\\n}\\nexports.default = Timer;\\n//# sourceMappingURL=timer.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"Timer\",\"constructor\",\"callback\",\"timerCalc\",\"timer\",\"undefined\",\"tries\",\"reset\",\"clearTimeout\",\"scheduleTimeout\",\"setTimeout\",\"default\"]\n}\n"]