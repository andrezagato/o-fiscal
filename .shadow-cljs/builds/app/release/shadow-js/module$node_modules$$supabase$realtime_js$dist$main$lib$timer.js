["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/realtime-js/dist/main/lib/timer.js"],"~:js","shadow$provide[24]=function(S,ka,a){Object.defineProperty(a,\"__esModule\",{value:!0});class I{constructor(q,D){this.timerCalc=D;this.timer=void 0;this.tries=0;this.callback=q;this.timerCalc=D}reset(){this.tries=0;clearTimeout(this.timer);this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer);this.timer=setTimeout(()=>{this.tries+=1;this.callback()},this.timerCalc(this.tries+1))}}a.default=I}","~:source","shadow$provide[24] = function(require,module,exports) {\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\r\n *\r\n * @example\r\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\r\n *      return [1000, 5000, 10000][tries - 1] || 10000\r\n *    })\r\n *    reconnectTimer.scheduleTimeout() // fires after 1000\r\n *    reconnectTimer.scheduleTimeout() // fires after 5000\r\n *    reconnectTimer.reset()\r\n *    reconnectTimer.scheduleTimeout() // fires after 1000\r\n */\r\nclass Timer {\r\n    constructor(callback, timerCalc) {\r\n        this.callback = callback;\r\n        this.timerCalc = timerCalc;\r\n        this.timer = undefined;\r\n        this.tries = 0;\r\n        this.callback = callback;\r\n        this.timerCalc = timerCalc;\r\n    }\r\n    reset() {\r\n        this.tries = 0;\r\n        clearTimeout(this.timer);\r\n        this.timer = undefined;\r\n    }\r\n    // Cancels any previous scheduleTimeout and schedules callback\r\n    scheduleTimeout() {\r\n        clearTimeout(this.timer);\r\n        this.timer = setTimeout(() => {\r\n            this.tries = this.tries + 1;\r\n            this.callback();\r\n        }, this.timerCalc(this.tries + 1));\r\n    }\r\n}\r\nexports.default = Timer;\r\n//# sourceMappingURL=timer.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["callback","__esModule","timerCalc","value","tries","default","timer"]],"~:compiled-at",1771869280844,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$realtime_js$dist$main$lib$timer.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAe,EAAf,CAAA,CAAqB,QAAQ,CAACC,CAAD,CAASC,EAAT,CAAgBC,CAAhB,CAAyB,CAEtDC,MAAOC,CAAAA,cAAP,CAAsBF,CAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAaA,MAAMC,EAAN,CACIC,WAAW,CAACC,CAAD,CAAWC,CAAX,CAAsB,CAE7B,IAAKA,CAAAA,SAAL,CAAiBA,CACjB,KAAKC,CAAAA,KAAL,CAAaC,IAAAA,EACb,KAAKC,CAAAA,KAAL,CAAa,CACb,KAAKJ,CAAAA,QAAL,CAAgBA,CAChB,KAAKC,CAAAA,SAAL,CAAiBA,CANY,CAQjCI,KAAK,EAAG,CACJ,IAAKD,CAAAA,KAAL,CAAa,CACbE,aAAA,CAAa,IAAKJ,CAAAA,KAAlB,CACA,KAAKA,CAAAA,KAAL,CAAaC,IAAAA,EAHT,CAMRI,eAAe,EAAG,CACdD,YAAA,CAAa,IAAKJ,CAAAA,KAAlB,CACA,KAAKA,CAAAA,KAAL,CAAaM,UAAA,CAAW,EAAA,EAAM,CAC1B,IAAKJ,CAAAA,KAAL,EAA0B,CAC1B,KAAKJ,CAAAA,QAAL,EAF0B,CAAjB,CAGV,IAAKC,CAAAA,SAAL,CAAe,IAAKG,CAAAA,KAApB,CAA4B,CAA5B,CAHU,CAFC,CAftB,CAuBAV,CAAQe,CAAAA,OAAR,CAAkBX,CAtCoC;\",\n\"sources\":[\"node_modules/@supabase/realtime-js/dist/main/lib/timer.js\"],\n\"sourcesContent\":[\"shadow$provide[24] = function(require,module,exports) {\\n\\\"use strict\\\";\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\n/**\\r\\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\\r\\n *\\r\\n * @example\\r\\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\\r\\n *      return [1000, 5000, 10000][tries - 1] || 10000\\r\\n *    })\\r\\n *    reconnectTimer.scheduleTimeout() // fires after 1000\\r\\n *    reconnectTimer.scheduleTimeout() // fires after 5000\\r\\n *    reconnectTimer.reset()\\r\\n *    reconnectTimer.scheduleTimeout() // fires after 1000\\r\\n */\\r\\nclass Timer {\\r\\n    constructor(callback, timerCalc) {\\r\\n        this.callback = callback;\\r\\n        this.timerCalc = timerCalc;\\r\\n        this.timer = undefined;\\r\\n        this.tries = 0;\\r\\n        this.callback = callback;\\r\\n        this.timerCalc = timerCalc;\\r\\n    }\\r\\n    reset() {\\r\\n        this.tries = 0;\\r\\n        clearTimeout(this.timer);\\r\\n        this.timer = undefined;\\r\\n    }\\r\\n    // Cancels any previous scheduleTimeout and schedules callback\\r\\n    scheduleTimeout() {\\r\\n        clearTimeout(this.timer);\\r\\n        this.timer = setTimeout(() => {\\r\\n            this.tries = this.tries + 1;\\r\\n            this.callback();\\r\\n        }, this.timerCalc(this.tries + 1));\\r\\n    }\\r\\n}\\r\\nexports.default = Timer;\\r\\n//# sourceMappingURL=timer.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"Timer\",\"constructor\",\"callback\",\"timerCalc\",\"timer\",\"undefined\",\"tries\",\"reset\",\"clearTimeout\",\"scheduleTimeout\",\"setTimeout\",\"default\"]\n}\n"]