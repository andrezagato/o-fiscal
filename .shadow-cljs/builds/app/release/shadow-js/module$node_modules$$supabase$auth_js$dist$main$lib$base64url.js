["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/auth-js/dist/main/lib/base64url.js"],"~:js","shadow$provide[39]=function(S,ka,a){function I(K,p,k){if(K!==null)for(p.queue=p.queue<<8|K,p.queuedBits+=8;p.queuedBits>=6;)k(E[p.queue>>p.queuedBits-6&63]),p.queuedBits-=6;else if(p.queuedBits>0)for(p.queue<<=6-p.queuedBits,p.queuedBits=6;p.queuedBits>=6;)k(E[p.queue>>p.queuedBits-6&63]),p.queuedBits-=6}function q(K,p,k){const y=d[K];if(y>-1)for(p.queue=p.queue<<6|y,p.queuedBits+=6;p.queuedBits>=8;)k(p.queue>>p.queuedBits-8&255),p.queuedBits-=8;else if(y!==-2)throw Error(`Invalid Base64-URL character \"${String.fromCharCode(K)}\"`);\n}function D(K,p){if(K<=127)p(K);else if(K<=2047)p(192|K>>6),p(128|K&63);else if(K<=65535)p(224|K>>12),p(128|K>>6&63),p(128|K&63);else if(K<=1114111)p(240|K>>18),p(128|K>>12&63),p(128|K>>6&63),p(128|K&63);else throw Error(`Unrecognized Unicode codepoint: ${K.toString(16)}`);}function C(K,p){for(let y=0;y<K.length;y+=1){var k=K.charCodeAt(y);k>55295&&k<=56319&&(k=(k-55296)*1024&65535,k=(K.charCodeAt(y+1)-56320&65535|k)+65536,y+=1);D(k,p)}}function G(K,p,k){if(p.utf8seq===0)if(K<=127)k(K);else{for(k=\n1;k<6;k+=1)if((K>>7-k&1)===0){p.utf8seq=k;break}if(p.utf8seq===2)p.codepoint=K&31;else if(p.utf8seq===3)p.codepoint=K&15;else if(p.utf8seq===4)p.codepoint=K&7;else throw Error(\"Invalid UTF-8 sequence\");--p.utf8seq}else if(p.utf8seq>0){if(K<=127)throw Error(\"Invalid UTF-8 sequence\");p.codepoint=p.codepoint<<6|K&63;--p.utf8seq;p.utf8seq===0&&k(p.codepoint)}}Object.defineProperty(a,\"__esModule\",{value:!0});a.byteToBase64URL=I;a.byteFromBase64URL=q;a.stringToBase64URL=function(K){const p=[],k=v=>{p.push(v)},\ny={queue:0,queuedBits:0};C(K,v=>{I(v,y,k)});I(null,y,k);return p.join(\"\")};a.stringFromBase64URL=function(K){const p=[],k=J=>{p.push(String.fromCodePoint(J))},y={utf8seq:0,codepoint:0},v={queue:0,queuedBits:0},z=J=>{G(J,y,k)};for(let J=0;J<K.length;J+=1)q(K.charCodeAt(J),v,z);return p.join(\"\")};a.codepointToUTF8=D;a.stringToUTF8=C;a.stringFromUTF8=G;a.base64UrlToUint8Array=function(K){const p=[],k={queue:0,queuedBits:0},y=v=>{p.push(v)};for(let v=0;v<K.length;v+=1)q(K.charCodeAt(v),k,y);return new Uint8Array(p)};\na.stringToUint8Array=function(K){const p=[];C(K,k=>p.push(k));return new Uint8Array(p)};a.bytesToBase64URL=function(K){const p=[],k={queue:0,queuedBits:0},y=v=>{p.push(v)};K.forEach(v=>I(v,k,y));I(null,k,y);return p.join(\"\")};const E=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\"),M=[\" \",\"\\t\",\"\\n\",\"\\r\",\"\\x3d\"],d=(()=>{const K=Array(128);for(var p=0;p<K.length;p+=1)K[p]=-1;for(p=0;p<M.length;p+=1)K[M[p].charCodeAt(0)]=-2;for(p=0;p<E.length;p+=1)K[E[p].charCodeAt(0)]=p;\nreturn K})()}","~:source","shadow$provide[39] = function(require,module,exports) {\n\"use strict\";\r\n/**\r\n * Avoid modifying this file. It's part of\r\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\r\n * that repo!\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.byteToBase64URL = byteToBase64URL;\r\nexports.byteFromBase64URL = byteFromBase64URL;\r\nexports.stringToBase64URL = stringToBase64URL;\r\nexports.stringFromBase64URL = stringFromBase64URL;\r\nexports.codepointToUTF8 = codepointToUTF8;\r\nexports.stringToUTF8 = stringToUTF8;\r\nexports.stringFromUTF8 = stringFromUTF8;\r\nexports.base64UrlToUint8Array = base64UrlToUint8Array;\r\nexports.stringToUint8Array = stringToUint8Array;\r\nexports.bytesToBase64URL = bytesToBase64URL;\r\n/**\r\n * An array of characters that encode 6 bits into a Base64-URL alphabet\r\n * character.\r\n */\r\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\r\n/**\r\n * An array of characters that can appear in a Base64-URL encoded string but\r\n * should be ignored.\r\n */\r\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('');\r\n/**\r\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\r\n * used to skip the character, or if -1 used to error out.\r\n */\r\nconst FROM_BASE64URL = (() => {\r\n    const charMap = new Array(128);\r\n    for (let i = 0; i < charMap.length; i += 1) {\r\n        charMap[i] = -1;\r\n    }\r\n    for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\r\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\r\n    }\r\n    for (let i = 0; i < TO_BASE64URL.length; i += 1) {\r\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\r\n    }\r\n    return charMap;\r\n})();\r\n/**\r\n * Converts a byte to a Base64-URL string.\r\n *\r\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\r\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\r\n * @param emit A function called with the next Base64 character when ready.\r\n */\r\nfunction byteToBase64URL(byte, state, emit) {\r\n    if (byte !== null) {\r\n        state.queue = (state.queue << 8) | byte;\r\n        state.queuedBits += 8;\r\n        while (state.queuedBits >= 6) {\r\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\r\n            emit(TO_BASE64URL[pos]);\r\n            state.queuedBits -= 6;\r\n        }\r\n    }\r\n    else if (state.queuedBits > 0) {\r\n        state.queue = state.queue << (6 - state.queuedBits);\r\n        state.queuedBits = 6;\r\n        while (state.queuedBits >= 6) {\r\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\r\n            emit(TO_BASE64URL[pos]);\r\n            state.queuedBits -= 6;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\r\n *\r\n * @param charCode The char code of the JavaScript string.\r\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\r\n * @param emit A function called with the next byte.\r\n */\r\nfunction byteFromBase64URL(charCode, state, emit) {\r\n    const bits = FROM_BASE64URL[charCode];\r\n    if (bits > -1) {\r\n        // valid Base64-URL character\r\n        state.queue = (state.queue << 6) | bits;\r\n        state.queuedBits += 6;\r\n        while (state.queuedBits >= 8) {\r\n            emit((state.queue >> (state.queuedBits - 8)) & 0xff);\r\n            state.queuedBits -= 8;\r\n        }\r\n    }\r\n    else if (bits === -2) {\r\n        // ignore spaces, tabs, newlines, =\r\n        return;\r\n    }\r\n    else {\r\n        throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\r\n    }\r\n}\r\n/**\r\n * Converts a JavaScript string (which may include any valid character) into a\r\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\r\n * then encoded as Base64-URL.\r\n *\r\n * @param str The string to convert.\r\n */\r\nfunction stringToBase64URL(str) {\r\n    const base64 = [];\r\n    const emitter = (char) => {\r\n        base64.push(char);\r\n    };\r\n    const state = { queue: 0, queuedBits: 0 };\r\n    stringToUTF8(str, (byte) => {\r\n        byteToBase64URL(byte, state, emitter);\r\n    });\r\n    byteToBase64URL(null, state, emitter);\r\n    return base64.join('');\r\n}\r\n/**\r\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\r\n * that the underlying string has been encoded as UTF-8.\r\n *\r\n * @param str The Base64-URL encoded string.\r\n */\r\nfunction stringFromBase64URL(str) {\r\n    const conv = [];\r\n    const utf8Emit = (codepoint) => {\r\n        conv.push(String.fromCodePoint(codepoint));\r\n    };\r\n    const utf8State = {\r\n        utf8seq: 0,\r\n        codepoint: 0,\r\n    };\r\n    const b64State = { queue: 0, queuedBits: 0 };\r\n    const byteEmit = (byte) => {\r\n        stringFromUTF8(byte, utf8State, utf8Emit);\r\n    };\r\n    for (let i = 0; i < str.length; i += 1) {\r\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\r\n    }\r\n    return conv.join('');\r\n}\r\n/**\r\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\r\n *\r\n * @param codepoint The Unicode codepoint.\r\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\r\n */\r\nfunction codepointToUTF8(codepoint, emit) {\r\n    if (codepoint <= 0x7f) {\r\n        emit(codepoint);\r\n        return;\r\n    }\r\n    else if (codepoint <= 0x7ff) {\r\n        emit(0xc0 | (codepoint >> 6));\r\n        emit(0x80 | (codepoint & 0x3f));\r\n        return;\r\n    }\r\n    else if (codepoint <= 0xffff) {\r\n        emit(0xe0 | (codepoint >> 12));\r\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\r\n        emit(0x80 | (codepoint & 0x3f));\r\n        return;\r\n    }\r\n    else if (codepoint <= 0x10ffff) {\r\n        emit(0xf0 | (codepoint >> 18));\r\n        emit(0x80 | ((codepoint >> 12) & 0x3f));\r\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\r\n        emit(0x80 | (codepoint & 0x3f));\r\n        return;\r\n    }\r\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\r\n}\r\n/**\r\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\r\n *\r\n * @param str  The string to convert to UTF-8.\r\n * @param emit Function which will be called for each UTF-8 byte of the string.\r\n */\r\nfunction stringToUTF8(str, emit) {\r\n    for (let i = 0; i < str.length; i += 1) {\r\n        let codepoint = str.charCodeAt(i);\r\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\r\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\r\n            // range where the next UTF-16 codepoint needs to be combined with the\r\n            // current one to get the Unicode codepoint\r\n            const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff;\r\n            const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff;\r\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\r\n            i += 1;\r\n        }\r\n        codepointToUTF8(codepoint, emit);\r\n    }\r\n}\r\n/**\r\n * Converts a UTF-8 byte to a Unicode codepoint.\r\n *\r\n * @param byte  The UTF-8 byte next in the sequence.\r\n * @param state The shared state between consecutive UTF-8 bytes in the\r\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\r\n * @param emit  Function which will be called for each codepoint.\r\n */\r\nfunction stringFromUTF8(byte, state, emit) {\r\n    if (state.utf8seq === 0) {\r\n        if (byte <= 0x7f) {\r\n            emit(byte);\r\n            return;\r\n        }\r\n        // count the number of 1 leading bits until you reach 0\r\n        for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\r\n            if (((byte >> (7 - leadingBit)) & 1) === 0) {\r\n                state.utf8seq = leadingBit;\r\n                break;\r\n            }\r\n        }\r\n        if (state.utf8seq === 2) {\r\n            state.codepoint = byte & 31;\r\n        }\r\n        else if (state.utf8seq === 3) {\r\n            state.codepoint = byte & 15;\r\n        }\r\n        else if (state.utf8seq === 4) {\r\n            state.codepoint = byte & 7;\r\n        }\r\n        else {\r\n            throw new Error('Invalid UTF-8 sequence');\r\n        }\r\n        state.utf8seq -= 1;\r\n    }\r\n    else if (state.utf8seq > 0) {\r\n        if (byte <= 0x7f) {\r\n            throw new Error('Invalid UTF-8 sequence');\r\n        }\r\n        state.codepoint = (state.codepoint << 6) | (byte & 63);\r\n        state.utf8seq -= 1;\r\n        if (state.utf8seq === 0) {\r\n            emit(state.codepoint);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Helper functions to convert different types of strings to Uint8Array\r\n */\r\nfunction base64UrlToUint8Array(str) {\r\n    const result = [];\r\n    const state = { queue: 0, queuedBits: 0 };\r\n    const onByte = (byte) => {\r\n        result.push(byte);\r\n    };\r\n    for (let i = 0; i < str.length; i += 1) {\r\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\r\n    }\r\n    return new Uint8Array(result);\r\n}\r\nfunction stringToUint8Array(str) {\r\n    const result = [];\r\n    stringToUTF8(str, (byte) => result.push(byte));\r\n    return new Uint8Array(result);\r\n}\r\nfunction bytesToBase64URL(bytes) {\r\n    const result = [];\r\n    const state = { queue: 0, queuedBits: 0 };\r\n    const onChar = (char) => {\r\n        result.push(char);\r\n    };\r\n    bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));\r\n    // always call with `null` after processing all bytes\r\n    byteToBase64URL(null, state, onChar);\r\n    return result.join('');\r\n}\r\n//# sourceMappingURL=base64url.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["byteFromBase64URL","stringToUint8Array","byteToBase64URL","queue","__esModule","stringFromUTF8","value","stringFromBase64URL","stringToBase64URL","codepoint","codepointToUTF8","bytesToBase64URL","utf8seq","queuedBits","base64UrlToUint8Array","stringToUTF8"]],"~:compiled-at",1771869280899,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$auth_js$dist$main$lib$base64url.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/auth-js/dist/main/lib/base64url.js\"],\n\"sourcesContent\":[\"shadow$provide[39] = function(require,module,exports) {\\n\\\"use strict\\\";\\r\\n/**\\r\\n * Avoid modifying this file. It's part of\\r\\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\\r\\n * that repo!\\r\\n */\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.byteToBase64URL = byteToBase64URL;\\r\\nexports.byteFromBase64URL = byteFromBase64URL;\\r\\nexports.stringToBase64URL = stringToBase64URL;\\r\\nexports.stringFromBase64URL = stringFromBase64URL;\\r\\nexports.codepointToUTF8 = codepointToUTF8;\\r\\nexports.stringToUTF8 = stringToUTF8;\\r\\nexports.stringFromUTF8 = stringFromUTF8;\\r\\nexports.base64UrlToUint8Array = base64UrlToUint8Array;\\r\\nexports.stringToUint8Array = stringToUint8Array;\\r\\nexports.bytesToBase64URL = bytesToBase64URL;\\r\\n/**\\r\\n * An array of characters that encode 6 bits into a Base64-URL alphabet\\r\\n * character.\\r\\n */\\r\\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\\r\\n/**\\r\\n * An array of characters that can appear in a Base64-URL encoded string but\\r\\n * should be ignored.\\r\\n */\\r\\nconst IGNORE_BASE64URL = ' \\\\t\\\\n\\\\r='.split('');\\r\\n/**\\r\\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\\r\\n * used to skip the character, or if -1 used to error out.\\r\\n */\\r\\nconst FROM_BASE64URL = (() => {\\r\\n    const charMap = new Array(128);\\r\\n    for (let i = 0; i < charMap.length; i += 1) {\\r\\n        charMap[i] = -1;\\r\\n    }\\r\\n    for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\\r\\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\\r\\n    }\\r\\n    for (let i = 0; i < TO_BASE64URL.length; i += 1) {\\r\\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\\r\\n    }\\r\\n    return charMap;\\r\\n})();\\r\\n/**\\r\\n * Converts a byte to a Base64-URL string.\\r\\n *\\r\\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\\r\\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\\r\\n * @param emit A function called with the next Base64 character when ready.\\r\\n */\\r\\nfunction byteToBase64URL(byte, state, emit) {\\r\\n    if (byte !== null) {\\r\\n        state.queue = (state.queue << 8) | byte;\\r\\n        state.queuedBits += 8;\\r\\n        while (state.queuedBits >= 6) {\\r\\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\\r\\n            emit(TO_BASE64URL[pos]);\\r\\n            state.queuedBits -= 6;\\r\\n        }\\r\\n    }\\r\\n    else if (state.queuedBits > 0) {\\r\\n        state.queue = state.queue << (6 - state.queuedBits);\\r\\n        state.queuedBits = 6;\\r\\n        while (state.queuedBits >= 6) {\\r\\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\\r\\n            emit(TO_BASE64URL[pos]);\\r\\n            state.queuedBits -= 6;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\\r\\n *\\r\\n * @param charCode The char code of the JavaScript string.\\r\\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\\r\\n * @param emit A function called with the next byte.\\r\\n */\\r\\nfunction byteFromBase64URL(charCode, state, emit) {\\r\\n    const bits = FROM_BASE64URL[charCode];\\r\\n    if (bits > -1) {\\r\\n        // valid Base64-URL character\\r\\n        state.queue = (state.queue << 6) | bits;\\r\\n        state.queuedBits += 6;\\r\\n        while (state.queuedBits >= 8) {\\r\\n            emit((state.queue >> (state.queuedBits - 8)) & 0xff);\\r\\n            state.queuedBits -= 8;\\r\\n        }\\r\\n    }\\r\\n    else if (bits === -2) {\\r\\n        // ignore spaces, tabs, newlines, =\\r\\n        return;\\r\\n    }\\r\\n    else {\\r\\n        throw new Error(`Invalid Base64-URL character \\\"${String.fromCharCode(charCode)}\\\"`);\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Converts a JavaScript string (which may include any valid character) into a\\r\\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\\r\\n * then encoded as Base64-URL.\\r\\n *\\r\\n * @param str The string to convert.\\r\\n */\\r\\nfunction stringToBase64URL(str) {\\r\\n    const base64 = [];\\r\\n    const emitter = (char) => {\\r\\n        base64.push(char);\\r\\n    };\\r\\n    const state = { queue: 0, queuedBits: 0 };\\r\\n    stringToUTF8(str, (byte) => {\\r\\n        byteToBase64URL(byte, state, emitter);\\r\\n    });\\r\\n    byteToBase64URL(null, state, emitter);\\r\\n    return base64.join('');\\r\\n}\\r\\n/**\\r\\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\\r\\n * that the underlying string has been encoded as UTF-8.\\r\\n *\\r\\n * @param str The Base64-URL encoded string.\\r\\n */\\r\\nfunction stringFromBase64URL(str) {\\r\\n    const conv = [];\\r\\n    const utf8Emit = (codepoint) => {\\r\\n        conv.push(String.fromCodePoint(codepoint));\\r\\n    };\\r\\n    const utf8State = {\\r\\n        utf8seq: 0,\\r\\n        codepoint: 0,\\r\\n    };\\r\\n    const b64State = { queue: 0, queuedBits: 0 };\\r\\n    const byteEmit = (byte) => {\\r\\n        stringFromUTF8(byte, utf8State, utf8Emit);\\r\\n    };\\r\\n    for (let i = 0; i < str.length; i += 1) {\\r\\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\\r\\n    }\\r\\n    return conv.join('');\\r\\n}\\r\\n/**\\r\\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\\r\\n *\\r\\n * @param codepoint The Unicode codepoint.\\r\\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\\r\\n */\\r\\nfunction codepointToUTF8(codepoint, emit) {\\r\\n    if (codepoint <= 0x7f) {\\r\\n        emit(codepoint);\\r\\n        return;\\r\\n    }\\r\\n    else if (codepoint <= 0x7ff) {\\r\\n        emit(0xc0 | (codepoint >> 6));\\r\\n        emit(0x80 | (codepoint & 0x3f));\\r\\n        return;\\r\\n    }\\r\\n    else if (codepoint <= 0xffff) {\\r\\n        emit(0xe0 | (codepoint >> 12));\\r\\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\\r\\n        emit(0x80 | (codepoint & 0x3f));\\r\\n        return;\\r\\n    }\\r\\n    else if (codepoint <= 0x10ffff) {\\r\\n        emit(0xf0 | (codepoint >> 18));\\r\\n        emit(0x80 | ((codepoint >> 12) & 0x3f));\\r\\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\\r\\n        emit(0x80 | (codepoint & 0x3f));\\r\\n        return;\\r\\n    }\\r\\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\\r\\n}\\r\\n/**\\r\\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\\r\\n *\\r\\n * @param str  The string to convert to UTF-8.\\r\\n * @param emit Function which will be called for each UTF-8 byte of the string.\\r\\n */\\r\\nfunction stringToUTF8(str, emit) {\\r\\n    for (let i = 0; i < str.length; i += 1) {\\r\\n        let codepoint = str.charCodeAt(i);\\r\\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\\r\\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\\r\\n            // range where the next UTF-16 codepoint needs to be combined with the\\r\\n            // current one to get the Unicode codepoint\\r\\n            const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff;\\r\\n            const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff;\\r\\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\\r\\n            i += 1;\\r\\n        }\\r\\n        codepointToUTF8(codepoint, emit);\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Converts a UTF-8 byte to a Unicode codepoint.\\r\\n *\\r\\n * @param byte  The UTF-8 byte next in the sequence.\\r\\n * @param state The shared state between consecutive UTF-8 bytes in the\\r\\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\\r\\n * @param emit  Function which will be called for each codepoint.\\r\\n */\\r\\nfunction stringFromUTF8(byte, state, emit) {\\r\\n    if (state.utf8seq === 0) {\\r\\n        if (byte <= 0x7f) {\\r\\n            emit(byte);\\r\\n            return;\\r\\n        }\\r\\n        // count the number of 1 leading bits until you reach 0\\r\\n        for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\\r\\n            if (((byte >> (7 - leadingBit)) & 1) === 0) {\\r\\n                state.utf8seq = leadingBit;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (state.utf8seq === 2) {\\r\\n            state.codepoint = byte & 31;\\r\\n        }\\r\\n        else if (state.utf8seq === 3) {\\r\\n            state.codepoint = byte & 15;\\r\\n        }\\r\\n        else if (state.utf8seq === 4) {\\r\\n            state.codepoint = byte & 7;\\r\\n        }\\r\\n        else {\\r\\n            throw new Error('Invalid UTF-8 sequence');\\r\\n        }\\r\\n        state.utf8seq -= 1;\\r\\n    }\\r\\n    else if (state.utf8seq > 0) {\\r\\n        if (byte <= 0x7f) {\\r\\n            throw new Error('Invalid UTF-8 sequence');\\r\\n        }\\r\\n        state.codepoint = (state.codepoint << 6) | (byte & 63);\\r\\n        state.utf8seq -= 1;\\r\\n        if (state.utf8seq === 0) {\\r\\n            emit(state.codepoint);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Helper functions to convert different types of strings to Uint8Array\\r\\n */\\r\\nfunction base64UrlToUint8Array(str) {\\r\\n    const result = [];\\r\\n    const state = { queue: 0, queuedBits: 0 };\\r\\n    const onByte = (byte) => {\\r\\n        result.push(byte);\\r\\n    };\\r\\n    for (let i = 0; i < str.length; i += 1) {\\r\\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\\r\\n    }\\r\\n    return new Uint8Array(result);\\r\\n}\\r\\nfunction stringToUint8Array(str) {\\r\\n    const result = [];\\r\\n    stringToUTF8(str, (byte) => result.push(byte));\\r\\n    return new Uint8Array(result);\\r\\n}\\r\\nfunction bytesToBase64URL(bytes) {\\r\\n    const result = [];\\r\\n    const state = { queue: 0, queuedBits: 0 };\\r\\n    const onChar = (char) => {\\r\\n        result.push(char);\\r\\n    };\\r\\n    bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));\\r\\n    // always call with `null` after processing all bytes\\r\\n    byteToBase64URL(null, state, onChar);\\r\\n    return result.join('');\\r\\n}\\r\\n//# sourceMappingURL=base64url.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"byteToBase64URL\",\"byte\",\"state\",\"emit\",\"queue\",\"queuedBits\",\"TO_BASE64URL\",\"byteFromBase64URL\",\"charCode\",\"bits\",\"FROM_BASE64URL\",\"Error\",\"String\",\"fromCharCode\",\"codepointToUTF8\",\"codepoint\",\"toString\",\"stringToUTF8\",\"str\",\"i\",\"length\",\"charCodeAt\",\"highSurrogate\",\"stringFromUTF8\",\"utf8seq\",\"leadingBit\",\"Object\",\"defineProperty\",\"value\",\"stringToBase64URL\",\"base64\",\"emitter\",\"char\",\"push\",\"join\",\"stringFromBase64URL\",\"conv\",\"utf8Emit\",\"fromCodePoint\",\"utf8State\",\"b64State\",\"byteEmit\",\"base64UrlToUint8Array\",\"result\",\"onByte\",\"Uint8Array\",\"stringToUint8Array\",\"bytesToBase64URL\",\"bytes\",\"onChar\",\"forEach\",\"IGNORE_BASE64URL\",\"charMap\",\"Array\"]\n}\n"]