["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/buffer/index.js"],"~:js","shadow$provide[34]=function(S,ka,a){function I(h){if(h>2147483647)throw new RangeError('The value \"'+h+'\" is invalid for option \"size\"');h=new Uint8Array(h);Object.setPrototypeOf(h,q.prototype);return h}function q(h,r,g){if(typeof h===\"number\"){if(typeof r===\"string\")throw new TypeError('The \"string\" argument must be of type string. Received type number');return G(h)}return D(h,r,g)}function D(h,r,g){if(typeof h===\"string\"){var n=r;if(typeof n!==\"string\"||n===\"\")n=\"utf8\";if(!q.isEncoding(n))throw new TypeError(\"Unknown encoding: \"+\nn);r=p(h,n)|0;g=I(r);h=g.write(h,n);h!==r&&(g=g.slice(0,h));return g}if(ArrayBuffer.isView(h))return O(h,Uint8Array)?(h=new Uint8Array(h),h=M(h.buffer,h.byteOffset,h.byteLength)):h=E(h),h;if(h==null)throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof h);if(O(h,ArrayBuffer)||h&&O(h.buffer,ArrayBuffer)||typeof SharedArrayBuffer!==\"undefined\"&&(O(h,SharedArrayBuffer)||h&&O(h.buffer,SharedArrayBuffer)))return M(h,\nr,g);if(typeof h===\"number\")throw new TypeError('The \"value\" argument must not be of type number. Received type number');n=h.valueOf&&h.valueOf();if(n!=null&&n!==h)return q.from(n,r,g);if(n=d(h))return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof h[Symbol.toPrimitive]===\"function\")return q.from(h[Symbol.toPrimitive](\"string\"),r,g);throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof h);}function C(h){if(typeof h!==\n\"number\")throw new TypeError('\"size\" argument must be of type number');if(h<0)throw new RangeError('The value \"'+h+'\" is invalid for option \"size\"');}function G(h){C(h);return I(h<0?0:K(h)|0)}function E(h){const r=h.length<0?0:K(h.length)|0,g=I(r);for(let n=0;n<r;n+=1)g[n]=h[n]&255;return g}function M(h,r,g){if(r<0||h.byteLength<r)throw new RangeError('\"offset\" is outside of buffer bounds');if(h.byteLength<r+(g||0))throw new RangeError('\"length\" is outside of buffer bounds');h=r===void 0&&g===void 0?\nnew Uint8Array(h):g===void 0?new Uint8Array(h,r):new Uint8Array(h,r,g);Object.setPrototypeOf(h,q.prototype);return h}function d(h){if(q.isBuffer(h)){var r=K(h.length)|0;const g=I(r);if(g.length===0)return g;h.copy(g,0,0,r);return g}if(h.length!==void 0)return(r=typeof h.length!==\"number\")||(r=h.length,r=r!==r),r?I(0):E(h);if(h.type===\"Buffer\"&&Array.isArray(h.data))return E(h.data)}function K(h){if(h>=2147483647)throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+(2147483647).toString(16)+\n\" bytes\");return h|0}function p(h,r){if(q.isBuffer(h))return h.length;if(ArrayBuffer.isView(h)||O(h,ArrayBuffer))return h.byteLength;if(typeof h!==\"string\")throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof h);const g=h.length,n=arguments.length>2&&arguments[2]===!0;if(!n&&g===0)return 0;let F=!1;for(;;)switch(r){case \"ascii\":case \"latin1\":case \"binary\":return g;case \"utf8\":case \"utf-8\":return ja(h).length;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":return g*\n2;case \"hex\":return g>>>1;case \"base64\":return la(h).length;default:if(F)return n?-1:ja(h).length;r=(\"\"+r).toLowerCase();F=!0}}function k(h,r,g){let n=!1;if(r===void 0||r<0)r=0;if(r>this.length)return\"\";if(g===void 0||g>this.length)g=this.length;if(g<=0)return\"\";g>>>=0;r>>>=0;if(g<=r)return\"\";for(h||=\"utf8\";;)switch(h){case \"hex\":h=r;r=this.length;if(!h||h<0)h=0;if(!g||g<0||g>r)g=r;for(r=\"\";h<g;++h)r+=Ea[this[h]];return r;case \"utf8\":case \"utf-8\":return J(this,r,g);case \"ascii\":h=r;r=\"\";for(g=Math.min(this.length,\ng);h<g;++h)r+=String.fromCharCode(this[h]&127);return r;case \"latin1\":case \"binary\":h=r;r=\"\";for(g=Math.min(this.length,g);h<g;++h)r+=String.fromCharCode(this[h]);return r;case \"base64\":return h=r,g=h===0&&g===this.length?ia.fromByteArray(this):ia.fromByteArray(this.slice(h,g)),g;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":g=this.slice(r,g);h=\"\";for(r=0;r<g.length-1;r+=2)h+=String.fromCharCode(g[r]+g[r+1]*256);return h;default:if(n)throw new TypeError(\"Unknown encoding: \"+h);h=(h+\"\").toLowerCase();\nn=!0}}function y(h,r,g){const n=h[r];h[r]=h[g];h[g]=n}function v(h,r,g,n,F){if(h.length===0)return-1;typeof g===\"string\"?(n=g,g=0):g>2147483647?g=2147483647:g<-2147483648&&(g=-2147483648);g=+g;g!==g&&(g=F?0:h.length-1);g<0&&(g=h.length+g);if(g>=h.length){if(F)return-1;g=h.length-1}else if(g<0)if(F)g=0;else return-1;typeof r===\"string\"&&(r=q.from(r,n));if(q.isBuffer(r))return r.length===0?-1:z(h,r,g,n,F);if(typeof r===\"number\")return r&=255,typeof Uint8Array.prototype.indexOf===\"function\"?F?Uint8Array.prototype.indexOf.call(h,\nr,g):Uint8Array.prototype.lastIndexOf.call(h,r,g):z(h,[r],g,n,F);throw new TypeError(\"val must be string, number or Buffer\");}function z(h,r,g,n,F){function Q(Fa,Ga){return ea===1?Fa[Ga]:Fa.readUInt16BE(Ga*ea)}let ea=1;var oa=h.length;let Da=r.length;if(n!==void 0&&(n=String(n).toLowerCase(),n===\"ucs2\"||n===\"ucs-2\"||n===\"utf16le\"||n===\"utf-16le\")){if(h.length<2||r.length<2)return-1;ea=2;oa/=2;Da/=2;g/=2}if(F)for(n=-1;g<oa;g++)if(Q(h,g)===Q(r,n===-1?0:g-n)){if(n===-1&&(n=g),g-n+1===Da)return n*ea}else n!==\n-1&&(g-=g-n),n=-1;else for(g+Da>oa&&(g=oa-Da);g>=0;g--){oa=!0;for(n=0;n<Da;n++)if(Q(h,g+n)!==Q(r,n)){oa=!1;break}if(oa)return g}return-1}function J(h,r,g){g=Math.min(h.length,g);for(var n=[];r<g;){var F=h[r];let Q=null,ea=F>239?4:F>223?3:F>191?2:1;if(r+ea<=g){let oa,Da,Fa;switch(ea){case 1:F<128&&(Q=F);break;case 2:oa=h[r+1];(oa&192)===128&&(F=(F&31)<<6|oa&63,F>127&&(Q=F));break;case 3:oa=h[r+1];Da=h[r+2];(oa&192)===128&&(Da&192)===128&&(F=(F&15)<<12|(oa&63)<<6|Da&63,F>2047&&(F<55296||F>57343)&&(Q=\nF));break;case 4:oa=h[r+1],Da=h[r+2],Fa=h[r+3],(oa&192)===128&&(Da&192)===128&&(Fa&192)===128&&(F=(F&15)<<18|(oa&63)<<12|(Da&63)<<6|Fa&63,F>65535&&F<1114112&&(Q=F))}}Q===null?(Q=65533,ea=1):Q>65535&&(Q-=65536,n.push(Q>>>10&1023|55296),Q=56320|Q&1023);n.push(Q);r+=ea}r=n.length;if(r<=4096)n=String.fromCharCode.apply(String,n);else{h=\"\";for(g=0;g<r;)h+=String.fromCharCode.apply(String,n.slice(g,g+=4096));n=h}return n}function l(h,r,g){if(h%1!==0||h<0)throw new RangeError(\"offset is not uint\");if(h+\nr>g)throw new RangeError(\"Trying to access beyond buffer length\");}function t(h,r,g,n,F,Q){if(!q.isBuffer(h))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>F||r<Q)throw new RangeError('\"value\" argument is out of bounds');if(g+n>h.length)throw new RangeError(\"Index out of range\");}function x(h,r,g,n,F){ha(r,n,F,h,g,7);n=Number(r&BigInt(4294967295));h[g++]=n;n>>=8;h[g++]=n;n>>=8;h[g++]=n;h[g++]=n>>8;r=Number(r>>BigInt(32)&BigInt(4294967295));h[g++]=r;r>>=8;h[g++]=r;r>>=8;h[g++]=\nr;h[g++]=r>>8;return g}function w(h,r,g,n,F){ha(r,n,F,h,g,7);n=Number(r&BigInt(4294967295));h[g+7]=n;n>>=8;h[g+6]=n;n>>=8;h[g+5]=n;h[g+4]=n>>8;r=Number(r>>BigInt(32)&BigInt(4294967295));h[g+3]=r;r>>=8;h[g+2]=r;r>>=8;h[g+1]=r;h[g]=r>>8;return g+8}function A(h,r,g,n,F,Q){if(g+n>h.length)throw new RangeError(\"Index out of range\");if(g<0)throw new RangeError(\"Index out of range\");}function L(h,r,g,n,F){r=+r;g>>>=0;F||A(h,r,g,4,3.4028234663852886E38,-3.4028234663852886E38);ma.write(h,r,g,n,23,4);return g+\n4}function P(h,r,g,n,F){r=+r;g>>>=0;F||A(h,r,g,8,1.7976931348623157E308,-1.7976931348623157E308);ma.write(h,r,g,n,52,8);return g+8}function T(h,r,g){sa[h]=class extends g{constructor(){super();Object.defineProperty(this,\"message\",{value:r.apply(this,arguments),writable:!0,configurable:!0});this.name=`${this.name} [${h}]`;this.stack;delete this.name}get code(){return h}set code(n){Object.defineProperty(this,\"code\",{configurable:!0,enumerable:!0,value:n,writable:!0})}toString(){return`${this.name} [${h}]: ${this.message}`}}}\nfunction Y(h){let r=\"\",g=h.length;const n=h[0]===\"-\"?1:0;for(;g>=n+4;g-=3)r=`_${h.slice(g-3,g)}${r}`;return`${h.slice(0,g)}${r}`}function ha(h,r,g,n,F,Q){if(h>g||h<r)throw n=typeof r===\"bigint\"?\"n\":\"\",new sa.ERR_OUT_OF_RANGE(\"value\",Q>3?r===0||r===BigInt(0)?`>= 0${n} and < 2${n} ** ${(Q+1)*8}${n}`:`>= -(2${n} ** ${(Q+1)*8-1}${n}) and < 2 ** `+`${(Q+1)*8-1}${n}`:`>= ${r}${n} and <= ${g}${n}`,h);da(F,\"offset\");n[F]!==void 0&&n[F+Q]!==void 0||fa(F,n.length-(Q+1))}function da(h,r){if(typeof h!==\"number\")throw new sa.ERR_INVALID_ARG_TYPE(r,\n\"number\",h);}function fa(h,r,g){if(Math.floor(h)!==h)throw da(h,g),new sa.ERR_OUT_OF_RANGE(g||\"offset\",\"an integer\",h);if(r<0)throw new sa.ERR_BUFFER_OUT_OF_BOUNDS;throw new sa.ERR_OUT_OF_RANGE(g||\"offset\",`>= ${g?1:0} and <= ${r}`,h);}function ja(h,r){r=r||Infinity;let g;const n=h.length;let F=null;const Q=[];for(let ea=0;ea<n;++ea){g=h.charCodeAt(ea);if(g>55295&&g<57344){if(!F){if(g>56319){(r-=3)>-1&&Q.push(239,191,189);continue}else if(ea+1===n){(r-=3)>-1&&Q.push(239,191,189);continue}F=g;continue}if(g<\n56320){(r-=3)>-1&&Q.push(239,191,189);F=g;continue}g=(F-55296<<10|g-56320)+65536}else F&&(r-=3)>-1&&Q.push(239,191,189);F=null;if(g<128){if(--r<0)break;Q.push(g)}else if(g<2048){if((r-=2)<0)break;Q.push(g>>6|192,g&63|128)}else if(g<65536){if((r-=3)<0)break;Q.push(g>>12|224,g>>6&63|128,g&63|128)}else if(g<1114112){if((r-=4)<0)break;Q.push(g>>18|240,g>>12&63|128,g>>6&63|128,g&63|128)}else throw Error(\"Invalid code point\");}return Q}function la(h){var r=ia,g=r.toByteArray;h=h.split(\"\\x3d\")[0];h=h.trim().replace(ya,\n\"\");if(h.length<2)h=\"\";else for(;h.length%4!==0;)h+=\"\\x3d\";return g.call(r,h)}function ta(h,r,g,n){let F;for(F=0;F<n&&!(F+g>=r.length||F>=h.length);++F)r[F+g]=h[F];return F}function O(h,r){return h instanceof r||h!=null&&h.constructor!=null&&h.constructor.name!=null&&h.constructor.name===r.name}function W(h){return typeof BigInt===\"undefined\"?Z:h}function Z(){throw Error(\"BigInt not supported\");}const ia=S(32),ma=S(33);S=typeof Symbol===\"function\"&&typeof Symbol[\"for\"]===\"function\"?Symbol[\"for\"](\"nodejs.util.inspect.custom\"):\nnull;a.Buffer=q;a.SlowBuffer=function(h){+h!=h&&(h=0);return q.alloc(+h)};a.INSPECT_MAX_BYTES=50;a.kMaxLength=2147483647;q.TYPED_ARRAY_SUPPORT=function(){try{const h=new Uint8Array(1),r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(h,r);return h.foo()===42}catch(h){return!1}}();q.TYPED_ARRAY_SUPPORT||typeof console===\"undefined\"||typeof console.error!==\"function\"||console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\nObject.defineProperty(q.prototype,\"parent\",{enumerable:!0,get:function(){if(q.isBuffer(this))return this.buffer}});Object.defineProperty(q.prototype,\"offset\",{enumerable:!0,get:function(){if(q.isBuffer(this))return this.byteOffset}});q.poolSize=8192;q.from=function(h,r,g){return D(h,r,g)};Object.setPrototypeOf(q.prototype,Uint8Array.prototype);Object.setPrototypeOf(q,Uint8Array);q.alloc=function(h,r,g){C(h);h=h<=0?I(h):r!==void 0?typeof g===\"string\"?I(h).fill(r,g):I(h).fill(r):I(h);return h};q.allocUnsafe=\nfunction(h){return G(h)};q.allocUnsafeSlow=function(h){return G(h)};q.isBuffer=function(h){return h!=null&&h._isBuffer===!0&&h!==q.prototype};q.compare=function(h,r){O(h,Uint8Array)&&(h=q.from(h,h.offset,h.byteLength));O(r,Uint8Array)&&(r=q.from(r,r.offset,r.byteLength));if(!q.isBuffer(h)||!q.isBuffer(r))throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');if(h===r)return 0;let g=h.length,n=r.length;for(let F=0,Q=Math.min(g,n);F<Q;++F)if(h[F]!==r[F]){g=h[F];\nn=r[F];break}return g<n?-1:n<g?1:0};q.isEncoding=function(h){switch(String(h).toLowerCase()){case \"hex\":case \"utf8\":case \"utf-8\":case \"ascii\":case \"latin1\":case \"binary\":case \"base64\":case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":return!0;default:return!1}};q.concat=function(h,r){if(!Array.isArray(h))throw new TypeError('\"list\" argument must be an Array of Buffers');if(h.length===0)return q.alloc(0);let g;if(r===void 0)for(g=r=0;g<h.length;++g)r+=h[g].length;r=q.allocUnsafe(r);let n=0;for(g=\n0;g<h.length;++g){let F=h[g];if(O(F,Uint8Array))n+F.length>r.length?(q.isBuffer(F)||(F=q.from(F)),F.copy(r,n)):Uint8Array.prototype.set.call(r,F,n);else if(q.isBuffer(F))F.copy(r,n);else throw new TypeError('\"list\" argument must be an Array of Buffers');n+=F.length}return r};q.byteLength=p;q.prototype._isBuffer=!0;q.prototype.swap16=function(){const h=this.length;if(h%2!==0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(let r=0;r<h;r+=2)y(this,r,r+1);return this};q.prototype.swap32=\nfunction(){const h=this.length;if(h%4!==0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(let r=0;r<h;r+=4)y(this,r,r+3),y(this,r+1,r+2);return this};q.prototype.swap64=function(){const h=this.length;if(h%8!==0)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(let r=0;r<h;r+=8)y(this,r,r+7),y(this,r+1,r+6),y(this,r+2,r+5),y(this,r+3,r+4);return this};q.prototype.toString=function(){const h=this.length;return h===0?\"\":arguments.length===0?J(this,0,h):k.apply(this,\narguments)};q.prototype.toLocaleString=q.prototype.toString;q.prototype.equals=function(h){if(!q.isBuffer(h))throw new TypeError(\"Argument must be a Buffer\");return this===h?!0:q.compare(this,h)===0};q.prototype.inspect=function(){let h;const r=a.INSPECT_MAX_BYTES;h=this.toString(\"hex\",0,r).replace(/(.{2})/g,\"$1 \").trim();this.length>r&&(h+=\" ... \");return\"\\x3cBuffer \"+h+\"\\x3e\"};S&&(q.prototype[S]=q.prototype.inspect);q.prototype.compare=function(h,r,g,n,F){O(h,Uint8Array)&&(h=q.from(h,h.offset,h.byteLength));\nif(!q.isBuffer(h))throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type '+typeof h);r===void 0&&(r=0);g===void 0&&(g=h?h.length:0);n===void 0&&(n=0);F===void 0&&(F=this.length);if(r<0||g>h.length||n<0||F>this.length)throw new RangeError(\"out of range index\");if(n>=F&&r>=g)return 0;if(n>=F)return-1;if(r>=g)return 1;r>>>=0;g>>>=0;n>>>=0;F>>>=0;if(this===h)return 0;let Q=F-n,ea=g-r;const oa=Math.min(Q,ea);n=this.slice(n,F);h=h.slice(r,g);for(r=0;r<oa;++r)if(n[r]!==\nh[r]){Q=n[r];ea=h[r];break}return Q<ea?-1:ea<Q?1:0};q.prototype.includes=function(h,r,g){return this.indexOf(h,r,g)!==-1};q.prototype.indexOf=function(h,r,g){return v(this,h,r,g,!0)};q.prototype.lastIndexOf=function(h,r,g){return v(this,h,r,g,!1)};q.prototype.write=function(h,r,g,n){if(r===void 0)n=\"utf8\",g=this.length,r=0;else if(g===void 0&&typeof r===\"string\")n=r,g=this.length,r=0;else if(isFinite(r))r>>>=0,isFinite(g)?(g>>>=0,n===void 0&&(n=\"utf8\")):(n=g,g=void 0);else throw Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\nvar F=this.length-r;if(g===void 0||g>F)g=F;if(h.length>0&&(g<0||r<0)||r>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");n||=\"utf8\";for(F=!1;;)switch(n){case \"hex\":a:{r=Number(r)||0;n=this.length-r;g?(g=Number(g),g>n&&(g=n)):g=n;n=h.length;g>n/2&&(g=n/2);for(n=0;n<g;++n){F=parseInt(h.substr(n*2,2),16);if(F!==F){h=n;break a}this[r+n]=F}h=n}return h;case \"utf8\":case \"utf-8\":return ta(ja(h,this.length-r),this,r,g);case \"ascii\":case \"latin1\":case \"binary\":n=[];for(F=0;F<h.length;++F)n.push(h.charCodeAt(F)&\n255);return ta(n,this,r,g);case \"base64\":return ta(la(h),this,r,g);case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":var Q=void 0;n=this.length-r;const ea=[];for(let oa=0;oa<h.length&&!((n-=2)<0);++oa)Q=h.charCodeAt(oa),F=Q>>8,Q%=256,ea.push(Q),ea.push(F);return ta(ea,this,r,g);default:if(F)throw new TypeError(\"Unknown encoding: \"+n);n=(\"\"+n).toLowerCase();F=!0}};q.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};q.prototype.slice=function(h,\nr){const g=this.length;h=~~h;r=r===void 0?g:~~r;h<0?(h+=g,h<0&&(h=0)):h>g&&(h=g);r<0?(r+=g,r<0&&(r=0)):r>g&&(r=g);r<h&&(r=h);h=this.subarray(h,r);Object.setPrototypeOf(h,q.prototype);return h};q.prototype.readUintLE=q.prototype.readUIntLE=function(h,r,g){h>>>=0;r>>>=0;g||l(h,r,this.length);g=this[h];let n=1,F=0;for(;++F<r&&(n*=256);)g+=this[h+F]*n;return g};q.prototype.readUintBE=q.prototype.readUIntBE=function(h,r,g){h>>>=0;r>>>=0;g||l(h,r,this.length);g=this[h+--r];let n=1;for(;r>0&&(n*=256);)g+=\nthis[h+--r]*n;return g};q.prototype.readUint8=q.prototype.readUInt8=function(h,r){h>>>=0;r||l(h,1,this.length);return this[h]};q.prototype.readUint16LE=q.prototype.readUInt16LE=function(h,r){h>>>=0;r||l(h,2,this.length);return this[h]|this[h+1]<<8};q.prototype.readUint16BE=q.prototype.readUInt16BE=function(h,r){h>>>=0;r||l(h,2,this.length);return this[h]<<8|this[h+1]};q.prototype.readUint32LE=q.prototype.readUInt32LE=function(h,r){h>>>=0;r||l(h,4,this.length);return(this[h]|this[h+1]<<8|this[h+2]<<\n16)+this[h+3]*16777216};q.prototype.readUint32BE=q.prototype.readUInt32BE=function(h,r){h>>>=0;r||l(h,4,this.length);return this[h]*16777216+(this[h+1]<<16|this[h+2]<<8|this[h+3])};q.prototype.readBigUInt64LE=W(function(h){h>>>=0;da(h,\"offset\");var r=this[h];const g=this[h+7];r!==void 0&&g!==void 0||fa(h,this.length-8);r=r+this[++h]*256+this[++h]*65536+this[++h]*2**24;h=this[++h]+this[++h]*256+this[++h]*65536+g*2**24;return BigInt(r)+(BigInt(h)<<BigInt(32))});q.prototype.readBigUInt64BE=W(function(h){h>>>=\n0;da(h,\"offset\");var r=this[h];const g=this[h+7];r!==void 0&&g!==void 0||fa(h,this.length-8);r=r*2**24+this[++h]*65536+this[++h]*256+this[++h];h=this[++h]*2**24+this[++h]*65536+this[++h]*256+g;return(BigInt(r)<<BigInt(32))+BigInt(h)});q.prototype.readIntLE=function(h,r,g){h>>>=0;r>>>=0;g||l(h,r,this.length);g=this[h];let n=1,F=0;for(;++F<r&&(n*=256);)g+=this[h+F]*n;g>=n*128&&(g-=Math.pow(2,8*r));return g};q.prototype.readIntBE=function(h,r,g){h>>>=0;r>>>=0;g||l(h,r,this.length);g=r;let n=1,F=this[h+\n--g];for(;g>0&&(n*=256);)F+=this[h+--g]*n;F>=n*128&&(F-=Math.pow(2,8*r));return F};q.prototype.readInt8=function(h,r){h>>>=0;r||l(h,1,this.length);return this[h]&128?(255-this[h]+1)*-1:this[h]};q.prototype.readInt16LE=function(h,r){h>>>=0;r||l(h,2,this.length);h=this[h]|this[h+1]<<8;return h&32768?h|4294901760:h};q.prototype.readInt16BE=function(h,r){h>>>=0;r||l(h,2,this.length);h=this[h+1]|this[h]<<8;return h&32768?h|4294901760:h};q.prototype.readInt32LE=function(h,r){h>>>=0;r||l(h,4,this.length);\nreturn this[h]|this[h+1]<<8|this[h+2]<<16|this[h+3]<<24};q.prototype.readInt32BE=function(h,r){h>>>=0;r||l(h,4,this.length);return this[h]<<24|this[h+1]<<16|this[h+2]<<8|this[h+3]};q.prototype.readBigInt64LE=W(function(h){h>>>=0;da(h,\"offset\");const r=this[h],g=this[h+7];r!==void 0&&g!==void 0||fa(h,this.length-8);return(BigInt(this[h+4]+this[h+5]*256+this[h+6]*65536+(g<<24))<<BigInt(32))+BigInt(r+this[++h]*256+this[++h]*65536+this[++h]*2**24)});q.prototype.readBigInt64BE=W(function(h){h>>>=0;da(h,\n\"offset\");var r=this[h];const g=this[h+7];r!==void 0&&g!==void 0||fa(h,this.length-8);r=(r<<24)+this[++h]*65536+this[++h]*256+this[++h];return(BigInt(r)<<BigInt(32))+BigInt(this[++h]*2**24+this[++h]*65536+this[++h]*256+g)});q.prototype.readFloatLE=function(h,r){h>>>=0;r||l(h,4,this.length);return ma.read(this,h,!0,23,4)};q.prototype.readFloatBE=function(h,r){h>>>=0;r||l(h,4,this.length);return ma.read(this,h,!1,23,4)};q.prototype.readDoubleLE=function(h,r){h>>>=0;r||l(h,8,this.length);return ma.read(this,\nh,!0,52,8)};q.prototype.readDoubleBE=function(h,r){h>>>=0;r||l(h,8,this.length);return ma.read(this,h,!1,52,8)};q.prototype.writeUintLE=q.prototype.writeUIntLE=function(h,r,g,n){h=+h;r>>>=0;g>>>=0;n||t(this,h,r,g,Math.pow(2,8*g)-1,0);n=1;let F=0;for(this[r]=h&255;++F<g&&(n*=256);)this[r+F]=h/n&255;return r+g};q.prototype.writeUintBE=q.prototype.writeUIntBE=function(h,r,g,n){h=+h;r>>>=0;g>>>=0;n||t(this,h,r,g,Math.pow(2,8*g)-1,0);n=g-1;let F=1;for(this[r+n]=h&255;--n>=0&&(F*=256);)this[r+n]=h/F&255;\nreturn r+g};q.prototype.writeUint8=q.prototype.writeUInt8=function(h,r,g){h=+h;r>>>=0;g||t(this,h,r,1,255,0);this[r]=h&255;return r+1};q.prototype.writeUint16LE=q.prototype.writeUInt16LE=function(h,r,g){h=+h;r>>>=0;g||t(this,h,r,2,65535,0);this[r]=h&255;this[r+1]=h>>>8;return r+2};q.prototype.writeUint16BE=q.prototype.writeUInt16BE=function(h,r,g){h=+h;r>>>=0;g||t(this,h,r,2,65535,0);this[r]=h>>>8;this[r+1]=h&255;return r+2};q.prototype.writeUint32LE=q.prototype.writeUInt32LE=function(h,r,g){h=+h;\nr>>>=0;g||t(this,h,r,4,4294967295,0);this[r+3]=h>>>24;this[r+2]=h>>>16;this[r+1]=h>>>8;this[r]=h&255;return r+4};q.prototype.writeUint32BE=q.prototype.writeUInt32BE=function(h,r,g){h=+h;r>>>=0;g||t(this,h,r,4,4294967295,0);this[r]=h>>>24;this[r+1]=h>>>16;this[r+2]=h>>>8;this[r+3]=h&255;return r+4};q.prototype.writeBigUInt64LE=W(function(h,r=0){return x(this,h,r,BigInt(0),BigInt(\"0xffffffffffffffff\"))});q.prototype.writeBigUInt64BE=W(function(h,r=0){return w(this,h,r,BigInt(0),BigInt(\"0xffffffffffffffff\"))});\nq.prototype.writeIntLE=function(h,r,g,n){h=+h;r>>>=0;n||(n=Math.pow(2,8*g-1),t(this,h,r,g,n-1,-n));n=0;let F=1,Q=0;for(this[r]=h&255;++n<g&&(F*=256);)h<0&&Q===0&&this[r+n-1]!==0&&(Q=1),this[r+n]=(h/F>>0)-Q&255;return r+g};q.prototype.writeIntBE=function(h,r,g,n){h=+h;r>>>=0;n||(n=Math.pow(2,8*g-1),t(this,h,r,g,n-1,-n));n=g-1;let F=1,Q=0;for(this[r+n]=h&255;--n>=0&&(F*=256);)h<0&&Q===0&&this[r+n+1]!==0&&(Q=1),this[r+n]=(h/F>>0)-Q&255;return r+g};q.prototype.writeInt8=function(h,r,g){h=+h;r>>>=0;g||\nt(this,h,r,1,127,-128);h<0&&(h=255+h+1);this[r]=h&255;return r+1};q.prototype.writeInt16LE=function(h,r,g){h=+h;r>>>=0;g||t(this,h,r,2,32767,-32768);this[r]=h&255;this[r+1]=h>>>8;return r+2};q.prototype.writeInt16BE=function(h,r,g){h=+h;r>>>=0;g||t(this,h,r,2,32767,-32768);this[r]=h>>>8;this[r+1]=h&255;return r+2};q.prototype.writeInt32LE=function(h,r,g){h=+h;r>>>=0;g||t(this,h,r,4,2147483647,-2147483648);this[r]=h&255;this[r+1]=h>>>8;this[r+2]=h>>>16;this[r+3]=h>>>24;return r+4};q.prototype.writeInt32BE=\nfunction(h,r,g){h=+h;r>>>=0;g||t(this,h,r,4,2147483647,-2147483648);h<0&&(h=4294967295+h+1);this[r]=h>>>24;this[r+1]=h>>>16;this[r+2]=h>>>8;this[r+3]=h&255;return r+4};q.prototype.writeBigInt64LE=W(function(h,r=0){return x(this,h,r,-BigInt(\"0x8000000000000000\"),BigInt(\"0x7fffffffffffffff\"))});q.prototype.writeBigInt64BE=W(function(h,r=0){return w(this,h,r,-BigInt(\"0x8000000000000000\"),BigInt(\"0x7fffffffffffffff\"))});q.prototype.writeFloatLE=function(h,r,g){return L(this,h,r,!0,g)};q.prototype.writeFloatBE=\nfunction(h,r,g){return L(this,h,r,!1,g)};q.prototype.writeDoubleLE=function(h,r,g){return P(this,h,r,!0,g)};q.prototype.writeDoubleBE=function(h,r,g){return P(this,h,r,!1,g)};q.prototype.copy=function(h,r,g,n){if(!q.isBuffer(h))throw new TypeError(\"argument should be a Buffer\");g||=0;n||n===0||(n=this.length);r>=h.length&&(r=h.length);r||=0;n>0&&n<g&&(n=g);if(n===g||h.length===0||this.length===0)return 0;if(r<0)throw new RangeError(\"targetStart out of bounds\");if(g<0||g>=this.length)throw new RangeError(\"Index out of range\");\nif(n<0)throw new RangeError(\"sourceEnd out of bounds\");n>this.length&&(n=this.length);h.length-r<n-g&&(n=h.length-r+g);const F=n-g;this===h&&typeof Uint8Array.prototype.copyWithin===\"function\"?this.copyWithin(r,g,n):Uint8Array.prototype.set.call(h,this.subarray(g,n),r);return F};q.prototype.fill=function(h,r,g,n){if(typeof h===\"string\"){typeof r===\"string\"?(n=r,r=0,g=this.length):typeof g===\"string\"&&(n=g,g=this.length);if(n!==void 0&&typeof n!==\"string\")throw new TypeError(\"encoding must be a string\");\nif(typeof n===\"string\"&&!q.isEncoding(n))throw new TypeError(\"Unknown encoding: \"+n);if(h.length===1){var F=h.charCodeAt(0);if(n===\"utf8\"&&F<128||n===\"latin1\")h=F}}else typeof h===\"number\"?h&=255:typeof h===\"boolean\"&&(h=Number(h));if(r<0||this.length<r||this.length<g)throw new RangeError(\"Out of range index\");if(g<=r)return this;r>>>=0;g=g===void 0?this.length:g>>>0;h||=0;if(typeof h===\"number\")for(n=r;n<g;++n)this[n]=h;else{F=q.isBuffer(h)?h:q.from(h,n);const Q=F.length;if(Q===0)throw new TypeError('The value \"'+\nh+'\" is invalid for argument \"value\"');for(n=0;n<g-r;++n)this[n+r]=F[n%Q]}return this};const sa={};T(\"ERR_BUFFER_OUT_OF_BOUNDS\",function(h){return h?`${h} is outside of buffer bounds`:\"Attempt to access memory outside buffer bounds\"},RangeError);T(\"ERR_INVALID_ARG_TYPE\",function(h,r){return`The \"${h}\" argument must be of type number. Received type ${typeof r}`},TypeError);T(\"ERR_OUT_OF_RANGE\",function(h,r,g){h=`The value of \"${h}\" is out of range.`;let n=g;if(Number.isInteger(g)&&Math.abs(g)>2**32)n=\nY(String(g));else if(typeof g===\"bigint\"){n=String(g);if(g>BigInt(2)**BigInt(32)||g<-(BigInt(2)**BigInt(32)))n=Y(n);n+=\"n\"}return h+` It must be ${r}. Received ${n}`},RangeError);const ya=/[^+/0-9A-Za-z-_]/g,Ea=function(){const h=Array(256);for(let r=0;r<16;++r){const g=r*16;for(let n=0;n<16;++n)h[g+n]=\"0123456789abcdef\"[r]+\"0123456789abcdef\"[n]}return h}()}","~:source","shadow$provide[34] = function(require,module,exports) {\n/*!\r\n * The buffer module from node.js, for the browser.\r\n *\r\n * @author   Feross Aboukhadijeh <https://feross.org>\r\n * @license  MIT\r\n */\r\n/* eslint-disable no-proto */\r\n\r\n'use strict'\r\n\r\nconst base64 = require('base64-js')\r\nconst ieee754 = require('ieee754')\r\nconst customInspectSymbol =\r\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\r\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\r\n    : null\r\n\r\nexports.Buffer = Buffer\r\nexports.SlowBuffer = SlowBuffer\r\nexports.INSPECT_MAX_BYTES = 50\r\n\r\nconst K_MAX_LENGTH = 0x7fffffff\r\nexports.kMaxLength = K_MAX_LENGTH\r\n\r\n/**\r\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n *   === true    Use Uint8Array implementation (fastest)\r\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\r\n *               implementation (most compatible, even IE6)\r\n *\r\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n * Opera 11.6+, iOS 4.2+.\r\n *\r\n * We report that the browser does not support typed arrays if the are not subclassable\r\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\r\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\r\n * for __proto__ and has a buggy typed array implementation.\r\n */\r\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\r\n\r\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\r\n    typeof console.error === 'function') {\r\n  console.error(\r\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\r\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\r\n  )\r\n}\r\n\r\nfunction typedArraySupport () {\r\n  // Can typed array instances can be augmented?\r\n  try {\r\n    const arr = new Uint8Array(1)\r\n    const proto = { foo: function () { return 42 } }\r\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\r\n    Object.setPrototypeOf(arr, proto)\r\n    return arr.foo() === 42\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nObject.defineProperty(Buffer.prototype, 'parent', {\r\n  enumerable: true,\r\n  get: function () {\r\n    if (!Buffer.isBuffer(this)) return undefined\r\n    return this.buffer\r\n  }\r\n})\r\n\r\nObject.defineProperty(Buffer.prototype, 'offset', {\r\n  enumerable: true,\r\n  get: function () {\r\n    if (!Buffer.isBuffer(this)) return undefined\r\n    return this.byteOffset\r\n  }\r\n})\r\n\r\nfunction createBuffer (length) {\r\n  if (length > K_MAX_LENGTH) {\r\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\r\n  }\r\n  // Return an augmented `Uint8Array` instance\r\n  const buf = new Uint8Array(length)\r\n  Object.setPrototypeOf(buf, Buffer.prototype)\r\n  return buf\r\n}\r\n\r\n/**\r\n * The Buffer constructor returns instances of `Uint8Array` that have their\r\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n * returns a single octet.\r\n *\r\n * The `Uint8Array` prototype remains unmodified.\r\n */\r\n\r\nfunction Buffer (arg, encodingOrOffset, length) {\r\n  // Common case.\r\n  if (typeof arg === 'number') {\r\n    if (typeof encodingOrOffset === 'string') {\r\n      throw new TypeError(\r\n        'The \"string\" argument must be of type string. Received type number'\r\n      )\r\n    }\r\n    return allocUnsafe(arg)\r\n  }\r\n  return from(arg, encodingOrOffset, length)\r\n}\r\n\r\nBuffer.poolSize = 8192 // not used by this implementation\r\n\r\nfunction from (value, encodingOrOffset, length) {\r\n  if (typeof value === 'string') {\r\n    return fromString(value, encodingOrOffset)\r\n  }\r\n\r\n  if (ArrayBuffer.isView(value)) {\r\n    return fromArrayView(value)\r\n  }\r\n\r\n  if (value == null) {\r\n    throw new TypeError(\r\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\r\n      'or Array-like Object. Received type ' + (typeof value)\r\n    )\r\n  }\r\n\r\n  if (isInstance(value, ArrayBuffer) ||\r\n      (value && isInstance(value.buffer, ArrayBuffer))) {\r\n    return fromArrayBuffer(value, encodingOrOffset, length)\r\n  }\r\n\r\n  if (typeof SharedArrayBuffer !== 'undefined' &&\r\n      (isInstance(value, SharedArrayBuffer) ||\r\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\r\n    return fromArrayBuffer(value, encodingOrOffset, length)\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    throw new TypeError(\r\n      'The \"value\" argument must not be of type number. Received type number'\r\n    )\r\n  }\r\n\r\n  const valueOf = value.valueOf && value.valueOf()\r\n  if (valueOf != null && valueOf !== value) {\r\n    return Buffer.from(valueOf, encodingOrOffset, length)\r\n  }\r\n\r\n  const b = fromObject(value)\r\n  if (b) return b\r\n\r\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\r\n      typeof value[Symbol.toPrimitive] === 'function') {\r\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\r\n  }\r\n\r\n  throw new TypeError(\r\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\r\n    'or Array-like Object. Received type ' + (typeof value)\r\n  )\r\n}\r\n\r\n/**\r\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n * if value is a number.\r\n * Buffer.from(str[, encoding])\r\n * Buffer.from(array)\r\n * Buffer.from(buffer)\r\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n **/\r\nBuffer.from = function (value, encodingOrOffset, length) {\r\n  return from(value, encodingOrOffset, length)\r\n}\r\n\r\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\r\n// https://github.com/feross/buffer/pull/148\r\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\r\nObject.setPrototypeOf(Buffer, Uint8Array)\r\n\r\nfunction assertSize (size) {\r\n  if (typeof size !== 'number') {\r\n    throw new TypeError('\"size\" argument must be of type number')\r\n  } else if (size < 0) {\r\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\r\n  }\r\n}\r\n\r\nfunction alloc (size, fill, encoding) {\r\n  assertSize(size)\r\n  if (size <= 0) {\r\n    return createBuffer(size)\r\n  }\r\n  if (fill !== undefined) {\r\n    // Only pay attention to encoding if it's a string. This\r\n    // prevents accidentally sending in a number that would\r\n    // be interpreted as a start offset.\r\n    return typeof encoding === 'string'\r\n      ? createBuffer(size).fill(fill, encoding)\r\n      : createBuffer(size).fill(fill)\r\n  }\r\n  return createBuffer(size)\r\n}\r\n\r\n/**\r\n * Creates a new filled Buffer instance.\r\n * alloc(size[, fill[, encoding]])\r\n **/\r\nBuffer.alloc = function (size, fill, encoding) {\r\n  return alloc(size, fill, encoding)\r\n}\r\n\r\nfunction allocUnsafe (size) {\r\n  assertSize(size)\r\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\r\n}\r\n\r\n/**\r\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n * */\r\nBuffer.allocUnsafe = function (size) {\r\n  return allocUnsafe(size)\r\n}\r\n/**\r\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n */\r\nBuffer.allocUnsafeSlow = function (size) {\r\n  return allocUnsafe(size)\r\n}\r\n\r\nfunction fromString (string, encoding) {\r\n  if (typeof encoding !== 'string' || encoding === '') {\r\n    encoding = 'utf8'\r\n  }\r\n\r\n  if (!Buffer.isEncoding(encoding)) {\r\n    throw new TypeError('Unknown encoding: ' + encoding)\r\n  }\r\n\r\n  const length = byteLength(string, encoding) | 0\r\n  let buf = createBuffer(length)\r\n\r\n  const actual = buf.write(string, encoding)\r\n\r\n  if (actual !== length) {\r\n    // Writing a hex string, for example, that contains invalid characters will\r\n    // cause everything after the first invalid character to be ignored. (e.g.\r\n    // 'abxxcd' will be treated as 'ab')\r\n    buf = buf.slice(0, actual)\r\n  }\r\n\r\n  return buf\r\n}\r\n\r\nfunction fromArrayLike (array) {\r\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\r\n  const buf = createBuffer(length)\r\n  for (let i = 0; i < length; i += 1) {\r\n    buf[i] = array[i] & 255\r\n  }\r\n  return buf\r\n}\r\n\r\nfunction fromArrayView (arrayView) {\r\n  if (isInstance(arrayView, Uint8Array)) {\r\n    const copy = new Uint8Array(arrayView)\r\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\r\n  }\r\n  return fromArrayLike(arrayView)\r\n}\r\n\r\nfunction fromArrayBuffer (array, byteOffset, length) {\r\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\r\n    throw new RangeError('\"offset\" is outside of buffer bounds')\r\n  }\r\n\r\n  if (array.byteLength < byteOffset + (length || 0)) {\r\n    throw new RangeError('\"length\" is outside of buffer bounds')\r\n  }\r\n\r\n  let buf\r\n  if (byteOffset === undefined && length === undefined) {\r\n    buf = new Uint8Array(array)\r\n  } else if (length === undefined) {\r\n    buf = new Uint8Array(array, byteOffset)\r\n  } else {\r\n    buf = new Uint8Array(array, byteOffset, length)\r\n  }\r\n\r\n  // Return an augmented `Uint8Array` instance\r\n  Object.setPrototypeOf(buf, Buffer.prototype)\r\n\r\n  return buf\r\n}\r\n\r\nfunction fromObject (obj) {\r\n  if (Buffer.isBuffer(obj)) {\r\n    const len = checked(obj.length) | 0\r\n    const buf = createBuffer(len)\r\n\r\n    if (buf.length === 0) {\r\n      return buf\r\n    }\r\n\r\n    obj.copy(buf, 0, 0, len)\r\n    return buf\r\n  }\r\n\r\n  if (obj.length !== undefined) {\r\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\r\n      return createBuffer(0)\r\n    }\r\n    return fromArrayLike(obj)\r\n  }\r\n\r\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\r\n    return fromArrayLike(obj.data)\r\n  }\r\n}\r\n\r\nfunction checked (length) {\r\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\r\n  // length is NaN (which is otherwise coerced to zero.)\r\n  if (length >= K_MAX_LENGTH) {\r\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\r\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\r\n  }\r\n  return length | 0\r\n}\r\n\r\nfunction SlowBuffer (length) {\r\n  if (+length != length) { // eslint-disable-line eqeqeq\r\n    length = 0\r\n  }\r\n  return Buffer.alloc(+length)\r\n}\r\n\r\nBuffer.isBuffer = function isBuffer (b) {\r\n  return b != null && b._isBuffer === true &&\r\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\r\n}\r\n\r\nBuffer.compare = function compare (a, b) {\r\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\r\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\r\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\r\n    throw new TypeError(\r\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\r\n    )\r\n  }\r\n\r\n  if (a === b) return 0\r\n\r\n  let x = a.length\r\n  let y = b.length\r\n\r\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\r\n    if (a[i] !== b[i]) {\r\n      x = a[i]\r\n      y = b[i]\r\n      break\r\n    }\r\n  }\r\n\r\n  if (x < y) return -1\r\n  if (y < x) return 1\r\n  return 0\r\n}\r\n\r\nBuffer.isEncoding = function isEncoding (encoding) {\r\n  switch (String(encoding).toLowerCase()) {\r\n    case 'hex':\r\n    case 'utf8':\r\n    case 'utf-8':\r\n    case 'ascii':\r\n    case 'latin1':\r\n    case 'binary':\r\n    case 'base64':\r\n    case 'ucs2':\r\n    case 'ucs-2':\r\n    case 'utf16le':\r\n    case 'utf-16le':\r\n      return true\r\n    default:\r\n      return false\r\n  }\r\n}\r\n\r\nBuffer.concat = function concat (list, length) {\r\n  if (!Array.isArray(list)) {\r\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n  }\r\n\r\n  if (list.length === 0) {\r\n    return Buffer.alloc(0)\r\n  }\r\n\r\n  let i\r\n  if (length === undefined) {\r\n    length = 0\r\n    for (i = 0; i < list.length; ++i) {\r\n      length += list[i].length\r\n    }\r\n  }\r\n\r\n  const buffer = Buffer.allocUnsafe(length)\r\n  let pos = 0\r\n  for (i = 0; i < list.length; ++i) {\r\n    let buf = list[i]\r\n    if (isInstance(buf, Uint8Array)) {\r\n      if (pos + buf.length > buffer.length) {\r\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\r\n        buf.copy(buffer, pos)\r\n      } else {\r\n        Uint8Array.prototype.set.call(\r\n          buffer,\r\n          buf,\r\n          pos\r\n        )\r\n      }\r\n    } else if (!Buffer.isBuffer(buf)) {\r\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n    } else {\r\n      buf.copy(buffer, pos)\r\n    }\r\n    pos += buf.length\r\n  }\r\n  return buffer\r\n}\r\n\r\nfunction byteLength (string, encoding) {\r\n  if (Buffer.isBuffer(string)) {\r\n    return string.length\r\n  }\r\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\r\n    return string.byteLength\r\n  }\r\n  if (typeof string !== 'string') {\r\n    throw new TypeError(\r\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\r\n      'Received type ' + typeof string\r\n    )\r\n  }\r\n\r\n  const len = string.length\r\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\r\n  if (!mustMatch && len === 0) return 0\r\n\r\n  // Use a for loop to avoid recursion\r\n  let loweredCase = false\r\n  for (;;) {\r\n    switch (encoding) {\r\n      case 'ascii':\r\n      case 'latin1':\r\n      case 'binary':\r\n        return len\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return utf8ToBytes(string).length\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return len * 2\r\n      case 'hex':\r\n        return len >>> 1\r\n      case 'base64':\r\n        return base64ToBytes(string).length\r\n      default:\r\n        if (loweredCase) {\r\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\r\n        }\r\n        encoding = ('' + encoding).toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\nBuffer.byteLength = byteLength\r\n\r\nfunction slowToString (encoding, start, end) {\r\n  let loweredCase = false\r\n\r\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\r\n  // property of a typed array.\r\n\r\n  // This behaves neither like String nor Uint8Array in that we set start/end\r\n  // to their upper/lower bounds if the value passed is out of range.\r\n  // undefined is handled specially as per ECMA-262 6th Edition,\r\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\r\n  if (start === undefined || start < 0) {\r\n    start = 0\r\n  }\r\n  // Return early if start > this.length. Done here to prevent potential uint32\r\n  // coercion fail below.\r\n  if (start > this.length) {\r\n    return ''\r\n  }\r\n\r\n  if (end === undefined || end > this.length) {\r\n    end = this.length\r\n  }\r\n\r\n  if (end <= 0) {\r\n    return ''\r\n  }\r\n\r\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\r\n  end >>>= 0\r\n  start >>>= 0\r\n\r\n  if (end <= start) {\r\n    return ''\r\n  }\r\n\r\n  if (!encoding) encoding = 'utf8'\r\n\r\n  while (true) {\r\n    switch (encoding) {\r\n      case 'hex':\r\n        return hexSlice(this, start, end)\r\n\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return utf8Slice(this, start, end)\r\n\r\n      case 'ascii':\r\n        return asciiSlice(this, start, end)\r\n\r\n      case 'latin1':\r\n      case 'binary':\r\n        return latin1Slice(this, start, end)\r\n\r\n      case 'base64':\r\n        return base64Slice(this, start, end)\r\n\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return utf16leSlice(this, start, end)\r\n\r\n      default:\r\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n        encoding = (encoding + '').toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\n\r\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\r\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\r\n// reliably in a browserify context because there could be multiple different\r\n// copies of the 'buffer' package in use. This method works even for Buffer\r\n// instances that were created from another copy of the `buffer` package.\r\n// See: https://github.com/feross/buffer/issues/154\r\nBuffer.prototype._isBuffer = true\r\n\r\nfunction swap (b, n, m) {\r\n  const i = b[n]\r\n  b[n] = b[m]\r\n  b[m] = i\r\n}\r\n\r\nBuffer.prototype.swap16 = function swap16 () {\r\n  const len = this.length\r\n  if (len % 2 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\r\n  }\r\n  for (let i = 0; i < len; i += 2) {\r\n    swap(this, i, i + 1)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.swap32 = function swap32 () {\r\n  const len = this.length\r\n  if (len % 4 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\r\n  }\r\n  for (let i = 0; i < len; i += 4) {\r\n    swap(this, i, i + 3)\r\n    swap(this, i + 1, i + 2)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.swap64 = function swap64 () {\r\n  const len = this.length\r\n  if (len % 8 !== 0) {\r\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\r\n  }\r\n  for (let i = 0; i < len; i += 8) {\r\n    swap(this, i, i + 7)\r\n    swap(this, i + 1, i + 6)\r\n    swap(this, i + 2, i + 5)\r\n    swap(this, i + 3, i + 4)\r\n  }\r\n  return this\r\n}\r\n\r\nBuffer.prototype.toString = function toString () {\r\n  const length = this.length\r\n  if (length === 0) return ''\r\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\r\n  return slowToString.apply(this, arguments)\r\n}\r\n\r\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\r\n\r\nBuffer.prototype.equals = function equals (b) {\r\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\r\n  if (this === b) return true\r\n  return Buffer.compare(this, b) === 0\r\n}\r\n\r\nBuffer.prototype.inspect = function inspect () {\r\n  let str = ''\r\n  const max = exports.INSPECT_MAX_BYTES\r\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\r\n  if (this.length > max) str += ' ... '\r\n  return '<Buffer ' + str + '>'\r\n}\r\nif (customInspectSymbol) {\r\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\r\n}\r\n\r\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\r\n  if (isInstance(target, Uint8Array)) {\r\n    target = Buffer.from(target, target.offset, target.byteLength)\r\n  }\r\n  if (!Buffer.isBuffer(target)) {\r\n    throw new TypeError(\r\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\r\n      'Received type ' + (typeof target)\r\n    )\r\n  }\r\n\r\n  if (start === undefined) {\r\n    start = 0\r\n  }\r\n  if (end === undefined) {\r\n    end = target ? target.length : 0\r\n  }\r\n  if (thisStart === undefined) {\r\n    thisStart = 0\r\n  }\r\n  if (thisEnd === undefined) {\r\n    thisEnd = this.length\r\n  }\r\n\r\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\r\n    throw new RangeError('out of range index')\r\n  }\r\n\r\n  if (thisStart >= thisEnd && start >= end) {\r\n    return 0\r\n  }\r\n  if (thisStart >= thisEnd) {\r\n    return -1\r\n  }\r\n  if (start >= end) {\r\n    return 1\r\n  }\r\n\r\n  start >>>= 0\r\n  end >>>= 0\r\n  thisStart >>>= 0\r\n  thisEnd >>>= 0\r\n\r\n  if (this === target) return 0\r\n\r\n  let x = thisEnd - thisStart\r\n  let y = end - start\r\n  const len = Math.min(x, y)\r\n\r\n  const thisCopy = this.slice(thisStart, thisEnd)\r\n  const targetCopy = target.slice(start, end)\r\n\r\n  for (let i = 0; i < len; ++i) {\r\n    if (thisCopy[i] !== targetCopy[i]) {\r\n      x = thisCopy[i]\r\n      y = targetCopy[i]\r\n      break\r\n    }\r\n  }\r\n\r\n  if (x < y) return -1\r\n  if (y < x) return 1\r\n  return 0\r\n}\r\n\r\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\r\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\r\n//\r\n// Arguments:\r\n// - buffer - a Buffer to search\r\n// - val - a string, Buffer, or number\r\n// - byteOffset - an index into `buffer`; will be clamped to an int32\r\n// - encoding - an optional encoding, relevant is val is a string\r\n// - dir - true for indexOf, false for lastIndexOf\r\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\r\n  // Empty buffer means no match\r\n  if (buffer.length === 0) return -1\r\n\r\n  // Normalize byteOffset\r\n  if (typeof byteOffset === 'string') {\r\n    encoding = byteOffset\r\n    byteOffset = 0\r\n  } else if (byteOffset > 0x7fffffff) {\r\n    byteOffset = 0x7fffffff\r\n  } else if (byteOffset < -0x80000000) {\r\n    byteOffset = -0x80000000\r\n  }\r\n  byteOffset = +byteOffset // Coerce to Number.\r\n  if (numberIsNaN(byteOffset)) {\r\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\r\n    byteOffset = dir ? 0 : (buffer.length - 1)\r\n  }\r\n\r\n  // Normalize byteOffset: negative offsets start from the end of the buffer\r\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\r\n  if (byteOffset >= buffer.length) {\r\n    if (dir) return -1\r\n    else byteOffset = buffer.length - 1\r\n  } else if (byteOffset < 0) {\r\n    if (dir) byteOffset = 0\r\n    else return -1\r\n  }\r\n\r\n  // Normalize val\r\n  if (typeof val === 'string') {\r\n    val = Buffer.from(val, encoding)\r\n  }\r\n\r\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\r\n  if (Buffer.isBuffer(val)) {\r\n    // Special case: looking for empty string/buffer always fails\r\n    if (val.length === 0) {\r\n      return -1\r\n    }\r\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\r\n  } else if (typeof val === 'number') {\r\n    val = val & 0xFF // Search for a byte value [0-255]\r\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\r\n      if (dir) {\r\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\r\n      } else {\r\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\r\n      }\r\n    }\r\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\r\n  }\r\n\r\n  throw new TypeError('val must be string, number or Buffer')\r\n}\r\n\r\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\r\n  let indexSize = 1\r\n  let arrLength = arr.length\r\n  let valLength = val.length\r\n\r\n  if (encoding !== undefined) {\r\n    encoding = String(encoding).toLowerCase()\r\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\r\n        encoding === 'utf16le' || encoding === 'utf-16le') {\r\n      if (arr.length < 2 || val.length < 2) {\r\n        return -1\r\n      }\r\n      indexSize = 2\r\n      arrLength /= 2\r\n      valLength /= 2\r\n      byteOffset /= 2\r\n    }\r\n  }\r\n\r\n  function read (buf, i) {\r\n    if (indexSize === 1) {\r\n      return buf[i]\r\n    } else {\r\n      return buf.readUInt16BE(i * indexSize)\r\n    }\r\n  }\r\n\r\n  let i\r\n  if (dir) {\r\n    let foundIndex = -1\r\n    for (i = byteOffset; i < arrLength; i++) {\r\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\r\n        if (foundIndex === -1) foundIndex = i\r\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\r\n      } else {\r\n        if (foundIndex !== -1) i -= i - foundIndex\r\n        foundIndex = -1\r\n      }\r\n    }\r\n  } else {\r\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\r\n    for (i = byteOffset; i >= 0; i--) {\r\n      let found = true\r\n      for (let j = 0; j < valLength; j++) {\r\n        if (read(arr, i + j) !== read(val, j)) {\r\n          found = false\r\n          break\r\n        }\r\n      }\r\n      if (found) return i\r\n    }\r\n  }\r\n\r\n  return -1\r\n}\r\n\r\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\r\n  return this.indexOf(val, byteOffset, encoding) !== -1\r\n}\r\n\r\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\r\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\r\n}\r\n\r\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\r\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\r\n}\r\n\r\nfunction hexWrite (buf, string, offset, length) {\r\n  offset = Number(offset) || 0\r\n  const remaining = buf.length - offset\r\n  if (!length) {\r\n    length = remaining\r\n  } else {\r\n    length = Number(length)\r\n    if (length > remaining) {\r\n      length = remaining\r\n    }\r\n  }\r\n\r\n  const strLen = string.length\r\n\r\n  if (length > strLen / 2) {\r\n    length = strLen / 2\r\n  }\r\n  let i\r\n  for (i = 0; i < length; ++i) {\r\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\r\n    if (numberIsNaN(parsed)) return i\r\n    buf[offset + i] = parsed\r\n  }\r\n  return i\r\n}\r\n\r\nfunction utf8Write (buf, string, offset, length) {\r\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\r\n}\r\n\r\nfunction asciiWrite (buf, string, offset, length) {\r\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\r\n}\r\n\r\nfunction base64Write (buf, string, offset, length) {\r\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\r\n}\r\n\r\nfunction ucs2Write (buf, string, offset, length) {\r\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\r\n}\r\n\r\nBuffer.prototype.write = function write (string, offset, length, encoding) {\r\n  // Buffer#write(string)\r\n  if (offset === undefined) {\r\n    encoding = 'utf8'\r\n    length = this.length\r\n    offset = 0\r\n  // Buffer#write(string, encoding)\r\n  } else if (length === undefined && typeof offset === 'string') {\r\n    encoding = offset\r\n    length = this.length\r\n    offset = 0\r\n  // Buffer#write(string, offset[, length][, encoding])\r\n  } else if (isFinite(offset)) {\r\n    offset = offset >>> 0\r\n    if (isFinite(length)) {\r\n      length = length >>> 0\r\n      if (encoding === undefined) encoding = 'utf8'\r\n    } else {\r\n      encoding = length\r\n      length = undefined\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\r\n    )\r\n  }\r\n\r\n  const remaining = this.length - offset\r\n  if (length === undefined || length > remaining) length = remaining\r\n\r\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\r\n    throw new RangeError('Attempt to write outside buffer bounds')\r\n  }\r\n\r\n  if (!encoding) encoding = 'utf8'\r\n\r\n  let loweredCase = false\r\n  for (;;) {\r\n    switch (encoding) {\r\n      case 'hex':\r\n        return hexWrite(this, string, offset, length)\r\n\r\n      case 'utf8':\r\n      case 'utf-8':\r\n        return utf8Write(this, string, offset, length)\r\n\r\n      case 'ascii':\r\n      case 'latin1':\r\n      case 'binary':\r\n        return asciiWrite(this, string, offset, length)\r\n\r\n      case 'base64':\r\n        // Warning: maxLength not taken into account in base64Write\r\n        return base64Write(this, string, offset, length)\r\n\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return ucs2Write(this, string, offset, length)\r\n\r\n      default:\r\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n        encoding = ('' + encoding).toLowerCase()\r\n        loweredCase = true\r\n    }\r\n  }\r\n}\r\n\r\nBuffer.prototype.toJSON = function toJSON () {\r\n  return {\r\n    type: 'Buffer',\r\n    data: Array.prototype.slice.call(this._arr || this, 0)\r\n  }\r\n}\r\n\r\nfunction base64Slice (buf, start, end) {\r\n  if (start === 0 && end === buf.length) {\r\n    return base64.fromByteArray(buf)\r\n  } else {\r\n    return base64.fromByteArray(buf.slice(start, end))\r\n  }\r\n}\r\n\r\nfunction utf8Slice (buf, start, end) {\r\n  end = Math.min(buf.length, end)\r\n  const res = []\r\n\r\n  let i = start\r\n  while (i < end) {\r\n    const firstByte = buf[i]\r\n    let codePoint = null\r\n    let bytesPerSequence = (firstByte > 0xEF)\r\n      ? 4\r\n      : (firstByte > 0xDF)\r\n          ? 3\r\n          : (firstByte > 0xBF)\r\n              ? 2\r\n              : 1\r\n\r\n    if (i + bytesPerSequence <= end) {\r\n      let secondByte, thirdByte, fourthByte, tempCodePoint\r\n\r\n      switch (bytesPerSequence) {\r\n        case 1:\r\n          if (firstByte < 0x80) {\r\n            codePoint = firstByte\r\n          }\r\n          break\r\n        case 2:\r\n          secondByte = buf[i + 1]\r\n          if ((secondByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\r\n            if (tempCodePoint > 0x7F) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n          break\r\n        case 3:\r\n          secondByte = buf[i + 1]\r\n          thirdByte = buf[i + 2]\r\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\r\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n          break\r\n        case 4:\r\n          secondByte = buf[i + 1]\r\n          thirdByte = buf[i + 2]\r\n          fourthByte = buf[i + 3]\r\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\r\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n              codePoint = tempCodePoint\r\n            }\r\n          }\r\n      }\r\n    }\r\n\r\n    if (codePoint === null) {\r\n      // we did not generate a valid codePoint so insert a\r\n      // replacement char (U+FFFD) and advance only 1 byte\r\n      codePoint = 0xFFFD\r\n      bytesPerSequence = 1\r\n    } else if (codePoint > 0xFFFF) {\r\n      // encode to utf16 (surrogate pair dance)\r\n      codePoint -= 0x10000\r\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\r\n      codePoint = 0xDC00 | codePoint & 0x3FF\r\n    }\r\n\r\n    res.push(codePoint)\r\n    i += bytesPerSequence\r\n  }\r\n\r\n  return decodeCodePointsArray(res)\r\n}\r\n\r\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\r\n// the lowest limit is Chrome, with 0x10000 args.\r\n// We go 1 magnitude less, for safety\r\nconst MAX_ARGUMENTS_LENGTH = 0x1000\r\n\r\nfunction decodeCodePointsArray (codePoints) {\r\n  const len = codePoints.length\r\n  if (len <= MAX_ARGUMENTS_LENGTH) {\r\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\r\n  }\r\n\r\n  // Decode in chunks to avoid \"call stack size exceeded\".\r\n  let res = ''\r\n  let i = 0\r\n  while (i < len) {\r\n    res += String.fromCharCode.apply(\r\n      String,\r\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n    )\r\n  }\r\n  return res\r\n}\r\n\r\nfunction asciiSlice (buf, start, end) {\r\n  let ret = ''\r\n  end = Math.min(buf.length, end)\r\n\r\n  for (let i = start; i < end; ++i) {\r\n    ret += String.fromCharCode(buf[i] & 0x7F)\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction latin1Slice (buf, start, end) {\r\n  let ret = ''\r\n  end = Math.min(buf.length, end)\r\n\r\n  for (let i = start; i < end; ++i) {\r\n    ret += String.fromCharCode(buf[i])\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction hexSlice (buf, start, end) {\r\n  const len = buf.length\r\n\r\n  if (!start || start < 0) start = 0\r\n  if (!end || end < 0 || end > len) end = len\r\n\r\n  let out = ''\r\n  for (let i = start; i < end; ++i) {\r\n    out += hexSliceLookupTable[buf[i]]\r\n  }\r\n  return out\r\n}\r\n\r\nfunction utf16leSlice (buf, start, end) {\r\n  const bytes = buf.slice(start, end)\r\n  let res = ''\r\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\r\n  for (let i = 0; i < bytes.length - 1; i += 2) {\r\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\r\n  }\r\n  return res\r\n}\r\n\r\nBuffer.prototype.slice = function slice (start, end) {\r\n  const len = this.length\r\n  start = ~~start\r\n  end = end === undefined ? len : ~~end\r\n\r\n  if (start < 0) {\r\n    start += len\r\n    if (start < 0) start = 0\r\n  } else if (start > len) {\r\n    start = len\r\n  }\r\n\r\n  if (end < 0) {\r\n    end += len\r\n    if (end < 0) end = 0\r\n  } else if (end > len) {\r\n    end = len\r\n  }\r\n\r\n  if (end < start) end = start\r\n\r\n  const newBuf = this.subarray(start, end)\r\n  // Return an augmented `Uint8Array` instance\r\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\r\n\r\n  return newBuf\r\n}\r\n\r\n/*\r\n * Need to make sure that buffer isn't trying to write out of bounds.\r\n */\r\nfunction checkOffset (offset, ext, length) {\r\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\r\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\r\n}\r\n\r\nBuffer.prototype.readUintLE =\r\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\r\n  offset = offset >>> 0\r\n  byteLength = byteLength >>> 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  let val = this[offset]\r\n  let mul = 1\r\n  let i = 0\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    val += this[offset + i] * mul\r\n  }\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readUintBE =\r\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\r\n  offset = offset >>> 0\r\n  byteLength = byteLength >>> 0\r\n  if (!noAssert) {\r\n    checkOffset(offset, byteLength, this.length)\r\n  }\r\n\r\n  let val = this[offset + --byteLength]\r\n  let mul = 1\r\n  while (byteLength > 0 && (mul *= 0x100)) {\r\n    val += this[offset + --byteLength] * mul\r\n  }\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readUint8 =\r\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 1, this.length)\r\n  return this[offset]\r\n}\r\n\r\nBuffer.prototype.readUint16LE =\r\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  return this[offset] | (this[offset + 1] << 8)\r\n}\r\n\r\nBuffer.prototype.readUint16BE =\r\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  return (this[offset] << 8) | this[offset + 1]\r\n}\r\n\r\nBuffer.prototype.readUint32LE =\r\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return ((this[offset]) |\r\n      (this[offset + 1] << 8) |\r\n      (this[offset + 2] << 16)) +\r\n      (this[offset + 3] * 0x1000000)\r\n}\r\n\r\nBuffer.prototype.readUint32BE =\r\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset] * 0x1000000) +\r\n    ((this[offset + 1] << 16) |\r\n    (this[offset + 2] << 8) |\r\n    this[offset + 3])\r\n}\r\n\r\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\r\n  offset = offset >>> 0\r\n  validateNumber(offset, 'offset')\r\n  const first = this[offset]\r\n  const last = this[offset + 7]\r\n  if (first === undefined || last === undefined) {\r\n    boundsError(offset, this.length - 8)\r\n  }\r\n\r\n  const lo = first +\r\n    this[++offset] * 2 ** 8 +\r\n    this[++offset] * 2 ** 16 +\r\n    this[++offset] * 2 ** 24\r\n\r\n  const hi = this[++offset] +\r\n    this[++offset] * 2 ** 8 +\r\n    this[++offset] * 2 ** 16 +\r\n    last * 2 ** 24\r\n\r\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\r\n})\r\n\r\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\r\n  offset = offset >>> 0\r\n  validateNumber(offset, 'offset')\r\n  const first = this[offset]\r\n  const last = this[offset + 7]\r\n  if (first === undefined || last === undefined) {\r\n    boundsError(offset, this.length - 8)\r\n  }\r\n\r\n  const hi = first * 2 ** 24 +\r\n    this[++offset] * 2 ** 16 +\r\n    this[++offset] * 2 ** 8 +\r\n    this[++offset]\r\n\r\n  const lo = this[++offset] * 2 ** 24 +\r\n    this[++offset] * 2 ** 16 +\r\n    this[++offset] * 2 ** 8 +\r\n    last\r\n\r\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\r\n})\r\n\r\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\r\n  offset = offset >>> 0\r\n  byteLength = byteLength >>> 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  let val = this[offset]\r\n  let mul = 1\r\n  let i = 0\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    val += this[offset + i] * mul\r\n  }\r\n  mul *= 0x80\r\n\r\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\r\n  offset = offset >>> 0\r\n  byteLength = byteLength >>> 0\r\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n  let i = byteLength\r\n  let mul = 1\r\n  let val = this[offset + --i]\r\n  while (i > 0 && (mul *= 0x100)) {\r\n    val += this[offset + --i] * mul\r\n  }\r\n  mul *= 0x80\r\n\r\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n  return val\r\n}\r\n\r\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 1, this.length)\r\n  if (!(this[offset] & 0x80)) return (this[offset])\r\n  return ((0xff - this[offset] + 1) * -1)\r\n}\r\n\r\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  const val = this[offset] | (this[offset + 1] << 8)\r\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n}\r\n\r\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 2, this.length)\r\n  const val = this[offset + 1] | (this[offset] << 8)\r\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n}\r\n\r\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset]) |\r\n    (this[offset + 1] << 8) |\r\n    (this[offset + 2] << 16) |\r\n    (this[offset + 3] << 24)\r\n}\r\n\r\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n  return (this[offset] << 24) |\r\n    (this[offset + 1] << 16) |\r\n    (this[offset + 2] << 8) |\r\n    (this[offset + 3])\r\n}\r\n\r\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\r\n  offset = offset >>> 0\r\n  validateNumber(offset, 'offset')\r\n  const first = this[offset]\r\n  const last = this[offset + 7]\r\n  if (first === undefined || last === undefined) {\r\n    boundsError(offset, this.length - 8)\r\n  }\r\n\r\n  const val = this[offset + 4] +\r\n    this[offset + 5] * 2 ** 8 +\r\n    this[offset + 6] * 2 ** 16 +\r\n    (last << 24) // Overflow\r\n\r\n  return (BigInt(val) << BigInt(32)) +\r\n    BigInt(first +\r\n    this[++offset] * 2 ** 8 +\r\n    this[++offset] * 2 ** 16 +\r\n    this[++offset] * 2 ** 24)\r\n})\r\n\r\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\r\n  offset = offset >>> 0\r\n  validateNumber(offset, 'offset')\r\n  const first = this[offset]\r\n  const last = this[offset + 7]\r\n  if (first === undefined || last === undefined) {\r\n    boundsError(offset, this.length - 8)\r\n  }\r\n\r\n  const val = (first << 24) + // Overflow\r\n    this[++offset] * 2 ** 16 +\r\n    this[++offset] * 2 ** 8 +\r\n    this[++offset]\r\n\r\n  return (BigInt(val) << BigInt(32)) +\r\n    BigInt(this[++offset] * 2 ** 24 +\r\n    this[++offset] * 2 ** 16 +\r\n    this[++offset] * 2 ** 8 +\r\n    last)\r\n})\r\n\r\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n  return ieee754.read(this, offset, true, 23, 4)\r\n}\r\n\r\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 4, this.length)\r\n  return ieee754.read(this, offset, false, 23, 4)\r\n}\r\n\r\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 8, this.length)\r\n  return ieee754.read(this, offset, true, 52, 8)\r\n}\r\n\r\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkOffset(offset, 8, this.length)\r\n  return ieee754.read(this, offset, false, 52, 8)\r\n}\r\n\r\nfunction checkInt (buf, value, offset, ext, max, min) {\r\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\r\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\r\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n}\r\n\r\nBuffer.prototype.writeUintLE =\r\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  byteLength = byteLength >>> 0\r\n  if (!noAssert) {\r\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n  }\r\n\r\n  let mul = 1\r\n  let i = 0\r\n  this[offset] = value & 0xFF\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    this[offset + i] = (value / mul) & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeUintBE =\r\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  byteLength = byteLength >>> 0\r\n  if (!noAssert) {\r\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n  }\r\n\r\n  let i = byteLength - 1\r\n  let mul = 1\r\n  this[offset + i] = value & 0xFF\r\n  while (--i >= 0 && (mul *= 0x100)) {\r\n    this[offset + i] = (value / mul) & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeUint8 =\r\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\r\n  this[offset] = (value & 0xff)\r\n  return offset + 1\r\n}\r\n\r\nBuffer.prototype.writeUint16LE =\r\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n  this[offset] = (value & 0xff)\r\n  this[offset + 1] = (value >>> 8)\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeUint16BE =\r\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n  this[offset] = (value >>> 8)\r\n  this[offset + 1] = (value & 0xff)\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeUint32LE =\r\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n  this[offset + 3] = (value >>> 24)\r\n  this[offset + 2] = (value >>> 16)\r\n  this[offset + 1] = (value >>> 8)\r\n  this[offset] = (value & 0xff)\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeUint32BE =\r\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n  this[offset] = (value >>> 24)\r\n  this[offset + 1] = (value >>> 16)\r\n  this[offset + 2] = (value >>> 8)\r\n  this[offset + 3] = (value & 0xff)\r\n  return offset + 4\r\n}\r\n\r\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\r\n  checkIntBI(value, min, max, buf, offset, 7)\r\n\r\n  let lo = Number(value & BigInt(0xffffffff))\r\n  buf[offset++] = lo\r\n  lo = lo >> 8\r\n  buf[offset++] = lo\r\n  lo = lo >> 8\r\n  buf[offset++] = lo\r\n  lo = lo >> 8\r\n  buf[offset++] = lo\r\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\r\n  buf[offset++] = hi\r\n  hi = hi >> 8\r\n  buf[offset++] = hi\r\n  hi = hi >> 8\r\n  buf[offset++] = hi\r\n  hi = hi >> 8\r\n  buf[offset++] = hi\r\n  return offset\r\n}\r\n\r\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\r\n  checkIntBI(value, min, max, buf, offset, 7)\r\n\r\n  let lo = Number(value & BigInt(0xffffffff))\r\n  buf[offset + 7] = lo\r\n  lo = lo >> 8\r\n  buf[offset + 6] = lo\r\n  lo = lo >> 8\r\n  buf[offset + 5] = lo\r\n  lo = lo >> 8\r\n  buf[offset + 4] = lo\r\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\r\n  buf[offset + 3] = hi\r\n  hi = hi >> 8\r\n  buf[offset + 2] = hi\r\n  hi = hi >> 8\r\n  buf[offset + 1] = hi\r\n  hi = hi >> 8\r\n  buf[offset] = hi\r\n  return offset + 8\r\n}\r\n\r\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\r\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\r\n})\r\n\r\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\r\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\r\n})\r\n\r\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) {\r\n    const limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n  }\r\n\r\n  let i = 0\r\n  let mul = 1\r\n  let sub = 0\r\n  this[offset] = value & 0xFF\r\n  while (++i < byteLength && (mul *= 0x100)) {\r\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\r\n      sub = 1\r\n    }\r\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) {\r\n    const limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n  }\r\n\r\n  let i = byteLength - 1\r\n  let mul = 1\r\n  let sub = 0\r\n  this[offset + i] = value & 0xFF\r\n  while (--i >= 0 && (mul *= 0x100)) {\r\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\r\n      sub = 1\r\n    }\r\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n  }\r\n\r\n  return offset + byteLength\r\n}\r\n\r\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\r\n  if (value < 0) value = 0xff + value + 1\r\n  this[offset] = (value & 0xff)\r\n  return offset + 1\r\n}\r\n\r\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n  this[offset] = (value & 0xff)\r\n  this[offset + 1] = (value >>> 8)\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n  this[offset] = (value >>> 8)\r\n  this[offset + 1] = (value & 0xff)\r\n  return offset + 2\r\n}\r\n\r\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n  this[offset] = (value & 0xff)\r\n  this[offset + 1] = (value >>> 8)\r\n  this[offset + 2] = (value >>> 16)\r\n  this[offset + 3] = (value >>> 24)\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n  if (value < 0) value = 0xffffffff + value + 1\r\n  this[offset] = (value >>> 24)\r\n  this[offset + 1] = (value >>> 16)\r\n  this[offset + 2] = (value >>> 8)\r\n  this[offset + 3] = (value & 0xff)\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\r\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\r\n})\r\n\r\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\r\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\r\n})\r\n\r\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\r\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n  if (offset < 0) throw new RangeError('Index out of range')\r\n}\r\n\r\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) {\r\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\r\n  }\r\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\r\n  return offset + 4\r\n}\r\n\r\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\r\n  return writeFloat(this, value, offset, true, noAssert)\r\n}\r\n\r\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\r\n  return writeFloat(this, value, offset, false, noAssert)\r\n}\r\n\r\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\r\n  value = +value\r\n  offset = offset >>> 0\r\n  if (!noAssert) {\r\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\r\n  }\r\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\r\n  return offset + 8\r\n}\r\n\r\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\r\n  return writeDouble(this, value, offset, true, noAssert)\r\n}\r\n\r\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\r\n  return writeDouble(this, value, offset, false, noAssert)\r\n}\r\n\r\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\r\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\r\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\r\n  if (!start) start = 0\r\n  if (!end && end !== 0) end = this.length\r\n  if (targetStart >= target.length) targetStart = target.length\r\n  if (!targetStart) targetStart = 0\r\n  if (end > 0 && end < start) end = start\r\n\r\n  // Copy 0 bytes; we're done\r\n  if (end === start) return 0\r\n  if (target.length === 0 || this.length === 0) return 0\r\n\r\n  // Fatal error conditions\r\n  if (targetStart < 0) {\r\n    throw new RangeError('targetStart out of bounds')\r\n  }\r\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\r\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\r\n\r\n  // Are we oob?\r\n  if (end > this.length) end = this.length\r\n  if (target.length - targetStart < end - start) {\r\n    end = target.length - targetStart + start\r\n  }\r\n\r\n  const len = end - start\r\n\r\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\r\n    // Use built-in when available, missing from IE11\r\n    this.copyWithin(targetStart, start, end)\r\n  } else {\r\n    Uint8Array.prototype.set.call(\r\n      target,\r\n      this.subarray(start, end),\r\n      targetStart\r\n    )\r\n  }\r\n\r\n  return len\r\n}\r\n\r\n// Usage:\r\n//    buffer.fill(number[, offset[, end]])\r\n//    buffer.fill(buffer[, offset[, end]])\r\n//    buffer.fill(string[, offset[, end]][, encoding])\r\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\r\n  // Handle string cases:\r\n  if (typeof val === 'string') {\r\n    if (typeof start === 'string') {\r\n      encoding = start\r\n      start = 0\r\n      end = this.length\r\n    } else if (typeof end === 'string') {\r\n      encoding = end\r\n      end = this.length\r\n    }\r\n    if (encoding !== undefined && typeof encoding !== 'string') {\r\n      throw new TypeError('encoding must be a string')\r\n    }\r\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\r\n      throw new TypeError('Unknown encoding: ' + encoding)\r\n    }\r\n    if (val.length === 1) {\r\n      const code = val.charCodeAt(0)\r\n      if ((encoding === 'utf8' && code < 128) ||\r\n          encoding === 'latin1') {\r\n        // Fast path: If `val` fits into a single byte, use that numeric value.\r\n        val = code\r\n      }\r\n    }\r\n  } else if (typeof val === 'number') {\r\n    val = val & 255\r\n  } else if (typeof val === 'boolean') {\r\n    val = Number(val)\r\n  }\r\n\r\n  // Invalid ranges are not set to a default, so can range check early.\r\n  if (start < 0 || this.length < start || this.length < end) {\r\n    throw new RangeError('Out of range index')\r\n  }\r\n\r\n  if (end <= start) {\r\n    return this\r\n  }\r\n\r\n  start = start >>> 0\r\n  end = end === undefined ? this.length : end >>> 0\r\n\r\n  if (!val) val = 0\r\n\r\n  let i\r\n  if (typeof val === 'number') {\r\n    for (i = start; i < end; ++i) {\r\n      this[i] = val\r\n    }\r\n  } else {\r\n    const bytes = Buffer.isBuffer(val)\r\n      ? val\r\n      : Buffer.from(val, encoding)\r\n    const len = bytes.length\r\n    if (len === 0) {\r\n      throw new TypeError('The value \"' + val +\r\n        '\" is invalid for argument \"value\"')\r\n    }\r\n    for (i = 0; i < end - start; ++i) {\r\n      this[i + start] = bytes[i % len]\r\n    }\r\n  }\r\n\r\n  return this\r\n}\r\n\r\n// CUSTOM ERRORS\r\n// =============\r\n\r\n// Simplified versions from Node, changed for Buffer-only usage\r\nconst errors = {}\r\nfunction E (sym, getMessage, Base) {\r\n  errors[sym] = class NodeError extends Base {\r\n    constructor () {\r\n      super()\r\n\r\n      Object.defineProperty(this, 'message', {\r\n        value: getMessage.apply(this, arguments),\r\n        writable: true,\r\n        configurable: true\r\n      })\r\n\r\n      // Add the error code to the name to include it in the stack trace.\r\n      this.name = `${this.name} [${sym}]`\r\n      // Access the stack to generate the error message including the error code\r\n      // from the name.\r\n      this.stack // eslint-disable-line no-unused-expressions\r\n      // Reset the name to the actual name.\r\n      delete this.name\r\n    }\r\n\r\n    get code () {\r\n      return sym\r\n    }\r\n\r\n    set code (value) {\r\n      Object.defineProperty(this, 'code', {\r\n        configurable: true,\r\n        enumerable: true,\r\n        value,\r\n        writable: true\r\n      })\r\n    }\r\n\r\n    toString () {\r\n      return `${this.name} [${sym}]: ${this.message}`\r\n    }\r\n  }\r\n}\r\n\r\nE('ERR_BUFFER_OUT_OF_BOUNDS',\r\n  function (name) {\r\n    if (name) {\r\n      return `${name} is outside of buffer bounds`\r\n    }\r\n\r\n    return 'Attempt to access memory outside buffer bounds'\r\n  }, RangeError)\r\nE('ERR_INVALID_ARG_TYPE',\r\n  function (name, actual) {\r\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\r\n  }, TypeError)\r\nE('ERR_OUT_OF_RANGE',\r\n  function (str, range, input) {\r\n    let msg = `The value of \"${str}\" is out of range.`\r\n    let received = input\r\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\r\n      received = addNumericalSeparator(String(input))\r\n    } else if (typeof input === 'bigint') {\r\n      received = String(input)\r\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\r\n        received = addNumericalSeparator(received)\r\n      }\r\n      received += 'n'\r\n    }\r\n    msg += ` It must be ${range}. Received ${received}`\r\n    return msg\r\n  }, RangeError)\r\n\r\nfunction addNumericalSeparator (val) {\r\n  let res = ''\r\n  let i = val.length\r\n  const start = val[0] === '-' ? 1 : 0\r\n  for (; i >= start + 4; i -= 3) {\r\n    res = `_${val.slice(i - 3, i)}${res}`\r\n  }\r\n  return `${val.slice(0, i)}${res}`\r\n}\r\n\r\n// CHECK FUNCTIONS\r\n// ===============\r\n\r\nfunction checkBounds (buf, offset, byteLength) {\r\n  validateNumber(offset, 'offset')\r\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\r\n    boundsError(offset, buf.length - (byteLength + 1))\r\n  }\r\n}\r\n\r\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\r\n  if (value > max || value < min) {\r\n    const n = typeof min === 'bigint' ? 'n' : ''\r\n    let range\r\n    if (byteLength > 3) {\r\n      if (min === 0 || min === BigInt(0)) {\r\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\r\n      } else {\r\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\r\n                `${(byteLength + 1) * 8 - 1}${n}`\r\n      }\r\n    } else {\r\n      range = `>= ${min}${n} and <= ${max}${n}`\r\n    }\r\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\r\n  }\r\n  checkBounds(buf, offset, byteLength)\r\n}\r\n\r\nfunction validateNumber (value, name) {\r\n  if (typeof value !== 'number') {\r\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\r\n  }\r\n}\r\n\r\nfunction boundsError (value, length, type) {\r\n  if (Math.floor(value) !== value) {\r\n    validateNumber(value, type)\r\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\r\n  }\r\n\r\n  if (length < 0) {\r\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\r\n  }\r\n\r\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\r\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\r\n                                    value)\r\n}\r\n\r\n// HELPER FUNCTIONS\r\n// ================\r\n\r\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\r\n\r\nfunction base64clean (str) {\r\n  // Node takes equal signs as end of the Base64 encoding\r\n  str = str.split('=')[0]\r\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\r\n  str = str.trim().replace(INVALID_BASE64_RE, '')\r\n  // Node converts strings with length < 2 to ''\r\n  if (str.length < 2) return ''\r\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\r\n  while (str.length % 4 !== 0) {\r\n    str = str + '='\r\n  }\r\n  return str\r\n}\r\n\r\nfunction utf8ToBytes (string, units) {\r\n  units = units || Infinity\r\n  let codePoint\r\n  const length = string.length\r\n  let leadSurrogate = null\r\n  const bytes = []\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    codePoint = string.charCodeAt(i)\r\n\r\n    // is surrogate component\r\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\r\n      // last char was a lead\r\n      if (!leadSurrogate) {\r\n        // no lead yet\r\n        if (codePoint > 0xDBFF) {\r\n          // unexpected trail\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          continue\r\n        } else if (i + 1 === length) {\r\n          // unpaired lead\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          continue\r\n        }\r\n\r\n        // valid lead\r\n        leadSurrogate = codePoint\r\n\r\n        continue\r\n      }\r\n\r\n      // 2 leads in a row\r\n      if (codePoint < 0xDC00) {\r\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n        leadSurrogate = codePoint\r\n        continue\r\n      }\r\n\r\n      // valid surrogate pair\r\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\r\n    } else if (leadSurrogate) {\r\n      // valid bmp char, but last char was a lead\r\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n    }\r\n\r\n    leadSurrogate = null\r\n\r\n    // encode utf8\r\n    if (codePoint < 0x80) {\r\n      if ((units -= 1) < 0) break\r\n      bytes.push(codePoint)\r\n    } else if (codePoint < 0x800) {\r\n      if ((units -= 2) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0x6 | 0xC0,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else if (codePoint < 0x10000) {\r\n      if ((units -= 3) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0xC | 0xE0,\r\n        codePoint >> 0x6 & 0x3F | 0x80,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else if (codePoint < 0x110000) {\r\n      if ((units -= 4) < 0) break\r\n      bytes.push(\r\n        codePoint >> 0x12 | 0xF0,\r\n        codePoint >> 0xC & 0x3F | 0x80,\r\n        codePoint >> 0x6 & 0x3F | 0x80,\r\n        codePoint & 0x3F | 0x80\r\n      )\r\n    } else {\r\n      throw new Error('Invalid code point')\r\n    }\r\n  }\r\n\r\n  return bytes\r\n}\r\n\r\nfunction asciiToBytes (str) {\r\n  const byteArray = []\r\n  for (let i = 0; i < str.length; ++i) {\r\n    // Node's code seems to be doing this and not & 0x7F..\r\n    byteArray.push(str.charCodeAt(i) & 0xFF)\r\n  }\r\n  return byteArray\r\n}\r\n\r\nfunction utf16leToBytes (str, units) {\r\n  let c, hi, lo\r\n  const byteArray = []\r\n  for (let i = 0; i < str.length; ++i) {\r\n    if ((units -= 2) < 0) break\r\n\r\n    c = str.charCodeAt(i)\r\n    hi = c >> 8\r\n    lo = c % 256\r\n    byteArray.push(lo)\r\n    byteArray.push(hi)\r\n  }\r\n\r\n  return byteArray\r\n}\r\n\r\nfunction base64ToBytes (str) {\r\n  return base64.toByteArray(base64clean(str))\r\n}\r\n\r\nfunction blitBuffer (src, dst, offset, length) {\r\n  let i\r\n  for (i = 0; i < length; ++i) {\r\n    if ((i + offset >= dst.length) || (i >= src.length)) break\r\n    dst[i + offset] = src[i]\r\n  }\r\n  return i\r\n}\r\n\r\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\r\n// the `instanceof` check but they should be treated as of that type.\r\n// See: https://github.com/feross/buffer/issues/166\r\nfunction isInstance (obj, type) {\r\n  return obj instanceof type ||\r\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\r\n      obj.constructor.name === type.name)\r\n}\r\nfunction numberIsNaN (obj) {\r\n  // For IE11 support\r\n  return obj !== obj // eslint-disable-line no-self-compare\r\n}\r\n\r\n// Create lookup table for `toString('hex')`\r\n// See: https://github.com/feross/buffer/issues/219\r\nconst hexSliceLookupTable = (function () {\r\n  const alphabet = '0123456789abcdef'\r\n  const table = new Array(256)\r\n  for (let i = 0; i < 16; ++i) {\r\n    const i16 = i * 16\r\n    for (let j = 0; j < 16; ++j) {\r\n      table[i16 + j] = alphabet[i] + alphabet[j]\r\n    }\r\n  }\r\n  return table\r\n})()\r\n\r\n// Return not function with Error if BigInt not supported\r\nfunction defineBigIntMethod (fn) {\r\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\r\n}\r\n\r\nfunction BufferBigIntNotDefined () {\r\n  throw new Error('BigInt not supported')\r\n}\r\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$ieee754$index","~$shadow.js","~$module$node_modules$base64_js$index"]],"~:properties",["^5",["readUIntBE","message","foo","compare","writeInt8","kMaxLength","includes","readUint16BE","readDoubleBE","toLocaleString","readFloatLE","offset","readUInt8","copy","readUint32LE","swap32","byteLength","writeBigInt64LE","swap16","readInt8","readBigUInt64LE","readUint32BE","writeUint8","writeIntBE","writeBigUInt64LE","readInt16LE","allocUnsafeSlow","parent","poolSize","writeUint32BE","readUInt16LE","writeUIntBE","_isBuffer","inspect","writeInt32BE","readUintBE","toString","readUInt16BE","writeUInt32BE","readUint16LE","Buffer","SlowBuffer","writeUint16LE","writeBigUInt64BE","name","writeInt32LE","configurable","writeUInt16LE","writeUint32LE","value","readIntLE","writeInt16LE","lastIndexOf","allocUnsafe","enumerable","alloc","readUInt32LE","readUIntLE","writeFloatBE","writeUInt8","fill","writable","writeDoubleBE","writeInt16BE","readUInt32BE","concat","readDoubleLE","readBigInt64BE","writeUintLE","writeUint16BE","readInt16BE","type","writeUInt32LE","readUint8","readBigInt64LE","readBigUInt64BE","from","isEncoding","writeFloatLE","slice","isBuffer","writeBigInt64BE","writeDoubleLE","readIntBE","readInt32LE","indexOf","INSPECT_MAX_BYTES","readInt32BE","write","writeUintBE","writeUInt16BE","swap64","writeUIntLE","TYPED_ARRAY_SUPPORT","data","get","equals","code","readFloatBE","writeIntLE","readUintLE","toJSON"]],"~:compiled-at",1771869280884,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$buffer$index.js\",\n\"lineCount\":48,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/buffer/index.js\"],\n\"sourcesContent\":[\"shadow$provide[34] = function(require,module,exports) {\\n/*!\\r\\n * The buffer module from node.js, for the browser.\\r\\n *\\r\\n * @author   Feross Aboukhadijeh <https://feross.org>\\r\\n * @license  MIT\\r\\n */\\r\\n/* eslint-disable no-proto */\\r\\n\\r\\n'use strict'\\r\\n\\r\\nconst base64 = require('base64-js')\\r\\nconst ieee754 = require('ieee754')\\r\\nconst customInspectSymbol =\\r\\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\\r\\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\\r\\n    : null\\r\\n\\r\\nexports.Buffer = Buffer\\r\\nexports.SlowBuffer = SlowBuffer\\r\\nexports.INSPECT_MAX_BYTES = 50\\r\\n\\r\\nconst K_MAX_LENGTH = 0x7fffffff\\r\\nexports.kMaxLength = K_MAX_LENGTH\\r\\n\\r\\n/**\\r\\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\\r\\n *   === true    Use Uint8Array implementation (fastest)\\r\\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\\r\\n *               implementation (most compatible, even IE6)\\r\\n *\\r\\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\\r\\n * Opera 11.6+, iOS 4.2+.\\r\\n *\\r\\n * We report that the browser does not support typed arrays if the are not subclassable\\r\\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\\r\\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\\r\\n * for __proto__ and has a buggy typed array implementation.\\r\\n */\\r\\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\\r\\n\\r\\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\\r\\n    typeof console.error === 'function') {\\r\\n  console.error(\\r\\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\\r\\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction typedArraySupport () {\\r\\n  // Can typed array instances can be augmented?\\r\\n  try {\\r\\n    const arr = new Uint8Array(1)\\r\\n    const proto = { foo: function () { return 42 } }\\r\\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\\r\\n    Object.setPrototypeOf(arr, proto)\\r\\n    return arr.foo() === 42\\r\\n  } catch (e) {\\r\\n    return false\\r\\n  }\\r\\n}\\r\\n\\r\\nObject.defineProperty(Buffer.prototype, 'parent', {\\r\\n  enumerable: true,\\r\\n  get: function () {\\r\\n    if (!Buffer.isBuffer(this)) return undefined\\r\\n    return this.buffer\\r\\n  }\\r\\n})\\r\\n\\r\\nObject.defineProperty(Buffer.prototype, 'offset', {\\r\\n  enumerable: true,\\r\\n  get: function () {\\r\\n    if (!Buffer.isBuffer(this)) return undefined\\r\\n    return this.byteOffset\\r\\n  }\\r\\n})\\r\\n\\r\\nfunction createBuffer (length) {\\r\\n  if (length > K_MAX_LENGTH) {\\r\\n    throw new RangeError('The value \\\"' + length + '\\\" is invalid for option \\\"size\\\"')\\r\\n  }\\r\\n  // Return an augmented `Uint8Array` instance\\r\\n  const buf = new Uint8Array(length)\\r\\n  Object.setPrototypeOf(buf, Buffer.prototype)\\r\\n  return buf\\r\\n}\\r\\n\\r\\n/**\\r\\n * The Buffer constructor returns instances of `Uint8Array` that have their\\r\\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\\r\\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\\r\\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\\r\\n * returns a single octet.\\r\\n *\\r\\n * The `Uint8Array` prototype remains unmodified.\\r\\n */\\r\\n\\r\\nfunction Buffer (arg, encodingOrOffset, length) {\\r\\n  // Common case.\\r\\n  if (typeof arg === 'number') {\\r\\n    if (typeof encodingOrOffset === 'string') {\\r\\n      throw new TypeError(\\r\\n        'The \\\"string\\\" argument must be of type string. Received type number'\\r\\n      )\\r\\n    }\\r\\n    return allocUnsafe(arg)\\r\\n  }\\r\\n  return from(arg, encodingOrOffset, length)\\r\\n}\\r\\n\\r\\nBuffer.poolSize = 8192 // not used by this implementation\\r\\n\\r\\nfunction from (value, encodingOrOffset, length) {\\r\\n  if (typeof value === 'string') {\\r\\n    return fromString(value, encodingOrOffset)\\r\\n  }\\r\\n\\r\\n  if (ArrayBuffer.isView(value)) {\\r\\n    return fromArrayView(value)\\r\\n  }\\r\\n\\r\\n  if (value == null) {\\r\\n    throw new TypeError(\\r\\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\\r\\n      'or Array-like Object. Received type ' + (typeof value)\\r\\n    )\\r\\n  }\\r\\n\\r\\n  if (isInstance(value, ArrayBuffer) ||\\r\\n      (value && isInstance(value.buffer, ArrayBuffer))) {\\r\\n    return fromArrayBuffer(value, encodingOrOffset, length)\\r\\n  }\\r\\n\\r\\n  if (typeof SharedArrayBuffer !== 'undefined' &&\\r\\n      (isInstance(value, SharedArrayBuffer) ||\\r\\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\\r\\n    return fromArrayBuffer(value, encodingOrOffset, length)\\r\\n  }\\r\\n\\r\\n  if (typeof value === 'number') {\\r\\n    throw new TypeError(\\r\\n      'The \\\"value\\\" argument must not be of type number. Received type number'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const valueOf = value.valueOf && value.valueOf()\\r\\n  if (valueOf != null && valueOf !== value) {\\r\\n    return Buffer.from(valueOf, encodingOrOffset, length)\\r\\n  }\\r\\n\\r\\n  const b = fromObject(value)\\r\\n  if (b) return b\\r\\n\\r\\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\\r\\n      typeof value[Symbol.toPrimitive] === 'function') {\\r\\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\\r\\n  }\\r\\n\\r\\n  throw new TypeError(\\r\\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\\r\\n    'or Array-like Object. Received type ' + (typeof value)\\r\\n  )\\r\\n}\\r\\n\\r\\n/**\\r\\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\\r\\n * if value is a number.\\r\\n * Buffer.from(str[, encoding])\\r\\n * Buffer.from(array)\\r\\n * Buffer.from(buffer)\\r\\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\\r\\n **/\\r\\nBuffer.from = function (value, encodingOrOffset, length) {\\r\\n  return from(value, encodingOrOffset, length)\\r\\n}\\r\\n\\r\\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\\r\\n// https://github.com/feross/buffer/pull/148\\r\\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\\r\\nObject.setPrototypeOf(Buffer, Uint8Array)\\r\\n\\r\\nfunction assertSize (size) {\\r\\n  if (typeof size !== 'number') {\\r\\n    throw new TypeError('\\\"size\\\" argument must be of type number')\\r\\n  } else if (size < 0) {\\r\\n    throw new RangeError('The value \\\"' + size + '\\\" is invalid for option \\\"size\\\"')\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction alloc (size, fill, encoding) {\\r\\n  assertSize(size)\\r\\n  if (size <= 0) {\\r\\n    return createBuffer(size)\\r\\n  }\\r\\n  if (fill !== undefined) {\\r\\n    // Only pay attention to encoding if it's a string. This\\r\\n    // prevents accidentally sending in a number that would\\r\\n    // be interpreted as a start offset.\\r\\n    return typeof encoding === 'string'\\r\\n      ? createBuffer(size).fill(fill, encoding)\\r\\n      : createBuffer(size).fill(fill)\\r\\n  }\\r\\n  return createBuffer(size)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a new filled Buffer instance.\\r\\n * alloc(size[, fill[, encoding]])\\r\\n **/\\r\\nBuffer.alloc = function (size, fill, encoding) {\\r\\n  return alloc(size, fill, encoding)\\r\\n}\\r\\n\\r\\nfunction allocUnsafe (size) {\\r\\n  assertSize(size)\\r\\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\\r\\n}\\r\\n\\r\\n/**\\r\\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\\r\\n * */\\r\\nBuffer.allocUnsafe = function (size) {\\r\\n  return allocUnsafe(size)\\r\\n}\\r\\n/**\\r\\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\\r\\n */\\r\\nBuffer.allocUnsafeSlow = function (size) {\\r\\n  return allocUnsafe(size)\\r\\n}\\r\\n\\r\\nfunction fromString (string, encoding) {\\r\\n  if (typeof encoding !== 'string' || encoding === '') {\\r\\n    encoding = 'utf8'\\r\\n  }\\r\\n\\r\\n  if (!Buffer.isEncoding(encoding)) {\\r\\n    throw new TypeError('Unknown encoding: ' + encoding)\\r\\n  }\\r\\n\\r\\n  const length = byteLength(string, encoding) | 0\\r\\n  let buf = createBuffer(length)\\r\\n\\r\\n  const actual = buf.write(string, encoding)\\r\\n\\r\\n  if (actual !== length) {\\r\\n    // Writing a hex string, for example, that contains invalid characters will\\r\\n    // cause everything after the first invalid character to be ignored. (e.g.\\r\\n    // 'abxxcd' will be treated as 'ab')\\r\\n    buf = buf.slice(0, actual)\\r\\n  }\\r\\n\\r\\n  return buf\\r\\n}\\r\\n\\r\\nfunction fromArrayLike (array) {\\r\\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\\r\\n  const buf = createBuffer(length)\\r\\n  for (let i = 0; i < length; i += 1) {\\r\\n    buf[i] = array[i] & 255\\r\\n  }\\r\\n  return buf\\r\\n}\\r\\n\\r\\nfunction fromArrayView (arrayView) {\\r\\n  if (isInstance(arrayView, Uint8Array)) {\\r\\n    const copy = new Uint8Array(arrayView)\\r\\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\\r\\n  }\\r\\n  return fromArrayLike(arrayView)\\r\\n}\\r\\n\\r\\nfunction fromArrayBuffer (array, byteOffset, length) {\\r\\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\\r\\n    throw new RangeError('\\\"offset\\\" is outside of buffer bounds')\\r\\n  }\\r\\n\\r\\n  if (array.byteLength < byteOffset + (length || 0)) {\\r\\n    throw new RangeError('\\\"length\\\" is outside of buffer bounds')\\r\\n  }\\r\\n\\r\\n  let buf\\r\\n  if (byteOffset === undefined && length === undefined) {\\r\\n    buf = new Uint8Array(array)\\r\\n  } else if (length === undefined) {\\r\\n    buf = new Uint8Array(array, byteOffset)\\r\\n  } else {\\r\\n    buf = new Uint8Array(array, byteOffset, length)\\r\\n  }\\r\\n\\r\\n  // Return an augmented `Uint8Array` instance\\r\\n  Object.setPrototypeOf(buf, Buffer.prototype)\\r\\n\\r\\n  return buf\\r\\n}\\r\\n\\r\\nfunction fromObject (obj) {\\r\\n  if (Buffer.isBuffer(obj)) {\\r\\n    const len = checked(obj.length) | 0\\r\\n    const buf = createBuffer(len)\\r\\n\\r\\n    if (buf.length === 0) {\\r\\n      return buf\\r\\n    }\\r\\n\\r\\n    obj.copy(buf, 0, 0, len)\\r\\n    return buf\\r\\n  }\\r\\n\\r\\n  if (obj.length !== undefined) {\\r\\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\\r\\n      return createBuffer(0)\\r\\n    }\\r\\n    return fromArrayLike(obj)\\r\\n  }\\r\\n\\r\\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\\r\\n    return fromArrayLike(obj.data)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction checked (length) {\\r\\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\\r\\n  // length is NaN (which is otherwise coerced to zero.)\\r\\n  if (length >= K_MAX_LENGTH) {\\r\\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\\r\\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\\r\\n  }\\r\\n  return length | 0\\r\\n}\\r\\n\\r\\nfunction SlowBuffer (length) {\\r\\n  if (+length != length) { // eslint-disable-line eqeqeq\\r\\n    length = 0\\r\\n  }\\r\\n  return Buffer.alloc(+length)\\r\\n}\\r\\n\\r\\nBuffer.isBuffer = function isBuffer (b) {\\r\\n  return b != null && b._isBuffer === true &&\\r\\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\\r\\n}\\r\\n\\r\\nBuffer.compare = function compare (a, b) {\\r\\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\\r\\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\\r\\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\\r\\n    throw new TypeError(\\r\\n      'The \\\"buf1\\\", \\\"buf2\\\" arguments must be one of type Buffer or Uint8Array'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  if (a === b) return 0\\r\\n\\r\\n  let x = a.length\\r\\n  let y = b.length\\r\\n\\r\\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\\r\\n    if (a[i] !== b[i]) {\\r\\n      x = a[i]\\r\\n      y = b[i]\\r\\n      break\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (x < y) return -1\\r\\n  if (y < x) return 1\\r\\n  return 0\\r\\n}\\r\\n\\r\\nBuffer.isEncoding = function isEncoding (encoding) {\\r\\n  switch (String(encoding).toLowerCase()) {\\r\\n    case 'hex':\\r\\n    case 'utf8':\\r\\n    case 'utf-8':\\r\\n    case 'ascii':\\r\\n    case 'latin1':\\r\\n    case 'binary':\\r\\n    case 'base64':\\r\\n    case 'ucs2':\\r\\n    case 'ucs-2':\\r\\n    case 'utf16le':\\r\\n    case 'utf-16le':\\r\\n      return true\\r\\n    default:\\r\\n      return false\\r\\n  }\\r\\n}\\r\\n\\r\\nBuffer.concat = function concat (list, length) {\\r\\n  if (!Array.isArray(list)) {\\r\\n    throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\r\\n  }\\r\\n\\r\\n  if (list.length === 0) {\\r\\n    return Buffer.alloc(0)\\r\\n  }\\r\\n\\r\\n  let i\\r\\n  if (length === undefined) {\\r\\n    length = 0\\r\\n    for (i = 0; i < list.length; ++i) {\\r\\n      length += list[i].length\\r\\n    }\\r\\n  }\\r\\n\\r\\n  const buffer = Buffer.allocUnsafe(length)\\r\\n  let pos = 0\\r\\n  for (i = 0; i < list.length; ++i) {\\r\\n    let buf = list[i]\\r\\n    if (isInstance(buf, Uint8Array)) {\\r\\n      if (pos + buf.length > buffer.length) {\\r\\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\\r\\n        buf.copy(buffer, pos)\\r\\n      } else {\\r\\n        Uint8Array.prototype.set.call(\\r\\n          buffer,\\r\\n          buf,\\r\\n          pos\\r\\n        )\\r\\n      }\\r\\n    } else if (!Buffer.isBuffer(buf)) {\\r\\n      throw new TypeError('\\\"list\\\" argument must be an Array of Buffers')\\r\\n    } else {\\r\\n      buf.copy(buffer, pos)\\r\\n    }\\r\\n    pos += buf.length\\r\\n  }\\r\\n  return buffer\\r\\n}\\r\\n\\r\\nfunction byteLength (string, encoding) {\\r\\n  if (Buffer.isBuffer(string)) {\\r\\n    return string.length\\r\\n  }\\r\\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\\r\\n    return string.byteLength\\r\\n  }\\r\\n  if (typeof string !== 'string') {\\r\\n    throw new TypeError(\\r\\n      'The \\\"string\\\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\\r\\n      'Received type ' + typeof string\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const len = string.length\\r\\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\\r\\n  if (!mustMatch && len === 0) return 0\\r\\n\\r\\n  // Use a for loop to avoid recursion\\r\\n  let loweredCase = false\\r\\n  for (;;) {\\r\\n    switch (encoding) {\\r\\n      case 'ascii':\\r\\n      case 'latin1':\\r\\n      case 'binary':\\r\\n        return len\\r\\n      case 'utf8':\\r\\n      case 'utf-8':\\r\\n        return utf8ToBytes(string).length\\r\\n      case 'ucs2':\\r\\n      case 'ucs-2':\\r\\n      case 'utf16le':\\r\\n      case 'utf-16le':\\r\\n        return len * 2\\r\\n      case 'hex':\\r\\n        return len >>> 1\\r\\n      case 'base64':\\r\\n        return base64ToBytes(string).length\\r\\n      default:\\r\\n        if (loweredCase) {\\r\\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\\r\\n        }\\r\\n        encoding = ('' + encoding).toLowerCase()\\r\\n        loweredCase = true\\r\\n    }\\r\\n  }\\r\\n}\\r\\nBuffer.byteLength = byteLength\\r\\n\\r\\nfunction slowToString (encoding, start, end) {\\r\\n  let loweredCase = false\\r\\n\\r\\n  // No need to verify that \\\"this.length <= MAX_UINT32\\\" since it's a read-only\\r\\n  // property of a typed array.\\r\\n\\r\\n  // This behaves neither like String nor Uint8Array in that we set start/end\\r\\n  // to their upper/lower bounds if the value passed is out of range.\\r\\n  // undefined is handled specially as per ECMA-262 6th Edition,\\r\\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\\r\\n  if (start === undefined || start < 0) {\\r\\n    start = 0\\r\\n  }\\r\\n  // Return early if start > this.length. Done here to prevent potential uint32\\r\\n  // coercion fail below.\\r\\n  if (start > this.length) {\\r\\n    return ''\\r\\n  }\\r\\n\\r\\n  if (end === undefined || end > this.length) {\\r\\n    end = this.length\\r\\n  }\\r\\n\\r\\n  if (end <= 0) {\\r\\n    return ''\\r\\n  }\\r\\n\\r\\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\\r\\n  end >>>= 0\\r\\n  start >>>= 0\\r\\n\\r\\n  if (end <= start) {\\r\\n    return ''\\r\\n  }\\r\\n\\r\\n  if (!encoding) encoding = 'utf8'\\r\\n\\r\\n  while (true) {\\r\\n    switch (encoding) {\\r\\n      case 'hex':\\r\\n        return hexSlice(this, start, end)\\r\\n\\r\\n      case 'utf8':\\r\\n      case 'utf-8':\\r\\n        return utf8Slice(this, start, end)\\r\\n\\r\\n      case 'ascii':\\r\\n        return asciiSlice(this, start, end)\\r\\n\\r\\n      case 'latin1':\\r\\n      case 'binary':\\r\\n        return latin1Slice(this, start, end)\\r\\n\\r\\n      case 'base64':\\r\\n        return base64Slice(this, start, end)\\r\\n\\r\\n      case 'ucs2':\\r\\n      case 'ucs-2':\\r\\n      case 'utf16le':\\r\\n      case 'utf-16le':\\r\\n        return utf16leSlice(this, start, end)\\r\\n\\r\\n      default:\\r\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\r\\n        encoding = (encoding + '').toLowerCase()\\r\\n        loweredCase = true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\\r\\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\\r\\n// reliably in a browserify context because there could be multiple different\\r\\n// copies of the 'buffer' package in use. This method works even for Buffer\\r\\n// instances that were created from another copy of the `buffer` package.\\r\\n// See: https://github.com/feross/buffer/issues/154\\r\\nBuffer.prototype._isBuffer = true\\r\\n\\r\\nfunction swap (b, n, m) {\\r\\n  const i = b[n]\\r\\n  b[n] = b[m]\\r\\n  b[m] = i\\r\\n}\\r\\n\\r\\nBuffer.prototype.swap16 = function swap16 () {\\r\\n  const len = this.length\\r\\n  if (len % 2 !== 0) {\\r\\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\\r\\n  }\\r\\n  for (let i = 0; i < len; i += 2) {\\r\\n    swap(this, i, i + 1)\\r\\n  }\\r\\n  return this\\r\\n}\\r\\n\\r\\nBuffer.prototype.swap32 = function swap32 () {\\r\\n  const len = this.length\\r\\n  if (len % 4 !== 0) {\\r\\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\\r\\n  }\\r\\n  for (let i = 0; i < len; i += 4) {\\r\\n    swap(this, i, i + 3)\\r\\n    swap(this, i + 1, i + 2)\\r\\n  }\\r\\n  return this\\r\\n}\\r\\n\\r\\nBuffer.prototype.swap64 = function swap64 () {\\r\\n  const len = this.length\\r\\n  if (len % 8 !== 0) {\\r\\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\\r\\n  }\\r\\n  for (let i = 0; i < len; i += 8) {\\r\\n    swap(this, i, i + 7)\\r\\n    swap(this, i + 1, i + 6)\\r\\n    swap(this, i + 2, i + 5)\\r\\n    swap(this, i + 3, i + 4)\\r\\n  }\\r\\n  return this\\r\\n}\\r\\n\\r\\nBuffer.prototype.toString = function toString () {\\r\\n  const length = this.length\\r\\n  if (length === 0) return ''\\r\\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\\r\\n  return slowToString.apply(this, arguments)\\r\\n}\\r\\n\\r\\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\\r\\n\\r\\nBuffer.prototype.equals = function equals (b) {\\r\\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\\r\\n  if (this === b) return true\\r\\n  return Buffer.compare(this, b) === 0\\r\\n}\\r\\n\\r\\nBuffer.prototype.inspect = function inspect () {\\r\\n  let str = ''\\r\\n  const max = exports.INSPECT_MAX_BYTES\\r\\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\\r\\n  if (this.length > max) str += ' ... '\\r\\n  return '<Buffer ' + str + '>'\\r\\n}\\r\\nif (customInspectSymbol) {\\r\\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\\r\\n}\\r\\n\\r\\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\\r\\n  if (isInstance(target, Uint8Array)) {\\r\\n    target = Buffer.from(target, target.offset, target.byteLength)\\r\\n  }\\r\\n  if (!Buffer.isBuffer(target)) {\\r\\n    throw new TypeError(\\r\\n      'The \\\"target\\\" argument must be one of type Buffer or Uint8Array. ' +\\r\\n      'Received type ' + (typeof target)\\r\\n    )\\r\\n  }\\r\\n\\r\\n  if (start === undefined) {\\r\\n    start = 0\\r\\n  }\\r\\n  if (end === undefined) {\\r\\n    end = target ? target.length : 0\\r\\n  }\\r\\n  if (thisStart === undefined) {\\r\\n    thisStart = 0\\r\\n  }\\r\\n  if (thisEnd === undefined) {\\r\\n    thisEnd = this.length\\r\\n  }\\r\\n\\r\\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\\r\\n    throw new RangeError('out of range index')\\r\\n  }\\r\\n\\r\\n  if (thisStart >= thisEnd && start >= end) {\\r\\n    return 0\\r\\n  }\\r\\n  if (thisStart >= thisEnd) {\\r\\n    return -1\\r\\n  }\\r\\n  if (start >= end) {\\r\\n    return 1\\r\\n  }\\r\\n\\r\\n  start >>>= 0\\r\\n  end >>>= 0\\r\\n  thisStart >>>= 0\\r\\n  thisEnd >>>= 0\\r\\n\\r\\n  if (this === target) return 0\\r\\n\\r\\n  let x = thisEnd - thisStart\\r\\n  let y = end - start\\r\\n  const len = Math.min(x, y)\\r\\n\\r\\n  const thisCopy = this.slice(thisStart, thisEnd)\\r\\n  const targetCopy = target.slice(start, end)\\r\\n\\r\\n  for (let i = 0; i < len; ++i) {\\r\\n    if (thisCopy[i] !== targetCopy[i]) {\\r\\n      x = thisCopy[i]\\r\\n      y = targetCopy[i]\\r\\n      break\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (x < y) return -1\\r\\n  if (y < x) return 1\\r\\n  return 0\\r\\n}\\r\\n\\r\\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\\r\\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\\r\\n//\\r\\n// Arguments:\\r\\n// - buffer - a Buffer to search\\r\\n// - val - a string, Buffer, or number\\r\\n// - byteOffset - an index into `buffer`; will be clamped to an int32\\r\\n// - encoding - an optional encoding, relevant is val is a string\\r\\n// - dir - true for indexOf, false for lastIndexOf\\r\\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\\r\\n  // Empty buffer means no match\\r\\n  if (buffer.length === 0) return -1\\r\\n\\r\\n  // Normalize byteOffset\\r\\n  if (typeof byteOffset === 'string') {\\r\\n    encoding = byteOffset\\r\\n    byteOffset = 0\\r\\n  } else if (byteOffset > 0x7fffffff) {\\r\\n    byteOffset = 0x7fffffff\\r\\n  } else if (byteOffset < -0x80000000) {\\r\\n    byteOffset = -0x80000000\\r\\n  }\\r\\n  byteOffset = +byteOffset // Coerce to Number.\\r\\n  if (numberIsNaN(byteOffset)) {\\r\\n    // byteOffset: it it's undefined, null, NaN, \\\"foo\\\", etc, search whole buffer\\r\\n    byteOffset = dir ? 0 : (buffer.length - 1)\\r\\n  }\\r\\n\\r\\n  // Normalize byteOffset: negative offsets start from the end of the buffer\\r\\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\\r\\n  if (byteOffset >= buffer.length) {\\r\\n    if (dir) return -1\\r\\n    else byteOffset = buffer.length - 1\\r\\n  } else if (byteOffset < 0) {\\r\\n    if (dir) byteOffset = 0\\r\\n    else return -1\\r\\n  }\\r\\n\\r\\n  // Normalize val\\r\\n  if (typeof val === 'string') {\\r\\n    val = Buffer.from(val, encoding)\\r\\n  }\\r\\n\\r\\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\\r\\n  if (Buffer.isBuffer(val)) {\\r\\n    // Special case: looking for empty string/buffer always fails\\r\\n    if (val.length === 0) {\\r\\n      return -1\\r\\n    }\\r\\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\\r\\n  } else if (typeof val === 'number') {\\r\\n    val = val & 0xFF // Search for a byte value [0-255]\\r\\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\\r\\n      if (dir) {\\r\\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\\r\\n      } else {\\r\\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\\r\\n      }\\r\\n    }\\r\\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\\r\\n  }\\r\\n\\r\\n  throw new TypeError('val must be string, number or Buffer')\\r\\n}\\r\\n\\r\\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\\r\\n  let indexSize = 1\\r\\n  let arrLength = arr.length\\r\\n  let valLength = val.length\\r\\n\\r\\n  if (encoding !== undefined) {\\r\\n    encoding = String(encoding).toLowerCase()\\r\\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\\r\\n        encoding === 'utf16le' || encoding === 'utf-16le') {\\r\\n      if (arr.length < 2 || val.length < 2) {\\r\\n        return -1\\r\\n      }\\r\\n      indexSize = 2\\r\\n      arrLength /= 2\\r\\n      valLength /= 2\\r\\n      byteOffset /= 2\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function read (buf, i) {\\r\\n    if (indexSize === 1) {\\r\\n      return buf[i]\\r\\n    } else {\\r\\n      return buf.readUInt16BE(i * indexSize)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  let i\\r\\n  if (dir) {\\r\\n    let foundIndex = -1\\r\\n    for (i = byteOffset; i < arrLength; i++) {\\r\\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\\r\\n        if (foundIndex === -1) foundIndex = i\\r\\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\\r\\n      } else {\\r\\n        if (foundIndex !== -1) i -= i - foundIndex\\r\\n        foundIndex = -1\\r\\n      }\\r\\n    }\\r\\n  } else {\\r\\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\\r\\n    for (i = byteOffset; i >= 0; i--) {\\r\\n      let found = true\\r\\n      for (let j = 0; j < valLength; j++) {\\r\\n        if (read(arr, i + j) !== read(val, j)) {\\r\\n          found = false\\r\\n          break\\r\\n        }\\r\\n      }\\r\\n      if (found) return i\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return -1\\r\\n}\\r\\n\\r\\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\\r\\n  return this.indexOf(val, byteOffset, encoding) !== -1\\r\\n}\\r\\n\\r\\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\\r\\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\\r\\n}\\r\\n\\r\\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\\r\\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\\r\\n}\\r\\n\\r\\nfunction hexWrite (buf, string, offset, length) {\\r\\n  offset = Number(offset) || 0\\r\\n  const remaining = buf.length - offset\\r\\n  if (!length) {\\r\\n    length = remaining\\r\\n  } else {\\r\\n    length = Number(length)\\r\\n    if (length > remaining) {\\r\\n      length = remaining\\r\\n    }\\r\\n  }\\r\\n\\r\\n  const strLen = string.length\\r\\n\\r\\n  if (length > strLen / 2) {\\r\\n    length = strLen / 2\\r\\n  }\\r\\n  let i\\r\\n  for (i = 0; i < length; ++i) {\\r\\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\\r\\n    if (numberIsNaN(parsed)) return i\\r\\n    buf[offset + i] = parsed\\r\\n  }\\r\\n  return i\\r\\n}\\r\\n\\r\\nfunction utf8Write (buf, string, offset, length) {\\r\\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\\r\\n}\\r\\n\\r\\nfunction asciiWrite (buf, string, offset, length) {\\r\\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\\r\\n}\\r\\n\\r\\nfunction base64Write (buf, string, offset, length) {\\r\\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\\r\\n}\\r\\n\\r\\nfunction ucs2Write (buf, string, offset, length) {\\r\\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\\r\\n}\\r\\n\\r\\nBuffer.prototype.write = function write (string, offset, length, encoding) {\\r\\n  // Buffer#write(string)\\r\\n  if (offset === undefined) {\\r\\n    encoding = 'utf8'\\r\\n    length = this.length\\r\\n    offset = 0\\r\\n  // Buffer#write(string, encoding)\\r\\n  } else if (length === undefined && typeof offset === 'string') {\\r\\n    encoding = offset\\r\\n    length = this.length\\r\\n    offset = 0\\r\\n  // Buffer#write(string, offset[, length][, encoding])\\r\\n  } else if (isFinite(offset)) {\\r\\n    offset = offset >>> 0\\r\\n    if (isFinite(length)) {\\r\\n      length = length >>> 0\\r\\n      if (encoding === undefined) encoding = 'utf8'\\r\\n    } else {\\r\\n      encoding = length\\r\\n      length = undefined\\r\\n    }\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const remaining = this.length - offset\\r\\n  if (length === undefined || length > remaining) length = remaining\\r\\n\\r\\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\\r\\n    throw new RangeError('Attempt to write outside buffer bounds')\\r\\n  }\\r\\n\\r\\n  if (!encoding) encoding = 'utf8'\\r\\n\\r\\n  let loweredCase = false\\r\\n  for (;;) {\\r\\n    switch (encoding) {\\r\\n      case 'hex':\\r\\n        return hexWrite(this, string, offset, length)\\r\\n\\r\\n      case 'utf8':\\r\\n      case 'utf-8':\\r\\n        return utf8Write(this, string, offset, length)\\r\\n\\r\\n      case 'ascii':\\r\\n      case 'latin1':\\r\\n      case 'binary':\\r\\n        return asciiWrite(this, string, offset, length)\\r\\n\\r\\n      case 'base64':\\r\\n        // Warning: maxLength not taken into account in base64Write\\r\\n        return base64Write(this, string, offset, length)\\r\\n\\r\\n      case 'ucs2':\\r\\n      case 'ucs-2':\\r\\n      case 'utf16le':\\r\\n      case 'utf-16le':\\r\\n        return ucs2Write(this, string, offset, length)\\r\\n\\r\\n      default:\\r\\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\\r\\n        encoding = ('' + encoding).toLowerCase()\\r\\n        loweredCase = true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nBuffer.prototype.toJSON = function toJSON () {\\r\\n  return {\\r\\n    type: 'Buffer',\\r\\n    data: Array.prototype.slice.call(this._arr || this, 0)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction base64Slice (buf, start, end) {\\r\\n  if (start === 0 && end === buf.length) {\\r\\n    return base64.fromByteArray(buf)\\r\\n  } else {\\r\\n    return base64.fromByteArray(buf.slice(start, end))\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction utf8Slice (buf, start, end) {\\r\\n  end = Math.min(buf.length, end)\\r\\n  const res = []\\r\\n\\r\\n  let i = start\\r\\n  while (i < end) {\\r\\n    const firstByte = buf[i]\\r\\n    let codePoint = null\\r\\n    let bytesPerSequence = (firstByte > 0xEF)\\r\\n      ? 4\\r\\n      : (firstByte > 0xDF)\\r\\n          ? 3\\r\\n          : (firstByte > 0xBF)\\r\\n              ? 2\\r\\n              : 1\\r\\n\\r\\n    if (i + bytesPerSequence <= end) {\\r\\n      let secondByte, thirdByte, fourthByte, tempCodePoint\\r\\n\\r\\n      switch (bytesPerSequence) {\\r\\n        case 1:\\r\\n          if (firstByte < 0x80) {\\r\\n            codePoint = firstByte\\r\\n          }\\r\\n          break\\r\\n        case 2:\\r\\n          secondByte = buf[i + 1]\\r\\n          if ((secondByte & 0xC0) === 0x80) {\\r\\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\\r\\n            if (tempCodePoint > 0x7F) {\\r\\n              codePoint = tempCodePoint\\r\\n            }\\r\\n          }\\r\\n          break\\r\\n        case 3:\\r\\n          secondByte = buf[i + 1]\\r\\n          thirdByte = buf[i + 2]\\r\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\\r\\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\\r\\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\\r\\n              codePoint = tempCodePoint\\r\\n            }\\r\\n          }\\r\\n          break\\r\\n        case 4:\\r\\n          secondByte = buf[i + 1]\\r\\n          thirdByte = buf[i + 2]\\r\\n          fourthByte = buf[i + 3]\\r\\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\\r\\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\\r\\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\\r\\n              codePoint = tempCodePoint\\r\\n            }\\r\\n          }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (codePoint === null) {\\r\\n      // we did not generate a valid codePoint so insert a\\r\\n      // replacement char (U+FFFD) and advance only 1 byte\\r\\n      codePoint = 0xFFFD\\r\\n      bytesPerSequence = 1\\r\\n    } else if (codePoint > 0xFFFF) {\\r\\n      // encode to utf16 (surrogate pair dance)\\r\\n      codePoint -= 0x10000\\r\\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\\r\\n      codePoint = 0xDC00 | codePoint & 0x3FF\\r\\n    }\\r\\n\\r\\n    res.push(codePoint)\\r\\n    i += bytesPerSequence\\r\\n  }\\r\\n\\r\\n  return decodeCodePointsArray(res)\\r\\n}\\r\\n\\r\\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\\r\\n// the lowest limit is Chrome, with 0x10000 args.\\r\\n// We go 1 magnitude less, for safety\\r\\nconst MAX_ARGUMENTS_LENGTH = 0x1000\\r\\n\\r\\nfunction decodeCodePointsArray (codePoints) {\\r\\n  const len = codePoints.length\\r\\n  if (len <= MAX_ARGUMENTS_LENGTH) {\\r\\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\\r\\n  }\\r\\n\\r\\n  // Decode in chunks to avoid \\\"call stack size exceeded\\\".\\r\\n  let res = ''\\r\\n  let i = 0\\r\\n  while (i < len) {\\r\\n    res += String.fromCharCode.apply(\\r\\n      String,\\r\\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\\r\\n    )\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nfunction asciiSlice (buf, start, end) {\\r\\n  let ret = ''\\r\\n  end = Math.min(buf.length, end)\\r\\n\\r\\n  for (let i = start; i < end; ++i) {\\r\\n    ret += String.fromCharCode(buf[i] & 0x7F)\\r\\n  }\\r\\n  return ret\\r\\n}\\r\\n\\r\\nfunction latin1Slice (buf, start, end) {\\r\\n  let ret = ''\\r\\n  end = Math.min(buf.length, end)\\r\\n\\r\\n  for (let i = start; i < end; ++i) {\\r\\n    ret += String.fromCharCode(buf[i])\\r\\n  }\\r\\n  return ret\\r\\n}\\r\\n\\r\\nfunction hexSlice (buf, start, end) {\\r\\n  const len = buf.length\\r\\n\\r\\n  if (!start || start < 0) start = 0\\r\\n  if (!end || end < 0 || end > len) end = len\\r\\n\\r\\n  let out = ''\\r\\n  for (let i = start; i < end; ++i) {\\r\\n    out += hexSliceLookupTable[buf[i]]\\r\\n  }\\r\\n  return out\\r\\n}\\r\\n\\r\\nfunction utf16leSlice (buf, start, end) {\\r\\n  const bytes = buf.slice(start, end)\\r\\n  let res = ''\\r\\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\\r\\n  for (let i = 0; i < bytes.length - 1; i += 2) {\\r\\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\\r\\n  }\\r\\n  return res\\r\\n}\\r\\n\\r\\nBuffer.prototype.slice = function slice (start, end) {\\r\\n  const len = this.length\\r\\n  start = ~~start\\r\\n  end = end === undefined ? len : ~~end\\r\\n\\r\\n  if (start < 0) {\\r\\n    start += len\\r\\n    if (start < 0) start = 0\\r\\n  } else if (start > len) {\\r\\n    start = len\\r\\n  }\\r\\n\\r\\n  if (end < 0) {\\r\\n    end += len\\r\\n    if (end < 0) end = 0\\r\\n  } else if (end > len) {\\r\\n    end = len\\r\\n  }\\r\\n\\r\\n  if (end < start) end = start\\r\\n\\r\\n  const newBuf = this.subarray(start, end)\\r\\n  // Return an augmented `Uint8Array` instance\\r\\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\\r\\n\\r\\n  return newBuf\\r\\n}\\r\\n\\r\\n/*\\r\\n * Need to make sure that buffer isn't trying to write out of bounds.\\r\\n */\\r\\nfunction checkOffset (offset, ext, length) {\\r\\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\\r\\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUintLE =\\r\\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\r\\n\\r\\n  let val = this[offset]\\r\\n  let mul = 1\\r\\n  let i = 0\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    val += this[offset + i] * mul\\r\\n  }\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUintBE =\\r\\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) {\\r\\n    checkOffset(offset, byteLength, this.length)\\r\\n  }\\r\\n\\r\\n  let val = this[offset + --byteLength]\\r\\n  let mul = 1\\r\\n  while (byteLength > 0 && (mul *= 0x100)) {\\r\\n    val += this[offset + --byteLength] * mul\\r\\n  }\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUint8 =\\r\\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\r\\n  return this[offset]\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUint16LE =\\r\\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  return this[offset] | (this[offset + 1] << 8)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUint16BE =\\r\\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  return (this[offset] << 8) | this[offset + 1]\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUint32LE =\\r\\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return ((this[offset]) |\\r\\n      (this[offset + 1] << 8) |\\r\\n      (this[offset + 2] << 16)) +\\r\\n      (this[offset + 3] * 0x1000000)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readUint32BE =\\r\\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return (this[offset] * 0x1000000) +\\r\\n    ((this[offset + 1] << 16) |\\r\\n    (this[offset + 2] << 8) |\\r\\n    this[offset + 3])\\r\\n}\\r\\n\\r\\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\\r\\n  offset = offset >>> 0\\r\\n  validateNumber(offset, 'offset')\\r\\n  const first = this[offset]\\r\\n  const last = this[offset + 7]\\r\\n  if (first === undefined || last === undefined) {\\r\\n    boundsError(offset, this.length - 8)\\r\\n  }\\r\\n\\r\\n  const lo = first +\\r\\n    this[++offset] * 2 ** 8 +\\r\\n    this[++offset] * 2 ** 16 +\\r\\n    this[++offset] * 2 ** 24\\r\\n\\r\\n  const hi = this[++offset] +\\r\\n    this[++offset] * 2 ** 8 +\\r\\n    this[++offset] * 2 ** 16 +\\r\\n    last * 2 ** 24\\r\\n\\r\\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\\r\\n})\\r\\n\\r\\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\\r\\n  offset = offset >>> 0\\r\\n  validateNumber(offset, 'offset')\\r\\n  const first = this[offset]\\r\\n  const last = this[offset + 7]\\r\\n  if (first === undefined || last === undefined) {\\r\\n    boundsError(offset, this.length - 8)\\r\\n  }\\r\\n\\r\\n  const hi = first * 2 ** 24 +\\r\\n    this[++offset] * 2 ** 16 +\\r\\n    this[++offset] * 2 ** 8 +\\r\\n    this[++offset]\\r\\n\\r\\n  const lo = this[++offset] * 2 ** 24 +\\r\\n    this[++offset] * 2 ** 16 +\\r\\n    this[++offset] * 2 ** 8 +\\r\\n    last\\r\\n\\r\\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\\r\\n})\\r\\n\\r\\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\r\\n\\r\\n  let val = this[offset]\\r\\n  let mul = 1\\r\\n  let i = 0\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    val += this[offset + i] * mul\\r\\n  }\\r\\n  mul *= 0x80\\r\\n\\r\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\\r\\n\\r\\n  let i = byteLength\\r\\n  let mul = 1\\r\\n  let val = this[offset + --i]\\r\\n  while (i > 0 && (mul *= 0x100)) {\\r\\n    val += this[offset + --i] * mul\\r\\n  }\\r\\n  mul *= 0x80\\r\\n\\r\\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\\r\\n\\r\\n  return val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 1, this.length)\\r\\n  if (!(this[offset] & 0x80)) return (this[offset])\\r\\n  return ((0xff - this[offset] + 1) * -1)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  const val = this[offset] | (this[offset + 1] << 8)\\r\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 2, this.length)\\r\\n  const val = this[offset + 1] | (this[offset] << 8)\\r\\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return (this[offset]) |\\r\\n    (this[offset + 1] << 8) |\\r\\n    (this[offset + 2] << 16) |\\r\\n    (this[offset + 3] << 24)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n\\r\\n  return (this[offset] << 24) |\\r\\n    (this[offset + 1] << 16) |\\r\\n    (this[offset + 2] << 8) |\\r\\n    (this[offset + 3])\\r\\n}\\r\\n\\r\\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\\r\\n  offset = offset >>> 0\\r\\n  validateNumber(offset, 'offset')\\r\\n  const first = this[offset]\\r\\n  const last = this[offset + 7]\\r\\n  if (first === undefined || last === undefined) {\\r\\n    boundsError(offset, this.length - 8)\\r\\n  }\\r\\n\\r\\n  const val = this[offset + 4] +\\r\\n    this[offset + 5] * 2 ** 8 +\\r\\n    this[offset + 6] * 2 ** 16 +\\r\\n    (last << 24) // Overflow\\r\\n\\r\\n  return (BigInt(val) << BigInt(32)) +\\r\\n    BigInt(first +\\r\\n    this[++offset] * 2 ** 8 +\\r\\n    this[++offset] * 2 ** 16 +\\r\\n    this[++offset] * 2 ** 24)\\r\\n})\\r\\n\\r\\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\\r\\n  offset = offset >>> 0\\r\\n  validateNumber(offset, 'offset')\\r\\n  const first = this[offset]\\r\\n  const last = this[offset + 7]\\r\\n  if (first === undefined || last === undefined) {\\r\\n    boundsError(offset, this.length - 8)\\r\\n  }\\r\\n\\r\\n  const val = (first << 24) + // Overflow\\r\\n    this[++offset] * 2 ** 16 +\\r\\n    this[++offset] * 2 ** 8 +\\r\\n    this[++offset]\\r\\n\\r\\n  return (BigInt(val) << BigInt(32)) +\\r\\n    BigInt(this[++offset] * 2 ** 24 +\\r\\n    this[++offset] * 2 ** 16 +\\r\\n    this[++offset] * 2 ** 8 +\\r\\n    last)\\r\\n})\\r\\n\\r\\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n  return ieee754.read(this, offset, true, 23, 4)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 4, this.length)\\r\\n  return ieee754.read(this, offset, false, 23, 4)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\r\\n  return ieee754.read(this, offset, true, 52, 8)\\r\\n}\\r\\n\\r\\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkOffset(offset, 8, this.length)\\r\\n  return ieee754.read(this, offset, false, 52, 8)\\r\\n}\\r\\n\\r\\nfunction checkInt (buf, value, offset, ext, max, min) {\\r\\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\\\"buffer\\\" argument must be a Buffer instance')\\r\\n  if (value > max || value < min) throw new RangeError('\\\"value\\\" argument is out of bounds')\\r\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUintLE =\\r\\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) {\\r\\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\\r\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\r\\n  }\\r\\n\\r\\n  let mul = 1\\r\\n  let i = 0\\r\\n  this[offset] = value & 0xFF\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    this[offset + i] = (value / mul) & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUintBE =\\r\\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  byteLength = byteLength >>> 0\\r\\n  if (!noAssert) {\\r\\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\\r\\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\\r\\n  }\\r\\n\\r\\n  let i = byteLength - 1\\r\\n  let mul = 1\\r\\n  this[offset + i] = value & 0xFF\\r\\n  while (--i >= 0 && (mul *= 0x100)) {\\r\\n    this[offset + i] = (value / mul) & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUint8 =\\r\\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\\r\\n  this[offset] = (value & 0xff)\\r\\n  return offset + 1\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUint16LE =\\r\\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\r\\n  this[offset] = (value & 0xff)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUint16BE =\\r\\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\\r\\n  this[offset] = (value >>> 8)\\r\\n  this[offset + 1] = (value & 0xff)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUint32LE =\\r\\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\r\\n  this[offset + 3] = (value >>> 24)\\r\\n  this[offset + 2] = (value >>> 16)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  this[offset] = (value & 0xff)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUint32BE =\\r\\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\\r\\n  this[offset] = (value >>> 24)\\r\\n  this[offset + 1] = (value >>> 16)\\r\\n  this[offset + 2] = (value >>> 8)\\r\\n  this[offset + 3] = (value & 0xff)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\\r\\n  checkIntBI(value, min, max, buf, offset, 7)\\r\\n\\r\\n  let lo = Number(value & BigInt(0xffffffff))\\r\\n  buf[offset++] = lo\\r\\n  lo = lo >> 8\\r\\n  buf[offset++] = lo\\r\\n  lo = lo >> 8\\r\\n  buf[offset++] = lo\\r\\n  lo = lo >> 8\\r\\n  buf[offset++] = lo\\r\\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\\r\\n  buf[offset++] = hi\\r\\n  hi = hi >> 8\\r\\n  buf[offset++] = hi\\r\\n  hi = hi >> 8\\r\\n  buf[offset++] = hi\\r\\n  hi = hi >> 8\\r\\n  buf[offset++] = hi\\r\\n  return offset\\r\\n}\\r\\n\\r\\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\\r\\n  checkIntBI(value, min, max, buf, offset, 7)\\r\\n\\r\\n  let lo = Number(value & BigInt(0xffffffff))\\r\\n  buf[offset + 7] = lo\\r\\n  lo = lo >> 8\\r\\n  buf[offset + 6] = lo\\r\\n  lo = lo >> 8\\r\\n  buf[offset + 5] = lo\\r\\n  lo = lo >> 8\\r\\n  buf[offset + 4] = lo\\r\\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\\r\\n  buf[offset + 3] = hi\\r\\n  hi = hi >> 8\\r\\n  buf[offset + 2] = hi\\r\\n  hi = hi >> 8\\r\\n  buf[offset + 1] = hi\\r\\n  hi = hi >> 8\\r\\n  buf[offset] = hi\\r\\n  return offset + 8\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\\r\\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\\r\\n})\\r\\n\\r\\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\\r\\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\\r\\n})\\r\\n\\r\\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    const limit = Math.pow(2, (8 * byteLength) - 1)\\r\\n\\r\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\r\\n  }\\r\\n\\r\\n  let i = 0\\r\\n  let mul = 1\\r\\n  let sub = 0\\r\\n  this[offset] = value & 0xFF\\r\\n  while (++i < byteLength && (mul *= 0x100)) {\\r\\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\\r\\n      sub = 1\\r\\n    }\\r\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    const limit = Math.pow(2, (8 * byteLength) - 1)\\r\\n\\r\\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\\r\\n  }\\r\\n\\r\\n  let i = byteLength - 1\\r\\n  let mul = 1\\r\\n  let sub = 0\\r\\n  this[offset + i] = value & 0xFF\\r\\n  while (--i >= 0 && (mul *= 0x100)) {\\r\\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\\r\\n      sub = 1\\r\\n    }\\r\\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\\r\\n  }\\r\\n\\r\\n  return offset + byteLength\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\\r\\n  if (value < 0) value = 0xff + value + 1\\r\\n  this[offset] = (value & 0xff)\\r\\n  return offset + 1\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\r\\n  this[offset] = (value & 0xff)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\\r\\n  this[offset] = (value >>> 8)\\r\\n  this[offset + 1] = (value & 0xff)\\r\\n  return offset + 2\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\r\\n  this[offset] = (value & 0xff)\\r\\n  this[offset + 1] = (value >>> 8)\\r\\n  this[offset + 2] = (value >>> 16)\\r\\n  this[offset + 3] = (value >>> 24)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\\r\\n  if (value < 0) value = 0xffffffff + value + 1\\r\\n  this[offset] = (value >>> 24)\\r\\n  this[offset + 1] = (value >>> 16)\\r\\n  this[offset + 2] = (value >>> 8)\\r\\n  this[offset + 3] = (value & 0xff)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\\r\\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\\r\\n})\\r\\n\\r\\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\\r\\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\\r\\n})\\r\\n\\r\\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\\r\\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\\r\\n  if (offset < 0) throw new RangeError('Index out of range')\\r\\n}\\r\\n\\r\\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\\r\\n  }\\r\\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\\r\\n  return offset + 4\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\\r\\n  return writeFloat(this, value, offset, true, noAssert)\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\\r\\n  return writeFloat(this, value, offset, false, noAssert)\\r\\n}\\r\\n\\r\\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\\r\\n  value = +value\\r\\n  offset = offset >>> 0\\r\\n  if (!noAssert) {\\r\\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\\r\\n  }\\r\\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\\r\\n  return offset + 8\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\\r\\n  return writeDouble(this, value, offset, true, noAssert)\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\\r\\n  return writeDouble(this, value, offset, false, noAssert)\\r\\n}\\r\\n\\r\\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\\r\\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\\r\\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\\r\\n  if (!start) start = 0\\r\\n  if (!end && end !== 0) end = this.length\\r\\n  if (targetStart >= target.length) targetStart = target.length\\r\\n  if (!targetStart) targetStart = 0\\r\\n  if (end > 0 && end < start) end = start\\r\\n\\r\\n  // Copy 0 bytes; we're done\\r\\n  if (end === start) return 0\\r\\n  if (target.length === 0 || this.length === 0) return 0\\r\\n\\r\\n  // Fatal error conditions\\r\\n  if (targetStart < 0) {\\r\\n    throw new RangeError('targetStart out of bounds')\\r\\n  }\\r\\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\\r\\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\\r\\n\\r\\n  // Are we oob?\\r\\n  if (end > this.length) end = this.length\\r\\n  if (target.length - targetStart < end - start) {\\r\\n    end = target.length - targetStart + start\\r\\n  }\\r\\n\\r\\n  const len = end - start\\r\\n\\r\\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\\r\\n    // Use built-in when available, missing from IE11\\r\\n    this.copyWithin(targetStart, start, end)\\r\\n  } else {\\r\\n    Uint8Array.prototype.set.call(\\r\\n      target,\\r\\n      this.subarray(start, end),\\r\\n      targetStart\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return len\\r\\n}\\r\\n\\r\\n// Usage:\\r\\n//    buffer.fill(number[, offset[, end]])\\r\\n//    buffer.fill(buffer[, offset[, end]])\\r\\n//    buffer.fill(string[, offset[, end]][, encoding])\\r\\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\\r\\n  // Handle string cases:\\r\\n  if (typeof val === 'string') {\\r\\n    if (typeof start === 'string') {\\r\\n      encoding = start\\r\\n      start = 0\\r\\n      end = this.length\\r\\n    } else if (typeof end === 'string') {\\r\\n      encoding = end\\r\\n      end = this.length\\r\\n    }\\r\\n    if (encoding !== undefined && typeof encoding !== 'string') {\\r\\n      throw new TypeError('encoding must be a string')\\r\\n    }\\r\\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\\r\\n      throw new TypeError('Unknown encoding: ' + encoding)\\r\\n    }\\r\\n    if (val.length === 1) {\\r\\n      const code = val.charCodeAt(0)\\r\\n      if ((encoding === 'utf8' && code < 128) ||\\r\\n          encoding === 'latin1') {\\r\\n        // Fast path: If `val` fits into a single byte, use that numeric value.\\r\\n        val = code\\r\\n      }\\r\\n    }\\r\\n  } else if (typeof val === 'number') {\\r\\n    val = val & 255\\r\\n  } else if (typeof val === 'boolean') {\\r\\n    val = Number(val)\\r\\n  }\\r\\n\\r\\n  // Invalid ranges are not set to a default, so can range check early.\\r\\n  if (start < 0 || this.length < start || this.length < end) {\\r\\n    throw new RangeError('Out of range index')\\r\\n  }\\r\\n\\r\\n  if (end <= start) {\\r\\n    return this\\r\\n  }\\r\\n\\r\\n  start = start >>> 0\\r\\n  end = end === undefined ? this.length : end >>> 0\\r\\n\\r\\n  if (!val) val = 0\\r\\n\\r\\n  let i\\r\\n  if (typeof val === 'number') {\\r\\n    for (i = start; i < end; ++i) {\\r\\n      this[i] = val\\r\\n    }\\r\\n  } else {\\r\\n    const bytes = Buffer.isBuffer(val)\\r\\n      ? val\\r\\n      : Buffer.from(val, encoding)\\r\\n    const len = bytes.length\\r\\n    if (len === 0) {\\r\\n      throw new TypeError('The value \\\"' + val +\\r\\n        '\\\" is invalid for argument \\\"value\\\"')\\r\\n    }\\r\\n    for (i = 0; i < end - start; ++i) {\\r\\n      this[i + start] = bytes[i % len]\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return this\\r\\n}\\r\\n\\r\\n// CUSTOM ERRORS\\r\\n// =============\\r\\n\\r\\n// Simplified versions from Node, changed for Buffer-only usage\\r\\nconst errors = {}\\r\\nfunction E (sym, getMessage, Base) {\\r\\n  errors[sym] = class NodeError extends Base {\\r\\n    constructor () {\\r\\n      super()\\r\\n\\r\\n      Object.defineProperty(this, 'message', {\\r\\n        value: getMessage.apply(this, arguments),\\r\\n        writable: true,\\r\\n        configurable: true\\r\\n      })\\r\\n\\r\\n      // Add the error code to the name to include it in the stack trace.\\r\\n      this.name = `${this.name} [${sym}]`\\r\\n      // Access the stack to generate the error message including the error code\\r\\n      // from the name.\\r\\n      this.stack // eslint-disable-line no-unused-expressions\\r\\n      // Reset the name to the actual name.\\r\\n      delete this.name\\r\\n    }\\r\\n\\r\\n    get code () {\\r\\n      return sym\\r\\n    }\\r\\n\\r\\n    set code (value) {\\r\\n      Object.defineProperty(this, 'code', {\\r\\n        configurable: true,\\r\\n        enumerable: true,\\r\\n        value,\\r\\n        writable: true\\r\\n      })\\r\\n    }\\r\\n\\r\\n    toString () {\\r\\n      return `${this.name} [${sym}]: ${this.message}`\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nE('ERR_BUFFER_OUT_OF_BOUNDS',\\r\\n  function (name) {\\r\\n    if (name) {\\r\\n      return `${name} is outside of buffer bounds`\\r\\n    }\\r\\n\\r\\n    return 'Attempt to access memory outside buffer bounds'\\r\\n  }, RangeError)\\r\\nE('ERR_INVALID_ARG_TYPE',\\r\\n  function (name, actual) {\\r\\n    return `The \\\"${name}\\\" argument must be of type number. Received type ${typeof actual}`\\r\\n  }, TypeError)\\r\\nE('ERR_OUT_OF_RANGE',\\r\\n  function (str, range, input) {\\r\\n    let msg = `The value of \\\"${str}\\\" is out of range.`\\r\\n    let received = input\\r\\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\\r\\n      received = addNumericalSeparator(String(input))\\r\\n    } else if (typeof input === 'bigint') {\\r\\n      received = String(input)\\r\\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\\r\\n        received = addNumericalSeparator(received)\\r\\n      }\\r\\n      received += 'n'\\r\\n    }\\r\\n    msg += ` It must be ${range}. Received ${received}`\\r\\n    return msg\\r\\n  }, RangeError)\\r\\n\\r\\nfunction addNumericalSeparator (val) {\\r\\n  let res = ''\\r\\n  let i = val.length\\r\\n  const start = val[0] === '-' ? 1 : 0\\r\\n  for (; i >= start + 4; i -= 3) {\\r\\n    res = `_${val.slice(i - 3, i)}${res}`\\r\\n  }\\r\\n  return `${val.slice(0, i)}${res}`\\r\\n}\\r\\n\\r\\n// CHECK FUNCTIONS\\r\\n// ===============\\r\\n\\r\\nfunction checkBounds (buf, offset, byteLength) {\\r\\n  validateNumber(offset, 'offset')\\r\\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\\r\\n    boundsError(offset, buf.length - (byteLength + 1))\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\\r\\n  if (value > max || value < min) {\\r\\n    const n = typeof min === 'bigint' ? 'n' : ''\\r\\n    let range\\r\\n    if (byteLength > 3) {\\r\\n      if (min === 0 || min === BigInt(0)) {\\r\\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\\r\\n      } else {\\r\\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\\r\\n                `${(byteLength + 1) * 8 - 1}${n}`\\r\\n      }\\r\\n    } else {\\r\\n      range = `>= ${min}${n} and <= ${max}${n}`\\r\\n    }\\r\\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\\r\\n  }\\r\\n  checkBounds(buf, offset, byteLength)\\r\\n}\\r\\n\\r\\nfunction validateNumber (value, name) {\\r\\n  if (typeof value !== 'number') {\\r\\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction boundsError (value, length, type) {\\r\\n  if (Math.floor(value) !== value) {\\r\\n    validateNumber(value, type)\\r\\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\\r\\n  }\\r\\n\\r\\n  if (length < 0) {\\r\\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\\r\\n  }\\r\\n\\r\\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\\r\\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\\r\\n                                    value)\\r\\n}\\r\\n\\r\\n// HELPER FUNCTIONS\\r\\n// ================\\r\\n\\r\\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\\r\\n\\r\\nfunction base64clean (str) {\\r\\n  // Node takes equal signs as end of the Base64 encoding\\r\\n  str = str.split('=')[0]\\r\\n  // Node strips out invalid characters like \\\\n and \\\\t from the string, base64-js does not\\r\\n  str = str.trim().replace(INVALID_BASE64_RE, '')\\r\\n  // Node converts strings with length < 2 to ''\\r\\n  if (str.length < 2) return ''\\r\\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\\r\\n  while (str.length % 4 !== 0) {\\r\\n    str = str + '='\\r\\n  }\\r\\n  return str\\r\\n}\\r\\n\\r\\nfunction utf8ToBytes (string, units) {\\r\\n  units = units || Infinity\\r\\n  let codePoint\\r\\n  const length = string.length\\r\\n  let leadSurrogate = null\\r\\n  const bytes = []\\r\\n\\r\\n  for (let i = 0; i < length; ++i) {\\r\\n    codePoint = string.charCodeAt(i)\\r\\n\\r\\n    // is surrogate component\\r\\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\\r\\n      // last char was a lead\\r\\n      if (!leadSurrogate) {\\r\\n        // no lead yet\\r\\n        if (codePoint > 0xDBFF) {\\r\\n          // unexpected trail\\r\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n          continue\\r\\n        } else if (i + 1 === length) {\\r\\n          // unpaired lead\\r\\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n          continue\\r\\n        }\\r\\n\\r\\n        // valid lead\\r\\n        leadSurrogate = codePoint\\r\\n\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      // 2 leads in a row\\r\\n      if (codePoint < 0xDC00) {\\r\\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n        leadSurrogate = codePoint\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      // valid surrogate pair\\r\\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\\r\\n    } else if (leadSurrogate) {\\r\\n      // valid bmp char, but last char was a lead\\r\\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\\r\\n    }\\r\\n\\r\\n    leadSurrogate = null\\r\\n\\r\\n    // encode utf8\\r\\n    if (codePoint < 0x80) {\\r\\n      if ((units -= 1) < 0) break\\r\\n      bytes.push(codePoint)\\r\\n    } else if (codePoint < 0x800) {\\r\\n      if ((units -= 2) < 0) break\\r\\n      bytes.push(\\r\\n        codePoint >> 0x6 | 0xC0,\\r\\n        codePoint & 0x3F | 0x80\\r\\n      )\\r\\n    } else if (codePoint < 0x10000) {\\r\\n      if ((units -= 3) < 0) break\\r\\n      bytes.push(\\r\\n        codePoint >> 0xC | 0xE0,\\r\\n        codePoint >> 0x6 & 0x3F | 0x80,\\r\\n        codePoint & 0x3F | 0x80\\r\\n      )\\r\\n    } else if (codePoint < 0x110000) {\\r\\n      if ((units -= 4) < 0) break\\r\\n      bytes.push(\\r\\n        codePoint >> 0x12 | 0xF0,\\r\\n        codePoint >> 0xC & 0x3F | 0x80,\\r\\n        codePoint >> 0x6 & 0x3F | 0x80,\\r\\n        codePoint & 0x3F | 0x80\\r\\n      )\\r\\n    } else {\\r\\n      throw new Error('Invalid code point')\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return bytes\\r\\n}\\r\\n\\r\\nfunction asciiToBytes (str) {\\r\\n  const byteArray = []\\r\\n  for (let i = 0; i < str.length; ++i) {\\r\\n    // Node's code seems to be doing this and not & 0x7F..\\r\\n    byteArray.push(str.charCodeAt(i) & 0xFF)\\r\\n  }\\r\\n  return byteArray\\r\\n}\\r\\n\\r\\nfunction utf16leToBytes (str, units) {\\r\\n  let c, hi, lo\\r\\n  const byteArray = []\\r\\n  for (let i = 0; i < str.length; ++i) {\\r\\n    if ((units -= 2) < 0) break\\r\\n\\r\\n    c = str.charCodeAt(i)\\r\\n    hi = c >> 8\\r\\n    lo = c % 256\\r\\n    byteArray.push(lo)\\r\\n    byteArray.push(hi)\\r\\n  }\\r\\n\\r\\n  return byteArray\\r\\n}\\r\\n\\r\\nfunction base64ToBytes (str) {\\r\\n  return base64.toByteArray(base64clean(str))\\r\\n}\\r\\n\\r\\nfunction blitBuffer (src, dst, offset, length) {\\r\\n  let i\\r\\n  for (i = 0; i < length; ++i) {\\r\\n    if ((i + offset >= dst.length) || (i >= src.length)) break\\r\\n    dst[i + offset] = src[i]\\r\\n  }\\r\\n  return i\\r\\n}\\r\\n\\r\\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\\r\\n// the `instanceof` check but they should be treated as of that type.\\r\\n// See: https://github.com/feross/buffer/issues/166\\r\\nfunction isInstance (obj, type) {\\r\\n  return obj instanceof type ||\\r\\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\\r\\n      obj.constructor.name === type.name)\\r\\n}\\r\\nfunction numberIsNaN (obj) {\\r\\n  // For IE11 support\\r\\n  return obj !== obj // eslint-disable-line no-self-compare\\r\\n}\\r\\n\\r\\n// Create lookup table for `toString('hex')`\\r\\n// See: https://github.com/feross/buffer/issues/219\\r\\nconst hexSliceLookupTable = (function () {\\r\\n  const alphabet = '0123456789abcdef'\\r\\n  const table = new Array(256)\\r\\n  for (let i = 0; i < 16; ++i) {\\r\\n    const i16 = i * 16\\r\\n    for (let j = 0; j < 16; ++j) {\\r\\n      table[i16 + j] = alphabet[i] + alphabet[j]\\r\\n    }\\r\\n  }\\r\\n  return table\\r\\n})()\\r\\n\\r\\n// Return not function with Error if BigInt not supported\\r\\nfunction defineBigIntMethod (fn) {\\r\\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\\r\\n}\\r\\n\\r\\nfunction BufferBigIntNotDefined () {\\r\\n  throw new Error('BigInt not supported')\\r\\n}\\r\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"createBuffer\",\"length\",\"K_MAX_LENGTH\",\"RangeError\",\"buf\",\"Uint8Array\",\"Object\",\"setPrototypeOf\",\"Buffer\",\"prototype\",\"arg\",\"encodingOrOffset\",\"TypeError\",\"allocUnsafe\",\"from\",\"value\",\"encoding\",\"isEncoding\",\"byteLength\",\"actual\",\"write\",\"slice\",\"ArrayBuffer\",\"isView\",\"isInstance\",\"copy\",\"fromArrayBuffer\",\"buffer\",\"byteOffset\",\"fromArrayLike\",\"SharedArrayBuffer\",\"valueOf\",\"b\",\"fromObject\",\"Symbol\",\"toPrimitive\",\"assertSize\",\"size\",\"checked\",\"array\",\"i\",\"undefined\",\"obj\",\"isBuffer\",\"len\",\"type\",\"Array\",\"isArray\",\"data\",\"toString\",\"string\",\"mustMatch\",\"arguments\",\"loweredCase\",\"utf8ToBytes\",\"base64ToBytes\",\"toLowerCase\",\"slowToString\",\"start\",\"end\",\"out\",\"hexSliceLookupTable\",\"utf8Slice\",\"ret\",\"Math\",\"min\",\"String\",\"fromCharCode\",\"base64\",\"fromByteArray\",\"bytes\",\"res\",\"swap\",\"n\",\"m\",\"bidirectionalIndexOf\",\"val\",\"dir\",\"arrayIndexOf\",\"indexOf\",\"call\",\"lastIndexOf\",\"arr\",\"read\",\"indexSize\",\"readUInt16BE\",\"arrLength\",\"valLength\",\"foundIndex\",\"found\",\"j\",\"firstByte\",\"codePoint\",\"bytesPerSequence\",\"secondByte\",\"thirdByte\",\"fourthByte\",\"tempCodePoint\",\"push\",\"MAX_ARGUMENTS_LENGTH\",\"apply\",\"checkOffset\",\"offset\",\"ext\",\"checkInt\",\"max\",\"wrtBigUInt64LE\",\"checkIntBI\",\"lo\",\"Number\",\"BigInt\",\"hi\",\"wrtBigUInt64BE\",\"checkIEEE754\",\"writeFloat\",\"littleEndian\",\"noAssert\",\"ieee754\",\"writeDouble\",\"E\",\"sym\",\"getMessage\",\"Base\",\"errors\",\"constructor\",\"defineProperty\",\"writable\",\"configurable\",\"name\",\"stack\",\"enumerable\",\"message\",\"addNumericalSeparator\",\"ERR_OUT_OF_RANGE\",\"range\",\"validateNumber\",\"boundsError\",\"ERR_INVALID_ARG_TYPE\",\"floor\",\"ERR_BUFFER_OUT_OF_BOUNDS\",\"units\",\"Infinity\",\"leadSurrogate\",\"charCodeAt\",\"Error\",\"str\",\"toByteArray\",\"split\",\"trim\",\"replace\",\"INVALID_BASE64_RE\",\"blitBuffer\",\"src\",\"dst\",\"defineBigIntMethod\",\"fn\",\"BufferBigIntNotDefined\",\"customInspectSymbol\",\"SlowBuffer\",\"alloc\",\"INSPECT_MAX_BYTES\",\"kMaxLength\",\"TYPED_ARRAY_SUPPORT\",\"typedArraySupport\",\"proto\",\"foo\",\"e\",\"console\",\"error\",\"get\",\"poolSize\",\"Buffer.from\",\"Buffer.alloc\",\"fill\",\"Buffer.allocUnsafe\",\"allocUnsafeSlow\",\"Buffer.allocUnsafeSlow\",\"Buffer.isBuffer\",\"_isBuffer\",\"compare\",\"Buffer.compare\",\"a\",\"x\",\"y\",\"Buffer.isEncoding\",\"concat\",\"Buffer.concat\",\"list\",\"pos\",\"set\",\"swap16\",\"Buffer.prototype.swap16\",\"swap32\",\"Buffer.prototype.swap32\",\"swap64\",\"Buffer.prototype.swap64\",\"Buffer.prototype.toString\",\"toLocaleString\",\"equals\",\"Buffer.prototype.equals\",\"inspect\",\"Buffer.prototype.inspect\",\"Buffer.prototype.compare\",\"target\",\"thisStart\",\"thisEnd\",\"thisCopy\",\"targetCopy\",\"includes\",\"Buffer.prototype.includes\",\"Buffer.prototype.indexOf\",\"Buffer.prototype.lastIndexOf\",\"Buffer.prototype.write\",\"isFinite\",\"remaining\",\"strLen\",\"parsed\",\"parseInt\",\"substr\",\"byteArray\",\"c\",\"toJSON\",\"Buffer.prototype.toJSON\",\"_arr\",\"Buffer.prototype.slice\",\"newBuf\",\"subarray\",\"readUintLE\",\"readUIntLE\",\"Buffer.prototype.readUIntLE\",\"mul\",\"readUintBE\",\"readUIntBE\",\"Buffer.prototype.readUIntBE\",\"readUint8\",\"readUInt8\",\"Buffer.prototype.readUInt8\",\"readUint16LE\",\"readUInt16LE\",\"Buffer.prototype.readUInt16LE\",\"readUint16BE\",\"Buffer.prototype.readUInt16BE\",\"readUint32LE\",\"readUInt32LE\",\"Buffer.prototype.readUInt32LE\",\"readUint32BE\",\"readUInt32BE\",\"Buffer.prototype.readUInt32BE\",\"readBigUInt64LE\",\"first\",\"last\",\"readBigUInt64BE\",\"readIntLE\",\"Buffer.prototype.readIntLE\",\"pow\",\"readIntBE\",\"Buffer.prototype.readIntBE\",\"readInt8\",\"Buffer.prototype.readInt8\",\"readInt16LE\",\"Buffer.prototype.readInt16LE\",\"readInt16BE\",\"Buffer.prototype.readInt16BE\",\"readInt32LE\",\"Buffer.prototype.readInt32LE\",\"readInt32BE\",\"Buffer.prototype.readInt32BE\",\"readBigInt64LE\",\"readBigInt64BE\",\"readFloatLE\",\"Buffer.prototype.readFloatLE\",\"readFloatBE\",\"Buffer.prototype.readFloatBE\",\"readDoubleLE\",\"Buffer.prototype.readDoubleLE\",\"readDoubleBE\",\"Buffer.prototype.readDoubleBE\",\"writeUintLE\",\"writeUIntLE\",\"Buffer.prototype.writeUIntLE\",\"writeUintBE\",\"writeUIntBE\",\"Buffer.prototype.writeUIntBE\",\"writeUint8\",\"writeUInt8\",\"Buffer.prototype.writeUInt8\",\"writeUint16LE\",\"writeUInt16LE\",\"Buffer.prototype.writeUInt16LE\",\"writeUint16BE\",\"writeUInt16BE\",\"Buffer.prototype.writeUInt16BE\",\"writeUint32LE\",\"writeUInt32LE\",\"Buffer.prototype.writeUInt32LE\",\"writeUint32BE\",\"writeUInt32BE\",\"Buffer.prototype.writeUInt32BE\",\"writeBigUInt64LE\",\"writeBigUInt64BE\",\"writeIntLE\",\"Buffer.prototype.writeIntLE\",\"limit\",\"sub\",\"writeIntBE\",\"Buffer.prototype.writeIntBE\",\"writeInt8\",\"Buffer.prototype.writeInt8\",\"writeInt16LE\",\"Buffer.prototype.writeInt16LE\",\"writeInt16BE\",\"Buffer.prototype.writeInt16BE\",\"writeInt32LE\",\"Buffer.prototype.writeInt32LE\",\"writeInt32BE\",\"Buffer.prototype.writeInt32BE\",\"writeBigInt64LE\",\"writeBigInt64BE\",\"writeFloatLE\",\"Buffer.prototype.writeFloatLE\",\"writeFloatBE\",\"Buffer.prototype.writeFloatBE\",\"writeDoubleLE\",\"Buffer.prototype.writeDoubleLE\",\"writeDoubleBE\",\"Buffer.prototype.writeDoubleBE\",\"Buffer.prototype.copy\",\"targetStart\",\"copyWithin\",\"Buffer.prototype.fill\",\"code\",\"input\",\"msg\",\"received\",\"isInteger\",\"abs\",\"table\",\"i16\",\"alphabet\"]\n}\n"]