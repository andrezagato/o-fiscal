["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js"],"~:js","shadow$provide[29]=function(S,ka,a){Object.defineProperty(a,\"__esModule\",{value:!0});ka=S(14);const I=ka.__importDefault(S(20)),q=S(22),D=ka.__importDefault(S(23)),C=ka.__importDefault(S(24)),G=S(25),E=ka.__importDefault(S(28)),M=()=>{},d=[1E3,2E3,5E3,1E4];class K{constructor(p,k){var y;this.apiKey=this.accessTokenValue=null;this._manuallySetToken=!1;this.channels=[];this.httpEndpoint=this.endPoint=\"\";this.headers={};this.params={};this.timeout=q.DEFAULT_TIMEOUT;this.transport=null;this.heartbeatIntervalMs=\n25E3;this.heartbeatTimer=void 0;this.pendingHeartbeatRef=null;this.heartbeatCallback=M;this.ref=0;this.reconnectTimer=null;this.vsn=q.DEFAULT_VSN;this.logger=M;this.conn=null;this.sendBuffer=[];this.serializer=new D.default;this.stateChangeCallbacks={open:[],close:[],error:[],message:[]};this.accessToken=null;this._connectionState=\"disconnected\";this._wasManualDisconnect=!1;this._heartbeatSentAt=this._authPromise=null;this._resolveFetch=v=>v?(...z)=>v(...z):(...z)=>fetch(...z);if((y=k===null||k===\nvoid 0?void 0:k.params)===null||y===void 0||!y.apikey)throw Error(\"API key is required to connect to Realtime\");this.apiKey=k.params.apikey;this.endPoint=`${p}/${q.TRANSPORTS.websocket}`;this.httpEndpoint=(0,G.httpEndpointURL)(p);this._initializeOptions(k);this._setupReconnectionTimer();this.fetch=this._resolveFetch(k===null||k===void 0?void 0:k.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){this._setConnectionState(\"connecting\");this.accessToken&&\n!this._authPromise&&this._setAuthSafely(\"connect\");if(this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=I.default.createWebSocket(this.endpointURL())}catch(p){this._setConnectionState(\"disconnected\");const k=p.message;if(k.includes(\"Node.js\"))throw Error(`${k}\\n\\n`+'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\nOption 1: Use Node.js 22+ which has native WebSocket support\\nOption 2: Install and provide the \"ws\" package:\\n\\n  npm install ws\\n\\n  import ws from \"ws\"\\n  const client \\x3d new RealtimeClient(url, {\\n    ...options,\\n    transport: ws\\n  })');\nthrow Error(`WebSocket not available: ${k}`);}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(p,k){if(!this.isDisconnecting())if(this._setConnectionState(\"disconnecting\",!0),this.conn){const y=setTimeout(()=>{this._setConnectionState(\"disconnected\")},100);this.conn.onclose=()=>{clearTimeout(y);this._setConnectionState(\"disconnected\")};typeof this.conn.close===\"function\"&&(p?this.conn.close(p,k!==null&&\nk!==void 0?k:\"\"):this.conn.close());this._teardownConnection()}else this._setConnectionState(\"disconnected\")}getChannels(){return this.channels}async removeChannel(p){p=await p.unsubscribe();this.channels.length===0&&this.disconnect();return p}async removeAllChannels(){const p=await Promise.all(this.channels.map(k=>k.unsubscribe()));this.channels=[];this.disconnect();return p}log(p,k,y){this.logger(p,k,y)}connectionState(){switch(this.conn&&this.conn.readyState){case q.SOCKET_STATES.connecting:return q.CONNECTION_STATE.Connecting;\ncase q.SOCKET_STATES.open:return q.CONNECTION_STATE.Open;case q.SOCKET_STATES.closing:return q.CONNECTION_STATE.Closing;default:return q.CONNECTION_STATE.Closed}}isConnected(){return this.connectionState()===q.CONNECTION_STATE.Open}isConnecting(){return this._connectionState===\"connecting\"}isDisconnecting(){return this._connectionState===\"disconnecting\"}channel(p,k={config:{}}){const y=`realtime:${p}`,v=this.getChannels().find(z=>z.topic===y);if(v)return v;p=new E.default(`realtime:${p}`,k,this);\nthis.channels.push(p);return p}push(p){const {topic:k,event:y,payload:v,ref:z}=p,J=()=>{this.encode(p,l=>{var t;(t=this.conn)===null||t===void 0||t.send(l)})};this.log(\"push\",`${k} ${y} (${z})`,v);this.isConnected()?J():this.sendBuffer.push(J)}async setAuth(p=null){this._authPromise=this._performAuth(p);try{await this._authPromise}finally{this._authPromise=null}}_isManualToken(){return this._manuallySetToken}async sendHeartbeat(){var p;if(this.isConnected())if(this.pendingHeartbeatRef){this._heartbeatSentAt=\nthis.pendingHeartbeatRef=null;this.log(\"transport\",\"heartbeat timeout. Attempting to re-establish connection\");try{this.heartbeatCallback(\"timeout\")}catch(k){this.log(\"error\",\"error in heartbeat callback\",k)}this._wasManualDisconnect=!1;(p=this.conn)===null||p===void 0||p.close(q.WS_CLOSE_NORMAL,\"heartbeat timeout\");setTimeout(()=>{var k;this.isConnected()||(k=this.reconnectTimer)===null||k===void 0||k.scheduleTimeout()},100)}else{this._heartbeatSentAt=Date.now();this.pendingHeartbeatRef=this._makeRef();\nthis.push({topic:\"phoenix\",event:\"heartbeat\",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback(\"sent\")}catch(k){this.log(\"error\",\"error in heartbeat callback\",k)}this._setAuthSafely(\"heartbeat\")}else try{this.heartbeatCallback(\"disconnected\")}catch(k){this.log(\"error\",\"error in heartbeat callback\",k)}}onHeartbeat(p){this.heartbeatCallback=p}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(p=>p()),this.sendBuffer=[])}_makeRef(){let p=this.ref+\n1;this.ref=p===this.ref?0:p;return this.ref.toString()}_leaveOpenTopic(p){let k=this.channels.find(y=>y.topic===p&&(y._isJoined()||y._isJoining()));k&&(this.log(\"transport\",`leaving duplicate topic \"${p}\"`),k.unsubscribe())}_remove(p){this.channels=this.channels.filter(k=>k.topic!==p.topic)}_onConnMessage(p){this.decode(p.data,k=>{if(k.topic===\"phoenix\"&&k.event===\"phx_reply\"&&k.ref&&k.ref===this.pendingHeartbeatRef){const l=this._heartbeatSentAt?Date.now()-this._heartbeatSentAt:void 0;try{this.heartbeatCallback(k.payload.status===\n\"ok\"?\"ok\":\"error\",l)}catch(t){this.log(\"error\",\"error in heartbeat callback\",t)}this.pendingHeartbeatRef=this._heartbeatSentAt=null}const {topic:y,event:v,payload:z,ref:J}=k;this.log(\"receive\",`${z.status||\"\"} ${y} ${v} ${J?`(${J})`:\"\"}`.trim(),z);this.channels.filter(l=>l._isMember(y)).forEach(l=>l._trigger(v,z,J));this._triggerStateCallbacks(\"message\",k)})}_clearTimer(p){var k;p===\"heartbeat\"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):p===\"reconnect\"&&((k=\nthis.reconnectTimer)===null||k===void 0||k.reset())}_clearAllTimers(){this._clearTimer(\"heartbeat\");this._clearTimer(\"reconnect\")}_setupConnectionHandlers(){this.conn&&(\"binaryType\"in this.conn&&(this.conn.binaryType=\"arraybuffer\"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=p=>this._onConnError(p),this.conn.onmessage=p=>this._onConnMessage(p),this.conn.onclose=p=>this._onConnClose(p),this.conn.readyState===q.SOCKET_STATES.open&&this._onConnOpen())}_teardownConnection(){if(this.conn){if(this.conn.readyState===\nq.SOCKET_STATES.open||this.conn.readyState===q.SOCKET_STATES.connecting)try{this.conn.close()}catch(p){this.log(\"error\",\"Error closing connection\",p)}this.conn.onopen=null;this.conn.onerror=null;this.conn.onmessage=null;this.conn=this.conn.onclose=null}this._clearAllTimers();this._terminateWorker();this.channels.forEach(p=>p.teardown())}_onConnOpen(){this._setConnectionState(\"connected\");this.log(\"transport\",`connected to ${this.endpointURL()}`);(this._authPromise||(this.accessToken&&!this.accessTokenValue?\nthis.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(p=>{this.log(\"error\",\"error waiting for auth on connect\",p);this.flushSendBuffer()});this._clearTimer(\"reconnect\");this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat();this._triggerStateCallbacks(\"open\")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer);this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?\nthis.log(\"worker\",`starting worker for from ${this.workerUrl}`):this.log(\"worker\",\"starting default worker\");const p=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(p);this.workerRef.onerror=k=>{this.log(\"worker\",\"worker error\",k.message);this._terminateWorker()};this.workerRef.onmessage=k=>{k.data.event===\"keepAlive\"&&this.sendHeartbeat()};this.workerRef.postMessage({event:\"start\",interval:this.heartbeatIntervalMs})}_terminateWorker(){this.workerRef&&(this.log(\"worker\",\"terminating worker\"),\nthis.workerRef.terminate(),this.workerRef=void 0)}_onConnClose(p){var k;this._setConnectionState(\"disconnected\");this.log(\"transport\",\"close\",p);this._triggerChanError();this._clearTimer(\"heartbeat\");this._wasManualDisconnect||(k=this.reconnectTimer)===null||k===void 0||k.scheduleTimeout();this._triggerStateCallbacks(\"close\",p)}_onConnError(p){this._setConnectionState(\"disconnected\");this.log(\"transport\",`${p}`);this._triggerChanError();this._triggerStateCallbacks(\"error\",p);try{this.heartbeatCallback(\"error\")}catch(k){this.log(\"error\",\n\"error in heartbeat callback\",k)}}_triggerChanError(){this.channels.forEach(p=>p._trigger(q.CHANNEL_EVENTS.error))}_appendParams(p,k){if(Object.keys(k).length===0)return p;const y=p.match(/\\?/)?\"\\x26\":\"?\";k=new URLSearchParams(k);return`${p}${y}${k}`}_workerObjectUrl(p){p||(p=new Blob(['\\n  addEventListener(\"message\", (e) \\x3d\\x3e {\\n    if (e.data.event \\x3d\\x3d\\x3d \"start\") {\\n      setInterval(() \\x3d\\x3e postMessage({ event: \"keepAlive\" }), e.data.interval);\\n    }\\n  });'],{type:\"application/javascript\"}),\np=URL.createObjectURL(p));return p}_setConnectionState(p,k=!1){this._connectionState=p;p===\"connecting\"?this._wasManualDisconnect=!1:p===\"disconnecting\"&&(this._wasManualDisconnect=k)}async _performAuth(p=null){let k,y=!1;if(p)k=p,y=!0;else if(this.accessToken)try{k=await this.accessToken()}catch(v){this.log(\"error\",\"Error fetching access token from callback\",v),k=this.accessTokenValue}else k=this.accessTokenValue;y?this._manuallySetToken=!0:this.accessToken&&(this._manuallySetToken=!1);this.accessTokenValue!=\nk&&(this.accessTokenValue=k,this.channels.forEach(v=>{const z={access_token:k,version:q.DEFAULT_VERSION};k&&v.updateJoinPayload(z);v.joinedOnce&&v._isJoined()&&v._push(q.CHANNEL_EVENTS.access_token,{access_token:k})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(p=\"general\"){this._isManualToken()||this.setAuth().catch(k=>{this.log(\"error\",`Error setting auth in ${p}`,k)})}_triggerStateCallbacks(p,k){try{this.stateChangeCallbacks[p].forEach(y=>{try{y(k)}catch(v){this.log(\"error\",\n`error in ${p} callback`,v)}})}catch(y){this.log(\"error\",`error triggering ${p} callbacks`,y)}}_setupReconnectionTimer(){this.reconnectTimer=new C.default(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded();this.isConnected()||this.connect()},10)},this.reconnectAfterMs)}_initializeOptions(p){var k,y,v,z,J,l,t,x,w,A,L,P;this.transport=(k=p===null||p===void 0?void 0:p.transport)!==null&&k!==void 0?k:null;this.timeout=(y=p===null||p===void 0?void 0:p.timeout)!==null&&y!==void 0?y:q.DEFAULT_TIMEOUT;\nthis.heartbeatIntervalMs=(v=p===null||p===void 0?void 0:p.heartbeatIntervalMs)!==null&&v!==void 0?v:25E3;this.worker=(z=p===null||p===void 0?void 0:p.worker)!==null&&z!==void 0?z:!1;this.accessToken=(J=p===null||p===void 0?void 0:p.accessToken)!==null&&J!==void 0?J:null;this.heartbeatCallback=(l=p===null||p===void 0?void 0:p.heartbeatCallback)!==null&&l!==void 0?l:M;this.vsn=(t=p===null||p===void 0?void 0:p.vsn)!==null&&t!==void 0?t:q.DEFAULT_VSN;if(p===null||p===void 0?0:p.params)this.params=p.params;\nif(p===null||p===void 0?0:p.logger)this.logger=p.logger;if((p===null||p===void 0?0:p.logLevel)||(p===null||p===void 0?0:p.log_level))this.logLevel=p.logLevel||p.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel});this.reconnectAfterMs=(x=p===null||p===void 0?void 0:p.reconnectAfterMs)!==null&&x!==void 0?x:T=>d[T-1]||1E4;switch(this.vsn){case q.VSN_1_0_0:this.encode=(w=p===null||p===void 0?void 0:p.encode)!==null&&w!==void 0?w:(T,Y)=>Y(JSON.stringify(T));this.decode=\n(A=p===null||p===void 0?void 0:p.decode)!==null&&A!==void 0?A:(T,Y)=>Y(JSON.parse(T));break;case q.VSN_2_0_0:this.encode=(L=p===null||p===void 0?void 0:p.encode)!==null&&L!==void 0?L:this.serializer.encode.bind(this.serializer);this.decode=(P=p===null||p===void 0?void 0:p.decode)!==null&&P!==void 0?P:this.serializer.decode.bind(this.serializer);break;default:throw Error(`Unsupported serializer version: ${this.vsn}`);}if(this.worker){if(typeof window!==\"undefined\"&&!window.Worker)throw Error(\"Web Worker is not supported\");\nthis.workerUrl=p===null||p===void 0?void 0:p.workerUrl}}}a.default=K}","~:source","shadow$provide[29] = function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst websocket_factory_1 = tslib_1.__importDefault(require(\"./lib/websocket-factory\"));\nconst constants_1 = require(\"./lib/constants\");\nconst serializer_1 = tslib_1.__importDefault(require(\"./lib/serializer\"));\nconst timer_1 = tslib_1.__importDefault(require(\"./lib/timer\"));\nconst transformers_1 = require(\"./lib/transformers\");\nconst RealtimeChannel_1 = tslib_1.__importDefault(require(\"./RealtimeChannel\"));\nconst noop = () => { };\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n    HEARTBEAT_INTERVAL: 25000,\n    RECONNECT_DELAY: 10,\n    HEARTBEAT_TIMEOUT_FALLBACK: 100,\n};\nconst RECONNECT_INTERVALS = [1000, 2000, 5000, 10000];\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nclass RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.logLevel Sets the log level for Realtime\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     * @param options.vsn The protocol version to use when connecting. Supported versions are \"1.0.0\" and \"2.0.0\". Defaults to \"2.0.0\".\n     * @example\n     * ```ts\n     * import RealtimeClient from '@supabase/realtime-js'\n     *\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\n     *   params: { apikey: 'public-anon-key' },\n     * })\n     * client.connect()\n     * ```\n     */\n    constructor(endPoint, options) {\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this._manuallySetToken = false;\n        this.channels = new Array();\n        this.endPoint = '';\n        this.httpEndpoint = '';\n        /** @deprecated headers cannot be set on websocket connections */\n        this.headers = {};\n        this.params = {};\n        this.timeout = constants_1.DEFAULT_TIMEOUT;\n        this.transport = null;\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.heartbeatCallback = noop;\n        this.ref = 0;\n        this.reconnectTimer = null;\n        this.vsn = constants_1.DEFAULT_VSN;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new serializer_1.default();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.accessToken = null;\n        this._connectionState = 'disconnected';\n        this._wasManualDisconnect = false;\n        this._authPromise = null;\n        this._heartbeatSentAt = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */\n        this._resolveFetch = (customFetch) => {\n            if (customFetch) {\n                return (...args) => customFetch(...args);\n            }\n            return (...args) => fetch(...args);\n        };\n        // Validate required parameters\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\n            throw new Error('API key is required to connect to Realtime');\n        }\n        this.apiKey = options.params.apikey;\n        // Initialize endpoint URLs\n        this.endPoint = `${endPoint}/${constants_1.TRANSPORTS.websocket}`;\n        this.httpEndpoint = (0, transformers_1.httpEndpointURL)(endPoint);\n        this._initializeOptions(options);\n        this._setupReconnectionTimer();\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        // Skip if already connecting, disconnecting, or connected\n        if (this.isConnecting() ||\n            this.isDisconnecting() ||\n            (this.conn !== null && this.isConnected())) {\n            return;\n        }\n        this._setConnectionState('connecting');\n        // Trigger auth if needed and not already in progress\n        // This ensures auth is called for standalone RealtimeClient usage\n        // while avoiding race conditions with SupabaseClient's immediate setAuth call\n        if (this.accessToken && !this._authPromise) {\n            this._setAuthSafely('connect');\n        }\n        // Establish WebSocket connection\n        if (this.transport) {\n            // Use custom transport if provided\n            this.conn = new this.transport(this.endpointURL());\n        }\n        else {\n            // Try to use native WebSocket\n            try {\n                this.conn = websocket_factory_1.default.createWebSocket(this.endpointURL());\n            }\n            catch (error) {\n                this._setConnectionState('disconnected');\n                const errorMessage = error.message;\n                // Provide helpful error message based on environment\n                if (errorMessage.includes('Node.js')) {\n                    throw new Error(`${errorMessage}\\n\\n` +\n                        'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n' +\n                        'Option 1: Use Node.js 22+ which has native WebSocket support\\n' +\n                        'Option 2: Install and provide the \"ws\" package:\\n\\n' +\n                        '  npm install ws\\n\\n' +\n                        '  import ws from \"ws\"\\n' +\n                        '  const client = new RealtimeClient(url, {\\n' +\n                        '    ...options,\\n' +\n                        '    transport: ws\\n' +\n                        '  })');\n                }\n                throw new Error(`WebSocket not available: ${errorMessage}`);\n            }\n        }\n        this._setupConnectionHandlers();\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */\n    endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: this.vsn }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.isDisconnecting()) {\n            return;\n        }\n        this._setConnectionState('disconnecting', true);\n        if (this.conn) {\n            // Setup fallback timer to prevent hanging in disconnecting state\n            const fallbackTimer = setTimeout(() => {\n                this._setConnectionState('disconnected');\n            }, 100);\n            this.conn.onclose = () => {\n                clearTimeout(fallbackTimer);\n                this._setConnectionState('disconnected');\n            };\n            // Close the WebSocket connection if close method exists\n            if (typeof this.conn.close === 'function') {\n                if (code) {\n                    this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n                }\n                else {\n                    this.conn.close();\n                }\n            }\n            this._teardownConnection();\n        }\n        else {\n            this._setConnectionState('disconnected');\n        }\n    }\n    /**\n     * Returns all created channels\n     */\n    getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n    async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n    async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));\n        this.channels = [];\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case constants_1.SOCKET_STATES.connecting:\n                return constants_1.CONNECTION_STATE.Connecting;\n            case constants_1.SOCKET_STATES.open:\n                return constants_1.CONNECTION_STATE.Open;\n            case constants_1.SOCKET_STATES.closing:\n                return constants_1.CONNECTION_STATE.Closing;\n            default:\n                return constants_1.CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === constants_1.CONNECTION_STATE.Open;\n    }\n    /**\n     * Returns `true` if the connection is currently connecting.\n     */\n    isConnecting() {\n        return this._connectionState === 'connecting';\n    }\n    /**\n     * Returns `true` if the connection is currently disconnecting.\n     */\n    isDisconnecting() {\n        return this._connectionState === 'disconnecting';\n    }\n    /**\n     * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.\n     *\n     * Topics are automatically prefixed with `realtime:` to match the Realtime service.\n     * If a channel with the same topic already exists it will be returned instead of creating\n     * a duplicate connection.\n     */\n    channel(topic, params = { config: {} }) {\n        const realtimeTopic = `realtime:${topic}`;\n        const exists = this.getChannels().find((c) => c.topic === realtimeTopic);\n        if (!exists) {\n            const chan = new RealtimeChannel_1.default(`realtime:${topic}`, params, this);\n            this.channels.push(chan);\n            return chan;\n        }\n        else {\n            return exists;\n        }\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * When a token is explicitly provided, it will be preserved across channel operations\n     * (including removeChannel and resubscribe). The `accessToken` callback will not be\n     * invoked until `setAuth()` is called without arguments.\n     *\n     * @param token A JWT string to override the token set on the client.\n     *\n     * @example\n     * // Use a manual token (preserved across resubscribes, ignores accessToken callback)\n     * client.realtime.setAuth('my-custom-jwt')\n     *\n     * // Switch back to using the accessToken callback\n     * client.realtime.setAuth()\n     */\n    async setAuth(token = null) {\n        this._authPromise = this._performAuth(token);\n        try {\n            await this._authPromise;\n        }\n        finally {\n            this._authPromise = null;\n        }\n    }\n    /**\n     * Returns true if the current access token was explicitly set via setAuth(token),\n     * false if it was obtained via the accessToken callback.\n     * @internal\n     */\n    _isManualToken() {\n        return this._manuallySetToken;\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */\n    async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            try {\n                this.heartbeatCallback('disconnected');\n            }\n            catch (e) {\n                this.log('error', 'error in heartbeat callback', e);\n            }\n            return;\n        }\n        // Handle heartbeat timeout and force reconnection if needed\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this._heartbeatSentAt = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            try {\n                this.heartbeatCallback('timeout');\n            }\n            catch (e) {\n                this.log('error', 'error in heartbeat callback', e);\n            }\n            // Force reconnection after heartbeat timeout\n            this._wasManualDisconnect = false;\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(constants_1.WS_CLOSE_NORMAL, 'heartbeat timeout');\n            setTimeout(() => {\n                var _a;\n                if (!this.isConnected()) {\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n                }\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\n            return;\n        }\n        // Send heartbeat message to server\n        this._heartbeatSentAt = Date.now();\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        try {\n            this.heartbeatCallback('sent');\n        }\n        catch (e) {\n            this.log('error', 'error in heartbeat callback', e);\n        }\n        this._setAuthSafely('heartbeat');\n    }\n    /**\n     * Sets a callback that receives lifecycle events for internal heartbeat messages.\n     * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).\n     */\n    onHeartbeat(callback) {\n        this.heartbeatCallback = callback;\n    }\n    /**\n     * Flushes send buffer\n     */\n    flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c.topic !== channel.topic);\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            // Handle heartbeat responses\n            if (msg.topic === 'phoenix' &&\n                msg.event === 'phx_reply' &&\n                msg.ref &&\n                msg.ref === this.pendingHeartbeatRef) {\n                const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : undefined;\n                try {\n                    this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error', latency);\n                }\n                catch (e) {\n                    this.log('error', 'error in heartbeat callback', e);\n                }\n                this._heartbeatSentAt = null;\n                this.pendingHeartbeatRef = null;\n            }\n            // Log incoming message\n            const { topic, event, payload, ref } = msg;\n            const refString = ref ? `(${ref})` : '';\n            const status = payload.status || '';\n            this.log('receive', `${status} ${topic} ${event} ${refString}`.trim(), payload);\n            // Route message to appropriate channels\n            this.channels\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this._triggerStateCallbacks('message', msg);\n        });\n    }\n    /**\n     * Clear specific timer\n     * @internal\n     */\n    _clearTimer(timer) {\n        var _a;\n        if (timer === 'heartbeat' && this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = undefined;\n        }\n        else if (timer === 'reconnect') {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n    }\n    /**\n     * Clear all timers\n     * @internal\n     */\n    _clearAllTimers() {\n        this._clearTimer('heartbeat');\n        this._clearTimer('reconnect');\n    }\n    /**\n     * Setup connection handlers for WebSocket events\n     * @internal\n     */\n    _setupConnectionHandlers() {\n        if (!this.conn)\n            return;\n        // Set binary type if supported (browsers and most WebSocket implementations)\n        if ('binaryType' in this.conn) {\n            ;\n            this.conn.binaryType = 'arraybuffer';\n        }\n        this.conn.onopen = () => this._onConnOpen();\n        this.conn.onerror = (error) => this._onConnError(error);\n        this.conn.onmessage = (event) => this._onConnMessage(event);\n        this.conn.onclose = (event) => this._onConnClose(event);\n        if (this.conn.readyState === constants_1.SOCKET_STATES.open) {\n            this._onConnOpen();\n        }\n    }\n    /**\n     * Teardown connection and cleanup resources\n     * @internal\n     */\n    _teardownConnection() {\n        if (this.conn) {\n            if (this.conn.readyState === constants_1.SOCKET_STATES.open ||\n                this.conn.readyState === constants_1.SOCKET_STATES.connecting) {\n                try {\n                    this.conn.close();\n                }\n                catch (e) {\n                    this.log('error', 'Error closing connection', e);\n                }\n            }\n            this.conn.onopen = null;\n            this.conn.onerror = null;\n            this.conn.onmessage = null;\n            this.conn.onclose = null;\n            this.conn = null;\n        }\n        this._clearAllTimers();\n        this._terminateWorker();\n        this.channels.forEach((channel) => channel.teardown());\n    }\n    /** @internal */\n    _onConnOpen() {\n        this._setConnectionState('connected');\n        this.log('transport', `connected to ${this.endpointURL()}`);\n        // Wait for any pending auth operations before flushing send buffer\n        // This ensures channel join messages include the correct access token\n        const authPromise = this._authPromise ||\n            (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());\n        authPromise\n            .then(() => {\n            this.flushSendBuffer();\n        })\n            .catch((e) => {\n            this.log('error', 'error waiting for auth on connect', e);\n            // Proceed anyway to avoid hanging connections\n            this.flushSendBuffer();\n        });\n        this._clearTimer('reconnect');\n        if (!this.worker) {\n            this._startHeartbeat();\n        }\n        else {\n            if (!this.workerRef) {\n                this._startWorkerHeartbeat();\n            }\n        }\n        this._triggerStateCallbacks('open');\n    }\n    /** @internal */\n    _startHeartbeat() {\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n    /** @internal */\n    _startWorkerHeartbeat() {\n        if (this.workerUrl) {\n            this.log('worker', `starting worker for from ${this.workerUrl}`);\n        }\n        else {\n            this.log('worker', `starting default worker`);\n        }\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\n        this.workerRef = new Worker(objectUrl);\n        this.workerRef.onerror = (error) => {\n            this.log('worker', 'worker error', error.message);\n            this._terminateWorker();\n        };\n        this.workerRef.onmessage = (event) => {\n            if (event.data.event === 'keepAlive') {\n                this.sendHeartbeat();\n            }\n        };\n        this.workerRef.postMessage({\n            event: 'start',\n            interval: this.heartbeatIntervalMs,\n        });\n    }\n    /**\n     * Terminate the Web Worker and clear the reference\n     * @internal\n     */\n    _terminateWorker() {\n        if (this.workerRef) {\n            this.log('worker', 'terminating worker');\n            this.workerRef.terminate();\n            this.workerRef = undefined;\n        }\n    }\n    /** @internal */\n    _onConnClose(event) {\n        var _a;\n        this._setConnectionState('disconnected');\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this._clearTimer('heartbeat');\n        // Only schedule reconnection if it wasn't a manual disconnect\n        if (!this._wasManualDisconnect) {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n        }\n        this._triggerStateCallbacks('close', event);\n    }\n    /** @internal */\n    _onConnError(error) {\n        this._setConnectionState('disconnected');\n        this.log('transport', `${error}`);\n        this._triggerChanError();\n        this._triggerStateCallbacks('error', error);\n        try {\n            this.heartbeatCallback('error');\n        }\n        catch (e) {\n            this.log('error', 'error in heartbeat callback', e);\n        }\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(constants_1.CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        }\n        else {\n            const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n    /**\n     * Set connection state with proper state management\n     * @internal\n     */\n    _setConnectionState(state, manual = false) {\n        this._connectionState = state;\n        if (state === 'connecting') {\n            this._wasManualDisconnect = false;\n        }\n        else if (state === 'disconnecting') {\n            this._wasManualDisconnect = manual;\n        }\n    }\n    /**\n     * Perform the actual auth operation\n     * @internal\n     */\n    async _performAuth(token = null) {\n        let tokenToSend;\n        let isManualToken = false;\n        if (token) {\n            tokenToSend = token;\n            // Track if this is a manually-provided token\n            isManualToken = true;\n        }\n        else if (this.accessToken) {\n            // Call the accessToken callback to get fresh token\n            try {\n                tokenToSend = await this.accessToken();\n            }\n            catch (e) {\n                this.log('error', 'Error fetching access token from callback', e);\n                // Fall back to cached value if callback fails\n                tokenToSend = this.accessTokenValue;\n            }\n        }\n        else {\n            tokenToSend = this.accessTokenValue;\n        }\n        // Track whether this token was manually set or fetched via callback\n        if (isManualToken) {\n            this._manuallySetToken = true;\n        }\n        else if (this.accessToken) {\n            // If we used the callback, clear the manual flag\n            this._manuallySetToken = false;\n        }\n        if (this.accessTokenValue != tokenToSend) {\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel) => {\n                const payload = {\n                    access_token: tokenToSend,\n                    version: constants_1.DEFAULT_VERSION,\n                };\n                tokenToSend && channel.updateJoinPayload(payload);\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(constants_1.CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend,\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Wait for any in-flight auth operations to complete\n     * @internal\n     */\n    async _waitForAuthIfNeeded() {\n        if (this._authPromise) {\n            await this._authPromise;\n        }\n    }\n    /**\n     * Safely call setAuth with standardized error handling\n     * @internal\n     */\n    _setAuthSafely(context = 'general') {\n        // Only refresh auth if using callback-based tokens\n        if (!this._isManualToken()) {\n            this.setAuth().catch((e) => {\n                this.log('error', `Error setting auth in ${context}`, e);\n            });\n        }\n    }\n    /**\n     * Trigger state change callbacks with proper error handling\n     * @internal\n     */\n    _triggerStateCallbacks(event, data) {\n        try {\n            this.stateChangeCallbacks[event].forEach((callback) => {\n                try {\n                    callback(data);\n                }\n                catch (e) {\n                    this.log('error', `error in ${event} callback`, e);\n                }\n            });\n        }\n        catch (e) {\n            this.log('error', `error triggering ${event} callbacks`, e);\n        }\n    }\n    /**\n     * Setup reconnection timer with proper configuration\n     * @internal\n     */\n    _setupReconnectionTimer() {\n        this.reconnectTimer = new timer_1.default(async () => {\n            setTimeout(async () => {\n                await this._waitForAuthIfNeeded();\n                if (!this.isConnected()) {\n                    this.connect();\n                }\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\n        }, this.reconnectAfterMs);\n    }\n    /**\n     * Initialize client options with defaults\n     * @internal\n     */\n    _initializeOptions(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        // Set defaults\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs =\n            (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\n        this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : constants_1.DEFAULT_VSN;\n        // Handle special cases\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n            this.logLevel = options.logLevel || options.log_level;\n            this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });\n        }\n        // Set up functions with defaults\n        this.reconnectAfterMs =\n            (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : ((tries) => {\n                return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\n            });\n        switch (this.vsn) {\n            case constants_1.VSN_1_0_0:\n                this.encode =\n                    (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : ((payload, callback) => {\n                        return callback(JSON.stringify(payload));\n                    });\n                this.decode =\n                    (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : ((payload, callback) => {\n                        return callback(JSON.parse(payload));\n                    });\n                break;\n            case constants_1.VSN_2_0_0:\n                this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);\n                this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);\n                break;\n            default:\n                throw new Error(`Unsupported serializer version: ${this.vsn}`);\n        }\n        // Handle worker setup\n        if (this.worker) {\n            if (typeof window !== 'undefined' && !window.Worker) {\n                throw new Error('Web Worker is not supported');\n            }\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n    }\n}\nexports.default = RealtimeClient;\n//# sourceMappingURL=RealtimeClient.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$supabase$realtime_js$dist$main$lib$timer","~$module$node_modules$$supabase$realtime_js$dist$main$RealtimeChannel","~$module$node_modules$tslib$tslib","~$module$node_modules$$supabase$realtime_js$dist$main$lib$websocket_factory","~$module$node_modules$$supabase$realtime_js$dist$main$lib$transformers","~$shadow.js","~$module$node_modules$$supabase$realtime_js$dist$main$lib$constants","~$module$node_modules$$supabase$realtime_js$dist$main$lib$serializer"]],"~:properties",["^5",["_authPromise","message","transport","fetch","heartbeatCallback","reconnectTimer","reconnectAfterMs","onerror","onclose","_connectionState","config","workerRef","workerUrl","logLevel","params","binaryType","vsn","accessTokenValue","decode","sendBuffer","access_token","__esModule","conn","error","event","_heartbeatSentAt","log_level","value","interval","timeout","accessToken","logger","apiKey","close","serializer","httpEndpoint","type","onopen","pendingHeartbeatRef","heartbeatIntervalMs","ref","version","stateChangeCallbacks","_manuallySetToken","endPoint","open","payload","encode","default","onmessage","_wasManualDisconnect","heartbeatTimer","channels","topic","_resolveFetch","headers","worker"]],"~:compiled-at",1771991938826,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$realtime_js$dist$main$RealtimeClient.js\",\n\"lineCount\":25,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js\"],\n\"sourcesContent\":[\"shadow$provide[29] = function(require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nconst tslib_1 = require(\\\"tslib\\\");\\nconst websocket_factory_1 = tslib_1.__importDefault(require(\\\"./lib/websocket-factory\\\"));\\nconst constants_1 = require(\\\"./lib/constants\\\");\\nconst serializer_1 = tslib_1.__importDefault(require(\\\"./lib/serializer\\\"));\\nconst timer_1 = tslib_1.__importDefault(require(\\\"./lib/timer\\\"));\\nconst transformers_1 = require(\\\"./lib/transformers\\\");\\nconst RealtimeChannel_1 = tslib_1.__importDefault(require(\\\"./RealtimeChannel\\\"));\\nconst noop = () => { };\\n// Connection-related constants\\nconst CONNECTION_TIMEOUTS = {\\n    HEARTBEAT_INTERVAL: 25000,\\n    RECONNECT_DELAY: 10,\\n    HEARTBEAT_TIMEOUT_FALLBACK: 100,\\n};\\nconst RECONNECT_INTERVALS = [1000, 2000, 5000, 10000];\\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\\nconst WORKER_SCRIPT = `\\n  addEventListener(\\\"message\\\", (e) => {\\n    if (e.data.event === \\\"start\\\") {\\n      setInterval(() => postMessage({ event: \\\"keepAlive\\\" }), e.data.interval);\\n    }\\n  });`;\\nclass RealtimeClient {\\n    /**\\n     * Initializes the Socket.\\n     *\\n     * @param endPoint The string WebSocket endpoint, ie, \\\"ws://example.com/socket\\\", \\\"wss://example.com\\\", \\\"/socket\\\" (inherited host & protocol)\\n     * @param httpEndpoint The string HTTP endpoint, ie, \\\"https://example.com\\\", \\\"/\\\" (inherited host & protocol)\\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\\n     * @param options.params The optional params to pass when connecting.\\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\\n     * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.\\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\\n     * @param options.logLevel Sets the log level for Realtime\\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\\n     * @param options.vsn The protocol version to use when connecting. Supported versions are \\\"1.0.0\\\" and \\\"2.0.0\\\". Defaults to \\\"2.0.0\\\".\\n     * @example\\n     * ```ts\\n     * import RealtimeClient from '@supabase/realtime-js'\\n     *\\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\\n     *   params: { apikey: 'public-anon-key' },\\n     * })\\n     * client.connect()\\n     * ```\\n     */\\n    constructor(endPoint, options) {\\n        var _a;\\n        this.accessTokenValue = null;\\n        this.apiKey = null;\\n        this._manuallySetToken = false;\\n        this.channels = new Array();\\n        this.endPoint = '';\\n        this.httpEndpoint = '';\\n        /** @deprecated headers cannot be set on websocket connections */\\n        this.headers = {};\\n        this.params = {};\\n        this.timeout = constants_1.DEFAULT_TIMEOUT;\\n        this.transport = null;\\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\\n        this.heartbeatTimer = undefined;\\n        this.pendingHeartbeatRef = null;\\n        this.heartbeatCallback = noop;\\n        this.ref = 0;\\n        this.reconnectTimer = null;\\n        this.vsn = constants_1.DEFAULT_VSN;\\n        this.logger = noop;\\n        this.conn = null;\\n        this.sendBuffer = [];\\n        this.serializer = new serializer_1.default();\\n        this.stateChangeCallbacks = {\\n            open: [],\\n            close: [],\\n            error: [],\\n            message: [],\\n        };\\n        this.accessToken = null;\\n        this._connectionState = 'disconnected';\\n        this._wasManualDisconnect = false;\\n        this._authPromise = null;\\n        this._heartbeatSentAt = null;\\n        /**\\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\\n         *\\n         * @internal\\n         */\\n        this._resolveFetch = (customFetch) => {\\n            if (customFetch) {\\n                return (...args) => customFetch(...args);\\n            }\\n            return (...args) => fetch(...args);\\n        };\\n        // Validate required parameters\\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\\n            throw new Error('API key is required to connect to Realtime');\\n        }\\n        this.apiKey = options.params.apikey;\\n        // Initialize endpoint URLs\\n        this.endPoint = `${endPoint}/${constants_1.TRANSPORTS.websocket}`;\\n        this.httpEndpoint = (0, transformers_1.httpEndpointURL)(endPoint);\\n        this._initializeOptions(options);\\n        this._setupReconnectionTimer();\\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\\n    }\\n    /**\\n     * Connects the socket, unless already connected.\\n     */\\n    connect() {\\n        // Skip if already connecting, disconnecting, or connected\\n        if (this.isConnecting() ||\\n            this.isDisconnecting() ||\\n            (this.conn !== null && this.isConnected())) {\\n            return;\\n        }\\n        this._setConnectionState('connecting');\\n        // Trigger auth if needed and not already in progress\\n        // This ensures auth is called for standalone RealtimeClient usage\\n        // while avoiding race conditions with SupabaseClient's immediate setAuth call\\n        if (this.accessToken && !this._authPromise) {\\n            this._setAuthSafely('connect');\\n        }\\n        // Establish WebSocket connection\\n        if (this.transport) {\\n            // Use custom transport if provided\\n            this.conn = new this.transport(this.endpointURL());\\n        }\\n        else {\\n            // Try to use native WebSocket\\n            try {\\n                this.conn = websocket_factory_1.default.createWebSocket(this.endpointURL());\\n            }\\n            catch (error) {\\n                this._setConnectionState('disconnected');\\n                const errorMessage = error.message;\\n                // Provide helpful error message based on environment\\n                if (errorMessage.includes('Node.js')) {\\n                    throw new Error(`${errorMessage}\\\\n\\\\n` +\\n                        'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\\\n\\\\n' +\\n                        'Option 1: Use Node.js 22+ which has native WebSocket support\\\\n' +\\n                        'Option 2: Install and provide the \\\"ws\\\" package:\\\\n\\\\n' +\\n                        '  npm install ws\\\\n\\\\n' +\\n                        '  import ws from \\\"ws\\\"\\\\n' +\\n                        '  const client = new RealtimeClient(url, {\\\\n' +\\n                        '    ...options,\\\\n' +\\n                        '    transport: ws\\\\n' +\\n                        '  })');\\n                }\\n                throw new Error(`WebSocket not available: ${errorMessage}`);\\n            }\\n        }\\n        this._setupConnectionHandlers();\\n    }\\n    /**\\n     * Returns the URL of the websocket.\\n     * @returns string The URL of the websocket.\\n     */\\n    endpointURL() {\\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: this.vsn }));\\n    }\\n    /**\\n     * Disconnects the socket.\\n     *\\n     * @param code A numeric status code to send on disconnect.\\n     * @param reason A custom reason for the disconnect.\\n     */\\n    disconnect(code, reason) {\\n        if (this.isDisconnecting()) {\\n            return;\\n        }\\n        this._setConnectionState('disconnecting', true);\\n        if (this.conn) {\\n            // Setup fallback timer to prevent hanging in disconnecting state\\n            const fallbackTimer = setTimeout(() => {\\n                this._setConnectionState('disconnected');\\n            }, 100);\\n            this.conn.onclose = () => {\\n                clearTimeout(fallbackTimer);\\n                this._setConnectionState('disconnected');\\n            };\\n            // Close the WebSocket connection if close method exists\\n            if (typeof this.conn.close === 'function') {\\n                if (code) {\\n                    this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\\n                }\\n                else {\\n                    this.conn.close();\\n                }\\n            }\\n            this._teardownConnection();\\n        }\\n        else {\\n            this._setConnectionState('disconnected');\\n        }\\n    }\\n    /**\\n     * Returns all created channels\\n     */\\n    getChannels() {\\n        return this.channels;\\n    }\\n    /**\\n     * Unsubscribes and removes a single channel\\n     * @param channel A RealtimeChannel instance\\n     */\\n    async removeChannel(channel) {\\n        const status = await channel.unsubscribe();\\n        if (this.channels.length === 0) {\\n            this.disconnect();\\n        }\\n        return status;\\n    }\\n    /**\\n     * Unsubscribes and removes all channels\\n     */\\n    async removeAllChannels() {\\n        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));\\n        this.channels = [];\\n        this.disconnect();\\n        return values_1;\\n    }\\n    /**\\n     * Logs the message.\\n     *\\n     * For customized logging, `this.logger` can be overridden.\\n     */\\n    log(kind, msg, data) {\\n        this.logger(kind, msg, data);\\n    }\\n    /**\\n     * Returns the current state of the socket.\\n     */\\n    connectionState() {\\n        switch (this.conn && this.conn.readyState) {\\n            case constants_1.SOCKET_STATES.connecting:\\n                return constants_1.CONNECTION_STATE.Connecting;\\n            case constants_1.SOCKET_STATES.open:\\n                return constants_1.CONNECTION_STATE.Open;\\n            case constants_1.SOCKET_STATES.closing:\\n                return constants_1.CONNECTION_STATE.Closing;\\n            default:\\n                return constants_1.CONNECTION_STATE.Closed;\\n        }\\n    }\\n    /**\\n     * Returns `true` is the connection is open.\\n     */\\n    isConnected() {\\n        return this.connectionState() === constants_1.CONNECTION_STATE.Open;\\n    }\\n    /**\\n     * Returns `true` if the connection is currently connecting.\\n     */\\n    isConnecting() {\\n        return this._connectionState === 'connecting';\\n    }\\n    /**\\n     * Returns `true` if the connection is currently disconnecting.\\n     */\\n    isDisconnecting() {\\n        return this._connectionState === 'disconnecting';\\n    }\\n    /**\\n     * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.\\n     *\\n     * Topics are automatically prefixed with `realtime:` to match the Realtime service.\\n     * If a channel with the same topic already exists it will be returned instead of creating\\n     * a duplicate connection.\\n     */\\n    channel(topic, params = { config: {} }) {\\n        const realtimeTopic = `realtime:${topic}`;\\n        const exists = this.getChannels().find((c) => c.topic === realtimeTopic);\\n        if (!exists) {\\n            const chan = new RealtimeChannel_1.default(`realtime:${topic}`, params, this);\\n            this.channels.push(chan);\\n            return chan;\\n        }\\n        else {\\n            return exists;\\n        }\\n    }\\n    /**\\n     * Push out a message if the socket is connected.\\n     *\\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\\n     */\\n    push(data) {\\n        const { topic, event, payload, ref } = data;\\n        const callback = () => {\\n            this.encode(data, (result) => {\\n                var _a;\\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\\n            });\\n        };\\n        this.log('push', `${topic} ${event} (${ref})`, payload);\\n        if (this.isConnected()) {\\n            callback();\\n        }\\n        else {\\n            this.sendBuffer.push(callback);\\n        }\\n    }\\n    /**\\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\\n     *\\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\\n     *\\n     * On callback used, it will set the value of the token internal to the client.\\n     *\\n     * When a token is explicitly provided, it will be preserved across channel operations\\n     * (including removeChannel and resubscribe). The `accessToken` callback will not be\\n     * invoked until `setAuth()` is called without arguments.\\n     *\\n     * @param token A JWT string to override the token set on the client.\\n     *\\n     * @example\\n     * // Use a manual token (preserved across resubscribes, ignores accessToken callback)\\n     * client.realtime.setAuth('my-custom-jwt')\\n     *\\n     * // Switch back to using the accessToken callback\\n     * client.realtime.setAuth()\\n     */\\n    async setAuth(token = null) {\\n        this._authPromise = this._performAuth(token);\\n        try {\\n            await this._authPromise;\\n        }\\n        finally {\\n            this._authPromise = null;\\n        }\\n    }\\n    /**\\n     * Returns true if the current access token was explicitly set via setAuth(token),\\n     * false if it was obtained via the accessToken callback.\\n     * @internal\\n     */\\n    _isManualToken() {\\n        return this._manuallySetToken;\\n    }\\n    /**\\n     * Sends a heartbeat message if the socket is connected.\\n     */\\n    async sendHeartbeat() {\\n        var _a;\\n        if (!this.isConnected()) {\\n            try {\\n                this.heartbeatCallback('disconnected');\\n            }\\n            catch (e) {\\n                this.log('error', 'error in heartbeat callback', e);\\n            }\\n            return;\\n        }\\n        // Handle heartbeat timeout and force reconnection if needed\\n        if (this.pendingHeartbeatRef) {\\n            this.pendingHeartbeatRef = null;\\n            this._heartbeatSentAt = null;\\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\\n            try {\\n                this.heartbeatCallback('timeout');\\n            }\\n            catch (e) {\\n                this.log('error', 'error in heartbeat callback', e);\\n            }\\n            // Force reconnection after heartbeat timeout\\n            this._wasManualDisconnect = false;\\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(constants_1.WS_CLOSE_NORMAL, 'heartbeat timeout');\\n            setTimeout(() => {\\n                var _a;\\n                if (!this.isConnected()) {\\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\\n                }\\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\\n            return;\\n        }\\n        // Send heartbeat message to server\\n        this._heartbeatSentAt = Date.now();\\n        this.pendingHeartbeatRef = this._makeRef();\\n        this.push({\\n            topic: 'phoenix',\\n            event: 'heartbeat',\\n            payload: {},\\n            ref: this.pendingHeartbeatRef,\\n        });\\n        try {\\n            this.heartbeatCallback('sent');\\n        }\\n        catch (e) {\\n            this.log('error', 'error in heartbeat callback', e);\\n        }\\n        this._setAuthSafely('heartbeat');\\n    }\\n    /**\\n     * Sets a callback that receives lifecycle events for internal heartbeat messages.\\n     * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).\\n     */\\n    onHeartbeat(callback) {\\n        this.heartbeatCallback = callback;\\n    }\\n    /**\\n     * Flushes send buffer\\n     */\\n    flushSendBuffer() {\\n        if (this.isConnected() && this.sendBuffer.length > 0) {\\n            this.sendBuffer.forEach((callback) => callback());\\n            this.sendBuffer = [];\\n        }\\n    }\\n    /**\\n     * Return the next message ref, accounting for overflows\\n     *\\n     * @internal\\n     */\\n    _makeRef() {\\n        let newRef = this.ref + 1;\\n        if (newRef === this.ref) {\\n            this.ref = 0;\\n        }\\n        else {\\n            this.ref = newRef;\\n        }\\n        return this.ref.toString();\\n    }\\n    /**\\n     * Unsubscribe from channels with the specified topic.\\n     *\\n     * @internal\\n     */\\n    _leaveOpenTopic(topic) {\\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\\n        if (dupChannel) {\\n            this.log('transport', `leaving duplicate topic \\\"${topic}\\\"`);\\n            dupChannel.unsubscribe();\\n        }\\n    }\\n    /**\\n     * Removes a subscription from the socket.\\n     *\\n     * @param channel An open subscription.\\n     *\\n     * @internal\\n     */\\n    _remove(channel) {\\n        this.channels = this.channels.filter((c) => c.topic !== channel.topic);\\n    }\\n    /** @internal */\\n    _onConnMessage(rawMessage) {\\n        this.decode(rawMessage.data, (msg) => {\\n            // Handle heartbeat responses\\n            if (msg.topic === 'phoenix' &&\\n                msg.event === 'phx_reply' &&\\n                msg.ref &&\\n                msg.ref === this.pendingHeartbeatRef) {\\n                const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : undefined;\\n                try {\\n                    this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error', latency);\\n                }\\n                catch (e) {\\n                    this.log('error', 'error in heartbeat callback', e);\\n                }\\n                this._heartbeatSentAt = null;\\n                this.pendingHeartbeatRef = null;\\n            }\\n            // Log incoming message\\n            const { topic, event, payload, ref } = msg;\\n            const refString = ref ? `(${ref})` : '';\\n            const status = payload.status || '';\\n            this.log('receive', `${status} ${topic} ${event} ${refString}`.trim(), payload);\\n            // Route message to appropriate channels\\n            this.channels\\n                .filter((channel) => channel._isMember(topic))\\n                .forEach((channel) => channel._trigger(event, payload, ref));\\n            this._triggerStateCallbacks('message', msg);\\n        });\\n    }\\n    /**\\n     * Clear specific timer\\n     * @internal\\n     */\\n    _clearTimer(timer) {\\n        var _a;\\n        if (timer === 'heartbeat' && this.heartbeatTimer) {\\n            clearInterval(this.heartbeatTimer);\\n            this.heartbeatTimer = undefined;\\n        }\\n        else if (timer === 'reconnect') {\\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\\n        }\\n    }\\n    /**\\n     * Clear all timers\\n     * @internal\\n     */\\n    _clearAllTimers() {\\n        this._clearTimer('heartbeat');\\n        this._clearTimer('reconnect');\\n    }\\n    /**\\n     * Setup connection handlers for WebSocket events\\n     * @internal\\n     */\\n    _setupConnectionHandlers() {\\n        if (!this.conn)\\n            return;\\n        // Set binary type if supported (browsers and most WebSocket implementations)\\n        if ('binaryType' in this.conn) {\\n            ;\\n            this.conn.binaryType = 'arraybuffer';\\n        }\\n        this.conn.onopen = () => this._onConnOpen();\\n        this.conn.onerror = (error) => this._onConnError(error);\\n        this.conn.onmessage = (event) => this._onConnMessage(event);\\n        this.conn.onclose = (event) => this._onConnClose(event);\\n        if (this.conn.readyState === constants_1.SOCKET_STATES.open) {\\n            this._onConnOpen();\\n        }\\n    }\\n    /**\\n     * Teardown connection and cleanup resources\\n     * @internal\\n     */\\n    _teardownConnection() {\\n        if (this.conn) {\\n            if (this.conn.readyState === constants_1.SOCKET_STATES.open ||\\n                this.conn.readyState === constants_1.SOCKET_STATES.connecting) {\\n                try {\\n                    this.conn.close();\\n                }\\n                catch (e) {\\n                    this.log('error', 'Error closing connection', e);\\n                }\\n            }\\n            this.conn.onopen = null;\\n            this.conn.onerror = null;\\n            this.conn.onmessage = null;\\n            this.conn.onclose = null;\\n            this.conn = null;\\n        }\\n        this._clearAllTimers();\\n        this._terminateWorker();\\n        this.channels.forEach((channel) => channel.teardown());\\n    }\\n    /** @internal */\\n    _onConnOpen() {\\n        this._setConnectionState('connected');\\n        this.log('transport', `connected to ${this.endpointURL()}`);\\n        // Wait for any pending auth operations before flushing send buffer\\n        // This ensures channel join messages include the correct access token\\n        const authPromise = this._authPromise ||\\n            (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());\\n        authPromise\\n            .then(() => {\\n            this.flushSendBuffer();\\n        })\\n            .catch((e) => {\\n            this.log('error', 'error waiting for auth on connect', e);\\n            // Proceed anyway to avoid hanging connections\\n            this.flushSendBuffer();\\n        });\\n        this._clearTimer('reconnect');\\n        if (!this.worker) {\\n            this._startHeartbeat();\\n        }\\n        else {\\n            if (!this.workerRef) {\\n                this._startWorkerHeartbeat();\\n            }\\n        }\\n        this._triggerStateCallbacks('open');\\n    }\\n    /** @internal */\\n    _startHeartbeat() {\\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\\n        this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\\n    }\\n    /** @internal */\\n    _startWorkerHeartbeat() {\\n        if (this.workerUrl) {\\n            this.log('worker', `starting worker for from ${this.workerUrl}`);\\n        }\\n        else {\\n            this.log('worker', `starting default worker`);\\n        }\\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\\n        this.workerRef = new Worker(objectUrl);\\n        this.workerRef.onerror = (error) => {\\n            this.log('worker', 'worker error', error.message);\\n            this._terminateWorker();\\n        };\\n        this.workerRef.onmessage = (event) => {\\n            if (event.data.event === 'keepAlive') {\\n                this.sendHeartbeat();\\n            }\\n        };\\n        this.workerRef.postMessage({\\n            event: 'start',\\n            interval: this.heartbeatIntervalMs,\\n        });\\n    }\\n    /**\\n     * Terminate the Web Worker and clear the reference\\n     * @internal\\n     */\\n    _terminateWorker() {\\n        if (this.workerRef) {\\n            this.log('worker', 'terminating worker');\\n            this.workerRef.terminate();\\n            this.workerRef = undefined;\\n        }\\n    }\\n    /** @internal */\\n    _onConnClose(event) {\\n        var _a;\\n        this._setConnectionState('disconnected');\\n        this.log('transport', 'close', event);\\n        this._triggerChanError();\\n        this._clearTimer('heartbeat');\\n        // Only schedule reconnection if it wasn't a manual disconnect\\n        if (!this._wasManualDisconnect) {\\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\\n        }\\n        this._triggerStateCallbacks('close', event);\\n    }\\n    /** @internal */\\n    _onConnError(error) {\\n        this._setConnectionState('disconnected');\\n        this.log('transport', `${error}`);\\n        this._triggerChanError();\\n        this._triggerStateCallbacks('error', error);\\n        try {\\n            this.heartbeatCallback('error');\\n        }\\n        catch (e) {\\n            this.log('error', 'error in heartbeat callback', e);\\n        }\\n    }\\n    /** @internal */\\n    _triggerChanError() {\\n        this.channels.forEach((channel) => channel._trigger(constants_1.CHANNEL_EVENTS.error));\\n    }\\n    /** @internal */\\n    _appendParams(url, params) {\\n        if (Object.keys(params).length === 0) {\\n            return url;\\n        }\\n        const prefix = url.match(/\\\\?/) ? '&' : '?';\\n        const query = new URLSearchParams(params);\\n        return `${url}${prefix}${query}`;\\n    }\\n    _workerObjectUrl(url) {\\n        let result_url;\\n        if (url) {\\n            result_url = url;\\n        }\\n        else {\\n            const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });\\n            result_url = URL.createObjectURL(blob);\\n        }\\n        return result_url;\\n    }\\n    /**\\n     * Set connection state with proper state management\\n     * @internal\\n     */\\n    _setConnectionState(state, manual = false) {\\n        this._connectionState = state;\\n        if (state === 'connecting') {\\n            this._wasManualDisconnect = false;\\n        }\\n        else if (state === 'disconnecting') {\\n            this._wasManualDisconnect = manual;\\n        }\\n    }\\n    /**\\n     * Perform the actual auth operation\\n     * @internal\\n     */\\n    async _performAuth(token = null) {\\n        let tokenToSend;\\n        let isManualToken = false;\\n        if (token) {\\n            tokenToSend = token;\\n            // Track if this is a manually-provided token\\n            isManualToken = true;\\n        }\\n        else if (this.accessToken) {\\n            // Call the accessToken callback to get fresh token\\n            try {\\n                tokenToSend = await this.accessToken();\\n            }\\n            catch (e) {\\n                this.log('error', 'Error fetching access token from callback', e);\\n                // Fall back to cached value if callback fails\\n                tokenToSend = this.accessTokenValue;\\n            }\\n        }\\n        else {\\n            tokenToSend = this.accessTokenValue;\\n        }\\n        // Track whether this token was manually set or fetched via callback\\n        if (isManualToken) {\\n            this._manuallySetToken = true;\\n        }\\n        else if (this.accessToken) {\\n            // If we used the callback, clear the manual flag\\n            this._manuallySetToken = false;\\n        }\\n        if (this.accessTokenValue != tokenToSend) {\\n            this.accessTokenValue = tokenToSend;\\n            this.channels.forEach((channel) => {\\n                const payload = {\\n                    access_token: tokenToSend,\\n                    version: constants_1.DEFAULT_VERSION,\\n                };\\n                tokenToSend && channel.updateJoinPayload(payload);\\n                if (channel.joinedOnce && channel._isJoined()) {\\n                    channel._push(constants_1.CHANNEL_EVENTS.access_token, {\\n                        access_token: tokenToSend,\\n                    });\\n                }\\n            });\\n        }\\n    }\\n    /**\\n     * Wait for any in-flight auth operations to complete\\n     * @internal\\n     */\\n    async _waitForAuthIfNeeded() {\\n        if (this._authPromise) {\\n            await this._authPromise;\\n        }\\n    }\\n    /**\\n     * Safely call setAuth with standardized error handling\\n     * @internal\\n     */\\n    _setAuthSafely(context = 'general') {\\n        // Only refresh auth if using callback-based tokens\\n        if (!this._isManualToken()) {\\n            this.setAuth().catch((e) => {\\n                this.log('error', `Error setting auth in ${context}`, e);\\n            });\\n        }\\n    }\\n    /**\\n     * Trigger state change callbacks with proper error handling\\n     * @internal\\n     */\\n    _triggerStateCallbacks(event, data) {\\n        try {\\n            this.stateChangeCallbacks[event].forEach((callback) => {\\n                try {\\n                    callback(data);\\n                }\\n                catch (e) {\\n                    this.log('error', `error in ${event} callback`, e);\\n                }\\n            });\\n        }\\n        catch (e) {\\n            this.log('error', `error triggering ${event} callbacks`, e);\\n        }\\n    }\\n    /**\\n     * Setup reconnection timer with proper configuration\\n     * @internal\\n     */\\n    _setupReconnectionTimer() {\\n        this.reconnectTimer = new timer_1.default(async () => {\\n            setTimeout(async () => {\\n                await this._waitForAuthIfNeeded();\\n                if (!this.isConnected()) {\\n                    this.connect();\\n                }\\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\\n        }, this.reconnectAfterMs);\\n    }\\n    /**\\n     * Initialize client options with defaults\\n     * @internal\\n     */\\n    _initializeOptions(options) {\\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\\n        // Set defaults\\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_TIMEOUT;\\n        this.heartbeatIntervalMs =\\n            (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\\n        this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : constants_1.DEFAULT_VSN;\\n        // Handle special cases\\n        if (options === null || options === void 0 ? void 0 : options.params)\\n            this.params = options.params;\\n        if (options === null || options === void 0 ? void 0 : options.logger)\\n            this.logger = options.logger;\\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\\n            this.logLevel = options.logLevel || options.log_level;\\n            this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });\\n        }\\n        // Set up functions with defaults\\n        this.reconnectAfterMs =\\n            (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : ((tries) => {\\n                return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\\n            });\\n        switch (this.vsn) {\\n            case constants_1.VSN_1_0_0:\\n                this.encode =\\n                    (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : ((payload, callback) => {\\n                        return callback(JSON.stringify(payload));\\n                    });\\n                this.decode =\\n                    (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : ((payload, callback) => {\\n                        return callback(JSON.parse(payload));\\n                    });\\n                break;\\n            case constants_1.VSN_2_0_0:\\n                this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);\\n                this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);\\n                break;\\n            default:\\n                throw new Error(`Unsupported serializer version: ${this.vsn}`);\\n        }\\n        // Handle worker setup\\n        if (this.worker) {\\n            if (typeof window !== 'undefined' && !window.Worker) {\\n                throw new Error('Web Worker is not supported');\\n            }\\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\\n        }\\n    }\\n}\\nexports.default = RealtimeClient;\\n//# sourceMappingURL=RealtimeClient.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"tslib_1\",\"websocket_factory_1\",\"__importDefault\",\"constants_1\",\"serializer_1\",\"timer_1\",\"transformers_1\",\"RealtimeChannel_1\",\"noop\",\"RECONNECT_INTERVALS\",\"RealtimeClient\",\"constructor\",\"endPoint\",\"options\",\"_a\",\"apiKey\",\"accessTokenValue\",\"_manuallySetToken\",\"channels\",\"httpEndpoint\",\"headers\",\"params\",\"timeout\",\"DEFAULT_TIMEOUT\",\"transport\",\"heartbeatIntervalMs\",\"HEARTBEAT_INTERVAL\",\"heartbeatTimer\",\"undefined\",\"pendingHeartbeatRef\",\"heartbeatCallback\",\"ref\",\"reconnectTimer\",\"vsn\",\"DEFAULT_VSN\",\"logger\",\"conn\",\"sendBuffer\",\"serializer\",\"default\",\"stateChangeCallbacks\",\"open\",\"close\",\"error\",\"message\",\"accessToken\",\"_connectionState\",\"_wasManualDisconnect\",\"_heartbeatSentAt\",\"_authPromise\",\"_resolveFetch\",\"customFetch\",\"this._resolveFetch\",\"args\",\"fetch\",\"apikey\",\"Error\",\"TRANSPORTS\",\"websocket\",\"httpEndpointURL\",\"_initializeOptions\",\"_setupReconnectionTimer\",\"connect\",\"isConnecting\",\"isDisconnecting\",\"isConnected\",\"_setConnectionState\",\"_setAuthSafely\",\"endpointURL\",\"createWebSocket\",\"errorMessage\",\"includes\",\"_setupConnectionHandlers\",\"_appendParams\",\"assign\",\"disconnect\",\"code\",\"reason\",\"fallbackTimer\",\"setTimeout\",\"onclose\",\"this.conn.onclose\",\"clearTimeout\",\"_teardownConnection\",\"getChannels\",\"removeChannel\",\"channel\",\"status\",\"unsubscribe\",\"length\",\"removeAllChannels\",\"values_1\",\"Promise\",\"all\",\"map\",\"log\",\"kind\",\"msg\",\"data\",\"connectionState\",\"readyState\",\"SOCKET_STATES\",\"connecting\",\"CONNECTION_STATE\",\"Connecting\",\"Open\",\"closing\",\"Closing\",\"Closed\",\"topic\",\"config\",\"realtimeTopic\",\"exists\",\"find\",\"c\",\"chan\",\"push\",\"event\",\"payload\",\"callback\",\"encode\",\"result\",\"send\",\"setAuth\",\"token\",\"_performAuth\",\"_isManualToken\",\"sendHeartbeat\",\"e\",\"WS_CLOSE_NORMAL\",\"scheduleTimeout\",\"HEARTBEAT_TIMEOUT_FALLBACK\",\"Date\",\"now\",\"_makeRef\",\"onHeartbeat\",\"flushSendBuffer\",\"forEach\",\"newRef\",\"toString\",\"_leaveOpenTopic\",\"dupChannel\",\"_isJoined\",\"_isJoining\",\"_remove\",\"filter\",\"_onConnMessage\",\"rawMessage\",\"decode\",\"latency\",\"refString\",\"trim\",\"_isMember\",\"_trigger\",\"_triggerStateCallbacks\",\"_clearTimer\",\"timer\",\"clearInterval\",\"reset\",\"_clearAllTimers\",\"binaryType\",\"onopen\",\"this.conn.onopen\",\"_onConnOpen\",\"onerror\",\"this.conn.onerror\",\"_onConnError\",\"onmessage\",\"this.conn.onmessage\",\"_onConnClose\",\"_terminateWorker\",\"teardown\",\"then\",\"resolve\",\"catch\",\"worker\",\"workerRef\",\"_startWorkerHeartbeat\",\"_startHeartbeat\",\"setInterval\",\"workerUrl\",\"objectUrl\",\"_workerObjectUrl\",\"Worker\",\"this.workerRef.onerror\",\"this.workerRef.onmessage\",\"postMessage\",\"interval\",\"terminate\",\"_triggerChanError\",\"CHANNEL_EVENTS\",\"url\",\"keys\",\"prefix\",\"match\",\"query\",\"URLSearchParams\",\"blob\",\"Blob\",\"WORKER_SCRIPT\",\"type\",\"result_url\",\"URL\",\"createObjectURL\",\"state\",\"manual\",\"tokenToSend\",\"isManualToken\",\"access_token\",\"version\",\"DEFAULT_VERSION\",\"updateJoinPayload\",\"joinedOnce\",\"_push\",\"_waitForAuthIfNeeded\",\"context\",\"RECONNECT_DELAY\",\"reconnectAfterMs\",\"_b\",\"_c\",\"_d\",\"_e\",\"_f\",\"_g\",\"_h\",\"_j\",\"_k\",\"_l\",\"_m\",\"logLevel\",\"log_level\",\"tries\",\"DEFAULT_RECONNECT_FALLBACK\",\"VSN_1_0_0\",\"JSON\",\"stringify\",\"parse\",\"VSN_2_0_0\",\"bind\",\"window\"]\n}\n"]