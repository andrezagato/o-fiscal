["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js"],"~:js","shadow$provide[29]=function(S,ka,a){Object.defineProperty(a,\"__esModule\",{value:!0});ka=S(14);const I=ka.__importDefault(S(20)),q=S(22),D=ka.__importDefault(S(23)),C=ka.__importDefault(S(24)),G=S(25),E=ka.__importDefault(S(28)),M=()=>{},d=[1E3,2E3,5E3,1E4];class K{constructor(p,k){var y;this.apiKey=this.accessTokenValue=null;this._manuallySetToken=!1;this.channels=[];this.httpEndpoint=this.endPoint=\"\";this.headers={};this.params={};this.timeout=q.DEFAULT_TIMEOUT;this.transport=null;this.heartbeatIntervalMs=\n25E3;this.heartbeatTimer=void 0;this.pendingHeartbeatRef=null;this.heartbeatCallback=M;this.ref=0;this.reconnectTimer=null;this.vsn=q.DEFAULT_VSN;this.logger=M;this.conn=null;this.sendBuffer=[];this.serializer=new D.default;this.stateChangeCallbacks={open:[],close:[],error:[],message:[]};this.accessToken=null;this._connectionState=\"disconnected\";this._wasManualDisconnect=!1;this._heartbeatSentAt=this._authPromise=null;this._resolveFetch=v=>v?(...z)=>v(...z):(...z)=>fetch(...z);if((y=k===null||k===\nvoid 0?void 0:k.params)===null||y===void 0||!y.apikey)throw Error(\"API key is required to connect to Realtime\");this.apiKey=k.params.apikey;this.endPoint=`${p}/${q.TRANSPORTS.websocket}`;this.httpEndpoint=(0,G.httpEndpointURL)(p);this._initializeOptions(k);this._setupReconnectionTimer();this.fetch=this._resolveFetch(k===null||k===void 0?void 0:k.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){this._setConnectionState(\"connecting\");this.accessToken&&\n!this._authPromise&&this._setAuthSafely(\"connect\");if(this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=I.default.createWebSocket(this.endpointURL())}catch(p){this._setConnectionState(\"disconnected\");const k=p.message;if(k.includes(\"Node.js\"))throw Error(`${k}\\n\\n`+'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\nOption 1: Use Node.js 22+ which has native WebSocket support\\nOption 2: Install and provide the \"ws\" package:\\n\\n  npm install ws\\n\\n  import ws from \"ws\"\\n  const client \\x3d new RealtimeClient(url, {\\n    ...options,\\n    transport: ws\\n  })');\nthrow Error(`WebSocket not available: ${k}`);}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(p,k){if(!this.isDisconnecting())if(this._setConnectionState(\"disconnecting\",!0),this.conn){const y=setTimeout(()=>{this._setConnectionState(\"disconnected\")},100);this.conn.onclose=()=>{clearTimeout(y);this._setConnectionState(\"disconnected\")};typeof this.conn.close===\"function\"&&(p?this.conn.close(p,k!==null&&\nk!==void 0?k:\"\"):this.conn.close());this._teardownConnection()}else this._setConnectionState(\"disconnected\")}getChannels(){return this.channels}async removeChannel(p){p=await p.unsubscribe();this.channels.length===0&&this.disconnect();return p}async removeAllChannels(){const p=await Promise.all(this.channels.map(k=>k.unsubscribe()));this.channels=[];this.disconnect();return p}log(p,k,y){this.logger(p,k,y)}connectionState(){switch(this.conn&&this.conn.readyState){case q.SOCKET_STATES.connecting:return q.CONNECTION_STATE.Connecting;\ncase q.SOCKET_STATES.open:return q.CONNECTION_STATE.Open;case q.SOCKET_STATES.closing:return q.CONNECTION_STATE.Closing;default:return q.CONNECTION_STATE.Closed}}isConnected(){return this.connectionState()===q.CONNECTION_STATE.Open}isConnecting(){return this._connectionState===\"connecting\"}isDisconnecting(){return this._connectionState===\"disconnecting\"}channel(p,k={config:{}}){const y=`realtime:${p}`,v=this.getChannels().find(z=>z.topic===y);if(v)return v;p=new E.default(`realtime:${p}`,k,this);\nthis.channels.push(p);return p}push(p){const {topic:k,event:y,payload:v,ref:z}=p,J=()=>{this.encode(p,l=>{var t;(t=this.conn)===null||t===void 0||t.send(l)})};this.log(\"push\",`${k} ${y} (${z})`,v);this.isConnected()?J():this.sendBuffer.push(J)}async setAuth(p=null){this._authPromise=this._performAuth(p);try{await this._authPromise}finally{this._authPromise=null}}_isManualToken(){return this._manuallySetToken}async sendHeartbeat(){var p;if(this.isConnected())if(this.pendingHeartbeatRef){this._heartbeatSentAt=\nthis.pendingHeartbeatRef=null;this.log(\"transport\",\"heartbeat timeout. Attempting to re-establish connection\");try{this.heartbeatCallback(\"timeout\")}catch(k){this.log(\"error\",\"error in heartbeat callback\",k)}this._wasManualDisconnect=!1;(p=this.conn)===null||p===void 0||p.close(q.WS_CLOSE_NORMAL,\"heartbeat timeout\");setTimeout(()=>{var k;this.isConnected()||(k=this.reconnectTimer)===null||k===void 0||k.scheduleTimeout()},100)}else{this._heartbeatSentAt=Date.now();this.pendingHeartbeatRef=this._makeRef();\nthis.push({topic:\"phoenix\",event:\"heartbeat\",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback(\"sent\")}catch(k){this.log(\"error\",\"error in heartbeat callback\",k)}this._setAuthSafely(\"heartbeat\")}else try{this.heartbeatCallback(\"disconnected\")}catch(k){this.log(\"error\",\"error in heartbeat callback\",k)}}onHeartbeat(p){this.heartbeatCallback=p}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(p=>p()),this.sendBuffer=[])}_makeRef(){let p=this.ref+\n1;this.ref=p===this.ref?0:p;return this.ref.toString()}_leaveOpenTopic(p){let k=this.channels.find(y=>y.topic===p&&(y._isJoined()||y._isJoining()));k&&(this.log(\"transport\",`leaving duplicate topic \"${p}\"`),k.unsubscribe())}_remove(p){this.channels=this.channels.filter(k=>k.topic!==p.topic)}_onConnMessage(p){this.decode(p.data,k=>{if(k.topic===\"phoenix\"&&k.event===\"phx_reply\"&&k.ref&&k.ref===this.pendingHeartbeatRef){const l=this._heartbeatSentAt?Date.now()-this._heartbeatSentAt:void 0;try{this.heartbeatCallback(k.payload.status===\n\"ok\"?\"ok\":\"error\",l)}catch(t){this.log(\"error\",\"error in heartbeat callback\",t)}this.pendingHeartbeatRef=this._heartbeatSentAt=null}const {topic:y,event:v,payload:z,ref:J}=k;this.log(\"receive\",`${z.status||\"\"} ${y} ${v} ${J?`(${J})`:\"\"}`.trim(),z);this.channels.filter(l=>l._isMember(y)).forEach(l=>l._trigger(v,z,J));this._triggerStateCallbacks(\"message\",k)})}_clearTimer(p){var k;p===\"heartbeat\"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):p===\"reconnect\"&&((k=\nthis.reconnectTimer)===null||k===void 0||k.reset())}_clearAllTimers(){this._clearTimer(\"heartbeat\");this._clearTimer(\"reconnect\")}_setupConnectionHandlers(){this.conn&&(\"binaryType\"in this.conn&&(this.conn.binaryType=\"arraybuffer\"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=p=>this._onConnError(p),this.conn.onmessage=p=>this._onConnMessage(p),this.conn.onclose=p=>this._onConnClose(p),this.conn.readyState===q.SOCKET_STATES.open&&this._onConnOpen())}_teardownConnection(){if(this.conn){if(this.conn.readyState===\nq.SOCKET_STATES.open||this.conn.readyState===q.SOCKET_STATES.connecting)try{this.conn.close()}catch(p){this.log(\"error\",\"Error closing connection\",p)}this.conn.onopen=null;this.conn.onerror=null;this.conn.onmessage=null;this.conn=this.conn.onclose=null}this._clearAllTimers();this._terminateWorker();this.channels.forEach(p=>p.teardown())}_onConnOpen(){this._setConnectionState(\"connected\");this.log(\"transport\",`connected to ${this.endpointURL()}`);(this._authPromise||(this.accessToken&&!this.accessTokenValue?\nthis.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(p=>{this.log(\"error\",\"error waiting for auth on connect\",p);this.flushSendBuffer()});this._clearTimer(\"reconnect\");this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat();this._triggerStateCallbacks(\"open\")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer);this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?\nthis.log(\"worker\",`starting worker for from ${this.workerUrl}`):this.log(\"worker\",\"starting default worker\");const p=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(p);this.workerRef.onerror=k=>{this.log(\"worker\",\"worker error\",k.message);this._terminateWorker()};this.workerRef.onmessage=k=>{k.data.event===\"keepAlive\"&&this.sendHeartbeat()};this.workerRef.postMessage({event:\"start\",interval:this.heartbeatIntervalMs})}_terminateWorker(){this.workerRef&&(this.log(\"worker\",\"terminating worker\"),\nthis.workerRef.terminate(),this.workerRef=void 0)}_onConnClose(p){var k;this._setConnectionState(\"disconnected\");this.log(\"transport\",\"close\",p);this._triggerChanError();this._clearTimer(\"heartbeat\");this._wasManualDisconnect||(k=this.reconnectTimer)===null||k===void 0||k.scheduleTimeout();this._triggerStateCallbacks(\"close\",p)}_onConnError(p){this._setConnectionState(\"disconnected\");this.log(\"transport\",`${p}`);this._triggerChanError();this._triggerStateCallbacks(\"error\",p);try{this.heartbeatCallback(\"error\")}catch(k){this.log(\"error\",\n\"error in heartbeat callback\",k)}}_triggerChanError(){this.channels.forEach(p=>p._trigger(q.CHANNEL_EVENTS.error))}_appendParams(p,k){if(Object.keys(k).length===0)return p;const y=p.match(/\\?/)?\"\\x26\":\"?\";k=new URLSearchParams(k);return`${p}${y}${k}`}_workerObjectUrl(p){p||(p=new Blob(['\\n  addEventListener(\"message\", (e) \\x3d\\x3e {\\n    if (e.data.event \\x3d\\x3d\\x3d \"start\") {\\n      setInterval(() \\x3d\\x3e postMessage({ event: \"keepAlive\" }), e.data.interval);\\n    }\\n  });'],{type:\"application/javascript\"}),\np=URL.createObjectURL(p));return p}_setConnectionState(p,k=!1){this._connectionState=p;p===\"connecting\"?this._wasManualDisconnect=!1:p===\"disconnecting\"&&(this._wasManualDisconnect=k)}async _performAuth(p=null){let k,y=!1;if(p)k=p,y=!0;else if(this.accessToken)try{k=await this.accessToken()}catch(v){this.log(\"error\",\"Error fetching access token from callback\",v),k=this.accessTokenValue}else k=this.accessTokenValue;y?this._manuallySetToken=!0:this.accessToken&&(this._manuallySetToken=!1);this.accessTokenValue!=\nk&&(this.accessTokenValue=k,this.channels.forEach(v=>{const z={access_token:k,version:q.DEFAULT_VERSION};k&&v.updateJoinPayload(z);v.joinedOnce&&v._isJoined()&&v._push(q.CHANNEL_EVENTS.access_token,{access_token:k})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(p=\"general\"){this._isManualToken()||this.setAuth().catch(k=>{this.log(\"error\",`Error setting auth in ${p}`,k)})}_triggerStateCallbacks(p,k){try{this.stateChangeCallbacks[p].forEach(y=>{try{y(k)}catch(v){this.log(\"error\",\n`error in ${p} callback`,v)}})}catch(y){this.log(\"error\",`error triggering ${p} callbacks`,y)}}_setupReconnectionTimer(){this.reconnectTimer=new C.default(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded();this.isConnected()||this.connect()},10)},this.reconnectAfterMs)}_initializeOptions(p){var k,y,v,z,J,l,t,x,w,A,L,P;this.transport=(k=p===null||p===void 0?void 0:p.transport)!==null&&k!==void 0?k:null;this.timeout=(y=p===null||p===void 0?void 0:p.timeout)!==null&&y!==void 0?y:q.DEFAULT_TIMEOUT;\nthis.heartbeatIntervalMs=(v=p===null||p===void 0?void 0:p.heartbeatIntervalMs)!==null&&v!==void 0?v:25E3;this.worker=(z=p===null||p===void 0?void 0:p.worker)!==null&&z!==void 0?z:!1;this.accessToken=(J=p===null||p===void 0?void 0:p.accessToken)!==null&&J!==void 0?J:null;this.heartbeatCallback=(l=p===null||p===void 0?void 0:p.heartbeatCallback)!==null&&l!==void 0?l:M;this.vsn=(t=p===null||p===void 0?void 0:p.vsn)!==null&&t!==void 0?t:q.DEFAULT_VSN;if(p===null||p===void 0?0:p.params)this.params=p.params;\nif(p===null||p===void 0?0:p.logger)this.logger=p.logger;if((p===null||p===void 0?0:p.logLevel)||(p===null||p===void 0?0:p.log_level))this.logLevel=p.logLevel||p.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel});this.reconnectAfterMs=(x=p===null||p===void 0?void 0:p.reconnectAfterMs)!==null&&x!==void 0?x:T=>d[T-1]||1E4;switch(this.vsn){case q.VSN_1_0_0:this.encode=(w=p===null||p===void 0?void 0:p.encode)!==null&&w!==void 0?w:(T,Y)=>Y(JSON.stringify(T));this.decode=\n(A=p===null||p===void 0?void 0:p.decode)!==null&&A!==void 0?A:(T,Y)=>Y(JSON.parse(T));break;case q.VSN_2_0_0:this.encode=(L=p===null||p===void 0?void 0:p.encode)!==null&&L!==void 0?L:this.serializer.encode.bind(this.serializer);this.decode=(P=p===null||p===void 0?void 0:p.decode)!==null&&P!==void 0?P:this.serializer.decode.bind(this.serializer);break;default:throw Error(`Unsupported serializer version: ${this.vsn}`);}if(this.worker){if(typeof window!==\"undefined\"&&!window.Worker)throw Error(\"Web Worker is not supported\");\nthis.workerUrl=p===null||p===void 0?void 0:p.workerUrl}}}a.default=K}","~:source","shadow$provide[29] = function(require,module,exports) {\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tslib_1 = require(\"tslib\");\r\nconst websocket_factory_1 = tslib_1.__importDefault(require(\"./lib/websocket-factory\"));\r\nconst constants_1 = require(\"./lib/constants\");\r\nconst serializer_1 = tslib_1.__importDefault(require(\"./lib/serializer\"));\r\nconst timer_1 = tslib_1.__importDefault(require(\"./lib/timer\"));\r\nconst transformers_1 = require(\"./lib/transformers\");\r\nconst RealtimeChannel_1 = tslib_1.__importDefault(require(\"./RealtimeChannel\"));\r\nconst noop = () => { };\r\n// Connection-related constants\r\nconst CONNECTION_TIMEOUTS = {\r\n    HEARTBEAT_INTERVAL: 25000,\r\n    RECONNECT_DELAY: 10,\r\n    HEARTBEAT_TIMEOUT_FALLBACK: 100,\r\n};\r\nconst RECONNECT_INTERVALS = [1000, 2000, 5000, 10000];\r\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\r\nconst WORKER_SCRIPT = `\r\n  addEventListener(\"message\", (e) => {\r\n    if (e.data.event === \"start\") {\r\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\r\n    }\r\n  });`;\r\nclass RealtimeClient {\r\n    /**\r\n     * Initializes the Socket.\r\n     *\r\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\r\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\r\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\r\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\r\n     * @param options.params The optional params to pass when connecting.\r\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\r\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\r\n     * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.\r\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\r\n     * @param options.logLevel Sets the log level for Realtime\r\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\r\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\r\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\r\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\r\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\r\n     * @param options.vsn The protocol version to use when connecting. Supported versions are \"1.0.0\" and \"2.0.0\". Defaults to \"2.0.0\".\r\n     * @example\r\n     * ```ts\r\n     * import RealtimeClient from '@supabase/realtime-js'\r\n     *\r\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\r\n     *   params: { apikey: 'public-anon-key' },\r\n     * })\r\n     * client.connect()\r\n     * ```\r\n     */\r\n    constructor(endPoint, options) {\r\n        var _a;\r\n        this.accessTokenValue = null;\r\n        this.apiKey = null;\r\n        this._manuallySetToken = false;\r\n        this.channels = new Array();\r\n        this.endPoint = '';\r\n        this.httpEndpoint = '';\r\n        /** @deprecated headers cannot be set on websocket connections */\r\n        this.headers = {};\r\n        this.params = {};\r\n        this.timeout = constants_1.DEFAULT_TIMEOUT;\r\n        this.transport = null;\r\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\r\n        this.heartbeatTimer = undefined;\r\n        this.pendingHeartbeatRef = null;\r\n        this.heartbeatCallback = noop;\r\n        this.ref = 0;\r\n        this.reconnectTimer = null;\r\n        this.vsn = constants_1.DEFAULT_VSN;\r\n        this.logger = noop;\r\n        this.conn = null;\r\n        this.sendBuffer = [];\r\n        this.serializer = new serializer_1.default();\r\n        this.stateChangeCallbacks = {\r\n            open: [],\r\n            close: [],\r\n            error: [],\r\n            message: [],\r\n        };\r\n        this.accessToken = null;\r\n        this._connectionState = 'disconnected';\r\n        this._wasManualDisconnect = false;\r\n        this._authPromise = null;\r\n        this._heartbeatSentAt = null;\r\n        /**\r\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\r\n         *\r\n         * @internal\r\n         */\r\n        this._resolveFetch = (customFetch) => {\r\n            if (customFetch) {\r\n                return (...args) => customFetch(...args);\r\n            }\r\n            return (...args) => fetch(...args);\r\n        };\r\n        // Validate required parameters\r\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\r\n            throw new Error('API key is required to connect to Realtime');\r\n        }\r\n        this.apiKey = options.params.apikey;\r\n        // Initialize endpoint URLs\r\n        this.endPoint = `${endPoint}/${constants_1.TRANSPORTS.websocket}`;\r\n        this.httpEndpoint = (0, transformers_1.httpEndpointURL)(endPoint);\r\n        this._initializeOptions(options);\r\n        this._setupReconnectionTimer();\r\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\r\n    }\r\n    /**\r\n     * Connects the socket, unless already connected.\r\n     */\r\n    connect() {\r\n        // Skip if already connecting, disconnecting, or connected\r\n        if (this.isConnecting() ||\r\n            this.isDisconnecting() ||\r\n            (this.conn !== null && this.isConnected())) {\r\n            return;\r\n        }\r\n        this._setConnectionState('connecting');\r\n        // Trigger auth if needed and not already in progress\r\n        // This ensures auth is called for standalone RealtimeClient usage\r\n        // while avoiding race conditions with SupabaseClient's immediate setAuth call\r\n        if (this.accessToken && !this._authPromise) {\r\n            this._setAuthSafely('connect');\r\n        }\r\n        // Establish WebSocket connection\r\n        if (this.transport) {\r\n            // Use custom transport if provided\r\n            this.conn = new this.transport(this.endpointURL());\r\n        }\r\n        else {\r\n            // Try to use native WebSocket\r\n            try {\r\n                this.conn = websocket_factory_1.default.createWebSocket(this.endpointURL());\r\n            }\r\n            catch (error) {\r\n                this._setConnectionState('disconnected');\r\n                const errorMessage = error.message;\r\n                // Provide helpful error message based on environment\r\n                if (errorMessage.includes('Node.js')) {\r\n                    throw new Error(`${errorMessage}\\n\\n` +\r\n                        'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n' +\r\n                        'Option 1: Use Node.js 22+ which has native WebSocket support\\n' +\r\n                        'Option 2: Install and provide the \"ws\" package:\\n\\n' +\r\n                        '  npm install ws\\n\\n' +\r\n                        '  import ws from \"ws\"\\n' +\r\n                        '  const client = new RealtimeClient(url, {\\n' +\r\n                        '    ...options,\\n' +\r\n                        '    transport: ws\\n' +\r\n                        '  })');\r\n                }\r\n                throw new Error(`WebSocket not available: ${errorMessage}`);\r\n            }\r\n        }\r\n        this._setupConnectionHandlers();\r\n    }\r\n    /**\r\n     * Returns the URL of the websocket.\r\n     * @returns string The URL of the websocket.\r\n     */\r\n    endpointURL() {\r\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: this.vsn }));\r\n    }\r\n    /**\r\n     * Disconnects the socket.\r\n     *\r\n     * @param code A numeric status code to send on disconnect.\r\n     * @param reason A custom reason for the disconnect.\r\n     */\r\n    disconnect(code, reason) {\r\n        if (this.isDisconnecting()) {\r\n            return;\r\n        }\r\n        this._setConnectionState('disconnecting', true);\r\n        if (this.conn) {\r\n            // Setup fallback timer to prevent hanging in disconnecting state\r\n            const fallbackTimer = setTimeout(() => {\r\n                this._setConnectionState('disconnected');\r\n            }, 100);\r\n            this.conn.onclose = () => {\r\n                clearTimeout(fallbackTimer);\r\n                this._setConnectionState('disconnected');\r\n            };\r\n            // Close the WebSocket connection if close method exists\r\n            if (typeof this.conn.close === 'function') {\r\n                if (code) {\r\n                    this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\r\n                }\r\n                else {\r\n                    this.conn.close();\r\n                }\r\n            }\r\n            this._teardownConnection();\r\n        }\r\n        else {\r\n            this._setConnectionState('disconnected');\r\n        }\r\n    }\r\n    /**\r\n     * Returns all created channels\r\n     */\r\n    getChannels() {\r\n        return this.channels;\r\n    }\r\n    /**\r\n     * Unsubscribes and removes a single channel\r\n     * @param channel A RealtimeChannel instance\r\n     */\r\n    async removeChannel(channel) {\r\n        const status = await channel.unsubscribe();\r\n        if (this.channels.length === 0) {\r\n            this.disconnect();\r\n        }\r\n        return status;\r\n    }\r\n    /**\r\n     * Unsubscribes and removes all channels\r\n     */\r\n    async removeAllChannels() {\r\n        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));\r\n        this.channels = [];\r\n        this.disconnect();\r\n        return values_1;\r\n    }\r\n    /**\r\n     * Logs the message.\r\n     *\r\n     * For customized logging, `this.logger` can be overridden.\r\n     */\r\n    log(kind, msg, data) {\r\n        this.logger(kind, msg, data);\r\n    }\r\n    /**\r\n     * Returns the current state of the socket.\r\n     */\r\n    connectionState() {\r\n        switch (this.conn && this.conn.readyState) {\r\n            case constants_1.SOCKET_STATES.connecting:\r\n                return constants_1.CONNECTION_STATE.Connecting;\r\n            case constants_1.SOCKET_STATES.open:\r\n                return constants_1.CONNECTION_STATE.Open;\r\n            case constants_1.SOCKET_STATES.closing:\r\n                return constants_1.CONNECTION_STATE.Closing;\r\n            default:\r\n                return constants_1.CONNECTION_STATE.Closed;\r\n        }\r\n    }\r\n    /**\r\n     * Returns `true` is the connection is open.\r\n     */\r\n    isConnected() {\r\n        return this.connectionState() === constants_1.CONNECTION_STATE.Open;\r\n    }\r\n    /**\r\n     * Returns `true` if the connection is currently connecting.\r\n     */\r\n    isConnecting() {\r\n        return this._connectionState === 'connecting';\r\n    }\r\n    /**\r\n     * Returns `true` if the connection is currently disconnecting.\r\n     */\r\n    isDisconnecting() {\r\n        return this._connectionState === 'disconnecting';\r\n    }\r\n    /**\r\n     * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.\r\n     *\r\n     * Topics are automatically prefixed with `realtime:` to match the Realtime service.\r\n     * If a channel with the same topic already exists it will be returned instead of creating\r\n     * a duplicate connection.\r\n     */\r\n    channel(topic, params = { config: {} }) {\r\n        const realtimeTopic = `realtime:${topic}`;\r\n        const exists = this.getChannels().find((c) => c.topic === realtimeTopic);\r\n        if (!exists) {\r\n            const chan = new RealtimeChannel_1.default(`realtime:${topic}`, params, this);\r\n            this.channels.push(chan);\r\n            return chan;\r\n        }\r\n        else {\r\n            return exists;\r\n        }\r\n    }\r\n    /**\r\n     * Push out a message if the socket is connected.\r\n     *\r\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\r\n     */\r\n    push(data) {\r\n        const { topic, event, payload, ref } = data;\r\n        const callback = () => {\r\n            this.encode(data, (result) => {\r\n                var _a;\r\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\r\n            });\r\n        };\r\n        this.log('push', `${topic} ${event} (${ref})`, payload);\r\n        if (this.isConnected()) {\r\n            callback();\r\n        }\r\n        else {\r\n            this.sendBuffer.push(callback);\r\n        }\r\n    }\r\n    /**\r\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\r\n     *\r\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\r\n     *\r\n     * On callback used, it will set the value of the token internal to the client.\r\n     *\r\n     * When a token is explicitly provided, it will be preserved across channel operations\r\n     * (including removeChannel and resubscribe). The `accessToken` callback will not be\r\n     * invoked until `setAuth()` is called without arguments.\r\n     *\r\n     * @param token A JWT string to override the token set on the client.\r\n     *\r\n     * @example\r\n     * // Use a manual token (preserved across resubscribes, ignores accessToken callback)\r\n     * client.realtime.setAuth('my-custom-jwt')\r\n     *\r\n     * // Switch back to using the accessToken callback\r\n     * client.realtime.setAuth()\r\n     */\r\n    async setAuth(token = null) {\r\n        this._authPromise = this._performAuth(token);\r\n        try {\r\n            await this._authPromise;\r\n        }\r\n        finally {\r\n            this._authPromise = null;\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if the current access token was explicitly set via setAuth(token),\r\n     * false if it was obtained via the accessToken callback.\r\n     * @internal\r\n     */\r\n    _isManualToken() {\r\n        return this._manuallySetToken;\r\n    }\r\n    /**\r\n     * Sends a heartbeat message if the socket is connected.\r\n     */\r\n    async sendHeartbeat() {\r\n        var _a;\r\n        if (!this.isConnected()) {\r\n            try {\r\n                this.heartbeatCallback('disconnected');\r\n            }\r\n            catch (e) {\r\n                this.log('error', 'error in heartbeat callback', e);\r\n            }\r\n            return;\r\n        }\r\n        // Handle heartbeat timeout and force reconnection if needed\r\n        if (this.pendingHeartbeatRef) {\r\n            this.pendingHeartbeatRef = null;\r\n            this._heartbeatSentAt = null;\r\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\r\n            try {\r\n                this.heartbeatCallback('timeout');\r\n            }\r\n            catch (e) {\r\n                this.log('error', 'error in heartbeat callback', e);\r\n            }\r\n            // Force reconnection after heartbeat timeout\r\n            this._wasManualDisconnect = false;\r\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(constants_1.WS_CLOSE_NORMAL, 'heartbeat timeout');\r\n            setTimeout(() => {\r\n                var _a;\r\n                if (!this.isConnected()) {\r\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\r\n                }\r\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\r\n            return;\r\n        }\r\n        // Send heartbeat message to server\r\n        this._heartbeatSentAt = Date.now();\r\n        this.pendingHeartbeatRef = this._makeRef();\r\n        this.push({\r\n            topic: 'phoenix',\r\n            event: 'heartbeat',\r\n            payload: {},\r\n            ref: this.pendingHeartbeatRef,\r\n        });\r\n        try {\r\n            this.heartbeatCallback('sent');\r\n        }\r\n        catch (e) {\r\n            this.log('error', 'error in heartbeat callback', e);\r\n        }\r\n        this._setAuthSafely('heartbeat');\r\n    }\r\n    /**\r\n     * Sets a callback that receives lifecycle events for internal heartbeat messages.\r\n     * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).\r\n     */\r\n    onHeartbeat(callback) {\r\n        this.heartbeatCallback = callback;\r\n    }\r\n    /**\r\n     * Flushes send buffer\r\n     */\r\n    flushSendBuffer() {\r\n        if (this.isConnected() && this.sendBuffer.length > 0) {\r\n            this.sendBuffer.forEach((callback) => callback());\r\n            this.sendBuffer = [];\r\n        }\r\n    }\r\n    /**\r\n     * Return the next message ref, accounting for overflows\r\n     *\r\n     * @internal\r\n     */\r\n    _makeRef() {\r\n        let newRef = this.ref + 1;\r\n        if (newRef === this.ref) {\r\n            this.ref = 0;\r\n        }\r\n        else {\r\n            this.ref = newRef;\r\n        }\r\n        return this.ref.toString();\r\n    }\r\n    /**\r\n     * Unsubscribe from channels with the specified topic.\r\n     *\r\n     * @internal\r\n     */\r\n    _leaveOpenTopic(topic) {\r\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\r\n        if (dupChannel) {\r\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\r\n            dupChannel.unsubscribe();\r\n        }\r\n    }\r\n    /**\r\n     * Removes a subscription from the socket.\r\n     *\r\n     * @param channel An open subscription.\r\n     *\r\n     * @internal\r\n     */\r\n    _remove(channel) {\r\n        this.channels = this.channels.filter((c) => c.topic !== channel.topic);\r\n    }\r\n    /** @internal */\r\n    _onConnMessage(rawMessage) {\r\n        this.decode(rawMessage.data, (msg) => {\r\n            // Handle heartbeat responses\r\n            if (msg.topic === 'phoenix' &&\r\n                msg.event === 'phx_reply' &&\r\n                msg.ref &&\r\n                msg.ref === this.pendingHeartbeatRef) {\r\n                const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : undefined;\r\n                try {\r\n                    this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error', latency);\r\n                }\r\n                catch (e) {\r\n                    this.log('error', 'error in heartbeat callback', e);\r\n                }\r\n                this._heartbeatSentAt = null;\r\n                this.pendingHeartbeatRef = null;\r\n            }\r\n            // Log incoming message\r\n            const { topic, event, payload, ref } = msg;\r\n            const refString = ref ? `(${ref})` : '';\r\n            const status = payload.status || '';\r\n            this.log('receive', `${status} ${topic} ${event} ${refString}`.trim(), payload);\r\n            // Route message to appropriate channels\r\n            this.channels\r\n                .filter((channel) => channel._isMember(topic))\r\n                .forEach((channel) => channel._trigger(event, payload, ref));\r\n            this._triggerStateCallbacks('message', msg);\r\n        });\r\n    }\r\n    /**\r\n     * Clear specific timer\r\n     * @internal\r\n     */\r\n    _clearTimer(timer) {\r\n        var _a;\r\n        if (timer === 'heartbeat' && this.heartbeatTimer) {\r\n            clearInterval(this.heartbeatTimer);\r\n            this.heartbeatTimer = undefined;\r\n        }\r\n        else if (timer === 'reconnect') {\r\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\r\n        }\r\n    }\r\n    /**\r\n     * Clear all timers\r\n     * @internal\r\n     */\r\n    _clearAllTimers() {\r\n        this._clearTimer('heartbeat');\r\n        this._clearTimer('reconnect');\r\n    }\r\n    /**\r\n     * Setup connection handlers for WebSocket events\r\n     * @internal\r\n     */\r\n    _setupConnectionHandlers() {\r\n        if (!this.conn)\r\n            return;\r\n        // Set binary type if supported (browsers and most WebSocket implementations)\r\n        if ('binaryType' in this.conn) {\r\n            ;\r\n            this.conn.binaryType = 'arraybuffer';\r\n        }\r\n        this.conn.onopen = () => this._onConnOpen();\r\n        this.conn.onerror = (error) => this._onConnError(error);\r\n        this.conn.onmessage = (event) => this._onConnMessage(event);\r\n        this.conn.onclose = (event) => this._onConnClose(event);\r\n        if (this.conn.readyState === constants_1.SOCKET_STATES.open) {\r\n            this._onConnOpen();\r\n        }\r\n    }\r\n    /**\r\n     * Teardown connection and cleanup resources\r\n     * @internal\r\n     */\r\n    _teardownConnection() {\r\n        if (this.conn) {\r\n            if (this.conn.readyState === constants_1.SOCKET_STATES.open ||\r\n                this.conn.readyState === constants_1.SOCKET_STATES.connecting) {\r\n                try {\r\n                    this.conn.close();\r\n                }\r\n                catch (e) {\r\n                    this.log('error', 'Error closing connection', e);\r\n                }\r\n            }\r\n            this.conn.onopen = null;\r\n            this.conn.onerror = null;\r\n            this.conn.onmessage = null;\r\n            this.conn.onclose = null;\r\n            this.conn = null;\r\n        }\r\n        this._clearAllTimers();\r\n        this._terminateWorker();\r\n        this.channels.forEach((channel) => channel.teardown());\r\n    }\r\n    /** @internal */\r\n    _onConnOpen() {\r\n        this._setConnectionState('connected');\r\n        this.log('transport', `connected to ${this.endpointURL()}`);\r\n        // Wait for any pending auth operations before flushing send buffer\r\n        // This ensures channel join messages include the correct access token\r\n        const authPromise = this._authPromise ||\r\n            (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());\r\n        authPromise\r\n            .then(() => {\r\n            this.flushSendBuffer();\r\n        })\r\n            .catch((e) => {\r\n            this.log('error', 'error waiting for auth on connect', e);\r\n            // Proceed anyway to avoid hanging connections\r\n            this.flushSendBuffer();\r\n        });\r\n        this._clearTimer('reconnect');\r\n        if (!this.worker) {\r\n            this._startHeartbeat();\r\n        }\r\n        else {\r\n            if (!this.workerRef) {\r\n                this._startWorkerHeartbeat();\r\n            }\r\n        }\r\n        this._triggerStateCallbacks('open');\r\n    }\r\n    /** @internal */\r\n    _startHeartbeat() {\r\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\r\n        this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\r\n    }\r\n    /** @internal */\r\n    _startWorkerHeartbeat() {\r\n        if (this.workerUrl) {\r\n            this.log('worker', `starting worker for from ${this.workerUrl}`);\r\n        }\r\n        else {\r\n            this.log('worker', `starting default worker`);\r\n        }\r\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\r\n        this.workerRef = new Worker(objectUrl);\r\n        this.workerRef.onerror = (error) => {\r\n            this.log('worker', 'worker error', error.message);\r\n            this._terminateWorker();\r\n        };\r\n        this.workerRef.onmessage = (event) => {\r\n            if (event.data.event === 'keepAlive') {\r\n                this.sendHeartbeat();\r\n            }\r\n        };\r\n        this.workerRef.postMessage({\r\n            event: 'start',\r\n            interval: this.heartbeatIntervalMs,\r\n        });\r\n    }\r\n    /**\r\n     * Terminate the Web Worker and clear the reference\r\n     * @internal\r\n     */\r\n    _terminateWorker() {\r\n        if (this.workerRef) {\r\n            this.log('worker', 'terminating worker');\r\n            this.workerRef.terminate();\r\n            this.workerRef = undefined;\r\n        }\r\n    }\r\n    /** @internal */\r\n    _onConnClose(event) {\r\n        var _a;\r\n        this._setConnectionState('disconnected');\r\n        this.log('transport', 'close', event);\r\n        this._triggerChanError();\r\n        this._clearTimer('heartbeat');\r\n        // Only schedule reconnection if it wasn't a manual disconnect\r\n        if (!this._wasManualDisconnect) {\r\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\r\n        }\r\n        this._triggerStateCallbacks('close', event);\r\n    }\r\n    /** @internal */\r\n    _onConnError(error) {\r\n        this._setConnectionState('disconnected');\r\n        this.log('transport', `${error}`);\r\n        this._triggerChanError();\r\n        this._triggerStateCallbacks('error', error);\r\n        try {\r\n            this.heartbeatCallback('error');\r\n        }\r\n        catch (e) {\r\n            this.log('error', 'error in heartbeat callback', e);\r\n        }\r\n    }\r\n    /** @internal */\r\n    _triggerChanError() {\r\n        this.channels.forEach((channel) => channel._trigger(constants_1.CHANNEL_EVENTS.error));\r\n    }\r\n    /** @internal */\r\n    _appendParams(url, params) {\r\n        if (Object.keys(params).length === 0) {\r\n            return url;\r\n        }\r\n        const prefix = url.match(/\\?/) ? '&' : '?';\r\n        const query = new URLSearchParams(params);\r\n        return `${url}${prefix}${query}`;\r\n    }\r\n    _workerObjectUrl(url) {\r\n        let result_url;\r\n        if (url) {\r\n            result_url = url;\r\n        }\r\n        else {\r\n            const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });\r\n            result_url = URL.createObjectURL(blob);\r\n        }\r\n        return result_url;\r\n    }\r\n    /**\r\n     * Set connection state with proper state management\r\n     * @internal\r\n     */\r\n    _setConnectionState(state, manual = false) {\r\n        this._connectionState = state;\r\n        if (state === 'connecting') {\r\n            this._wasManualDisconnect = false;\r\n        }\r\n        else if (state === 'disconnecting') {\r\n            this._wasManualDisconnect = manual;\r\n        }\r\n    }\r\n    /**\r\n     * Perform the actual auth operation\r\n     * @internal\r\n     */\r\n    async _performAuth(token = null) {\r\n        let tokenToSend;\r\n        let isManualToken = false;\r\n        if (token) {\r\n            tokenToSend = token;\r\n            // Track if this is a manually-provided token\r\n            isManualToken = true;\r\n        }\r\n        else if (this.accessToken) {\r\n            // Call the accessToken callback to get fresh token\r\n            try {\r\n                tokenToSend = await this.accessToken();\r\n            }\r\n            catch (e) {\r\n                this.log('error', 'Error fetching access token from callback', e);\r\n                // Fall back to cached value if callback fails\r\n                tokenToSend = this.accessTokenValue;\r\n            }\r\n        }\r\n        else {\r\n            tokenToSend = this.accessTokenValue;\r\n        }\r\n        // Track whether this token was manually set or fetched via callback\r\n        if (isManualToken) {\r\n            this._manuallySetToken = true;\r\n        }\r\n        else if (this.accessToken) {\r\n            // If we used the callback, clear the manual flag\r\n            this._manuallySetToken = false;\r\n        }\r\n        if (this.accessTokenValue != tokenToSend) {\r\n            this.accessTokenValue = tokenToSend;\r\n            this.channels.forEach((channel) => {\r\n                const payload = {\r\n                    access_token: tokenToSend,\r\n                    version: constants_1.DEFAULT_VERSION,\r\n                };\r\n                tokenToSend && channel.updateJoinPayload(payload);\r\n                if (channel.joinedOnce && channel._isJoined()) {\r\n                    channel._push(constants_1.CHANNEL_EVENTS.access_token, {\r\n                        access_token: tokenToSend,\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Wait for any in-flight auth operations to complete\r\n     * @internal\r\n     */\r\n    async _waitForAuthIfNeeded() {\r\n        if (this._authPromise) {\r\n            await this._authPromise;\r\n        }\r\n    }\r\n    /**\r\n     * Safely call setAuth with standardized error handling\r\n     * @internal\r\n     */\r\n    _setAuthSafely(context = 'general') {\r\n        // Only refresh auth if using callback-based tokens\r\n        if (!this._isManualToken()) {\r\n            this.setAuth().catch((e) => {\r\n                this.log('error', `Error setting auth in ${context}`, e);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Trigger state change callbacks with proper error handling\r\n     * @internal\r\n     */\r\n    _triggerStateCallbacks(event, data) {\r\n        try {\r\n            this.stateChangeCallbacks[event].forEach((callback) => {\r\n                try {\r\n                    callback(data);\r\n                }\r\n                catch (e) {\r\n                    this.log('error', `error in ${event} callback`, e);\r\n                }\r\n            });\r\n        }\r\n        catch (e) {\r\n            this.log('error', `error triggering ${event} callbacks`, e);\r\n        }\r\n    }\r\n    /**\r\n     * Setup reconnection timer with proper configuration\r\n     * @internal\r\n     */\r\n    _setupReconnectionTimer() {\r\n        this.reconnectTimer = new timer_1.default(async () => {\r\n            setTimeout(async () => {\r\n                await this._waitForAuthIfNeeded();\r\n                if (!this.isConnected()) {\r\n                    this.connect();\r\n                }\r\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\r\n        }, this.reconnectAfterMs);\r\n    }\r\n    /**\r\n     * Initialize client options with defaults\r\n     * @internal\r\n     */\r\n    _initializeOptions(options) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\r\n        // Set defaults\r\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\r\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_TIMEOUT;\r\n        this.heartbeatIntervalMs =\r\n            (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\r\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\r\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\r\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\r\n        this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : constants_1.DEFAULT_VSN;\r\n        // Handle special cases\r\n        if (options === null || options === void 0 ? void 0 : options.params)\r\n            this.params = options.params;\r\n        if (options === null || options === void 0 ? void 0 : options.logger)\r\n            this.logger = options.logger;\r\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\r\n            this.logLevel = options.logLevel || options.log_level;\r\n            this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });\r\n        }\r\n        // Set up functions with defaults\r\n        this.reconnectAfterMs =\r\n            (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : ((tries) => {\r\n                return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\r\n            });\r\n        switch (this.vsn) {\r\n            case constants_1.VSN_1_0_0:\r\n                this.encode =\r\n                    (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : ((payload, callback) => {\r\n                        return callback(JSON.stringify(payload));\r\n                    });\r\n                this.decode =\r\n                    (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : ((payload, callback) => {\r\n                        return callback(JSON.parse(payload));\r\n                    });\r\n                break;\r\n            case constants_1.VSN_2_0_0:\r\n                this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);\r\n                this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);\r\n                break;\r\n            default:\r\n                throw new Error(`Unsupported serializer version: ${this.vsn}`);\r\n        }\r\n        // Handle worker setup\r\n        if (this.worker) {\r\n            if (typeof window !== 'undefined' && !window.Worker) {\r\n                throw new Error('Web Worker is not supported');\r\n            }\r\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\r\n        }\r\n    }\r\n}\r\nexports.default = RealtimeClient;\r\n//# sourceMappingURL=RealtimeClient.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$supabase$realtime_js$dist$main$lib$timer","~$module$node_modules$$supabase$realtime_js$dist$main$RealtimeChannel","~$module$node_modules$tslib$tslib","~$module$node_modules$$supabase$realtime_js$dist$main$lib$websocket_factory","~$module$node_modules$$supabase$realtime_js$dist$main$lib$transformers","~$shadow.js","~$module$node_modules$$supabase$realtime_js$dist$main$lib$constants","~$module$node_modules$$supabase$realtime_js$dist$main$lib$serializer"]],"~:properties",["^5",["_authPromise","message","transport","fetch","heartbeatCallback","reconnectTimer","reconnectAfterMs","onerror","onclose","_connectionState","config","workerRef","workerUrl","logLevel","params","binaryType","vsn","accessTokenValue","decode","sendBuffer","access_token","__esModule","conn","error","event","_heartbeatSentAt","log_level","value","interval","timeout","accessToken","logger","apiKey","close","serializer","httpEndpoint","type","onopen","pendingHeartbeatRef","heartbeatIntervalMs","ref","version","stateChangeCallbacks","_manuallySetToken","endPoint","open","payload","encode","default","onmessage","_wasManualDisconnect","heartbeatTimer","channels","topic","_resolveFetch","headers","worker"]],"~:compiled-at",1771869280862,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$realtime_js$dist$main$RealtimeClient.js\",\n\"lineCount\":25,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js\"],\n\"sourcesContent\":[\"shadow$provide[29] = function(require,module,exports) {\\n\\\"use strict\\\";\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nconst tslib_1 = require(\\\"tslib\\\");\\r\\nconst websocket_factory_1 = tslib_1.__importDefault(require(\\\"./lib/websocket-factory\\\"));\\r\\nconst constants_1 = require(\\\"./lib/constants\\\");\\r\\nconst serializer_1 = tslib_1.__importDefault(require(\\\"./lib/serializer\\\"));\\r\\nconst timer_1 = tslib_1.__importDefault(require(\\\"./lib/timer\\\"));\\r\\nconst transformers_1 = require(\\\"./lib/transformers\\\");\\r\\nconst RealtimeChannel_1 = tslib_1.__importDefault(require(\\\"./RealtimeChannel\\\"));\\r\\nconst noop = () => { };\\r\\n// Connection-related constants\\r\\nconst CONNECTION_TIMEOUTS = {\\r\\n    HEARTBEAT_INTERVAL: 25000,\\r\\n    RECONNECT_DELAY: 10,\\r\\n    HEARTBEAT_TIMEOUT_FALLBACK: 100,\\r\\n};\\r\\nconst RECONNECT_INTERVALS = [1000, 2000, 5000, 10000];\\r\\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\\r\\nconst WORKER_SCRIPT = `\\r\\n  addEventListener(\\\"message\\\", (e) => {\\r\\n    if (e.data.event === \\\"start\\\") {\\r\\n      setInterval(() => postMessage({ event: \\\"keepAlive\\\" }), e.data.interval);\\r\\n    }\\r\\n  });`;\\r\\nclass RealtimeClient {\\r\\n    /**\\r\\n     * Initializes the Socket.\\r\\n     *\\r\\n     * @param endPoint The string WebSocket endpoint, ie, \\\"ws://example.com/socket\\\", \\\"wss://example.com\\\", \\\"/socket\\\" (inherited host & protocol)\\r\\n     * @param httpEndpoint The string HTTP endpoint, ie, \\\"https://example.com\\\", \\\"/\\\" (inherited host & protocol)\\r\\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\\r\\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\\r\\n     * @param options.params The optional params to pass when connecting.\\r\\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\\r\\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\\r\\n     * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.\\r\\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\\r\\n     * @param options.logLevel Sets the log level for Realtime\\r\\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\\r\\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\\r\\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\\r\\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\\r\\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\\r\\n     * @param options.vsn The protocol version to use when connecting. Supported versions are \\\"1.0.0\\\" and \\\"2.0.0\\\". Defaults to \\\"2.0.0\\\".\\r\\n     * @example\\r\\n     * ```ts\\r\\n     * import RealtimeClient from '@supabase/realtime-js'\\r\\n     *\\r\\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\\r\\n     *   params: { apikey: 'public-anon-key' },\\r\\n     * })\\r\\n     * client.connect()\\r\\n     * ```\\r\\n     */\\r\\n    constructor(endPoint, options) {\\r\\n        var _a;\\r\\n        this.accessTokenValue = null;\\r\\n        this.apiKey = null;\\r\\n        this._manuallySetToken = false;\\r\\n        this.channels = new Array();\\r\\n        this.endPoint = '';\\r\\n        this.httpEndpoint = '';\\r\\n        /** @deprecated headers cannot be set on websocket connections */\\r\\n        this.headers = {};\\r\\n        this.params = {};\\r\\n        this.timeout = constants_1.DEFAULT_TIMEOUT;\\r\\n        this.transport = null;\\r\\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\\r\\n        this.heartbeatTimer = undefined;\\r\\n        this.pendingHeartbeatRef = null;\\r\\n        this.heartbeatCallback = noop;\\r\\n        this.ref = 0;\\r\\n        this.reconnectTimer = null;\\r\\n        this.vsn = constants_1.DEFAULT_VSN;\\r\\n        this.logger = noop;\\r\\n        this.conn = null;\\r\\n        this.sendBuffer = [];\\r\\n        this.serializer = new serializer_1.default();\\r\\n        this.stateChangeCallbacks = {\\r\\n            open: [],\\r\\n            close: [],\\r\\n            error: [],\\r\\n            message: [],\\r\\n        };\\r\\n        this.accessToken = null;\\r\\n        this._connectionState = 'disconnected';\\r\\n        this._wasManualDisconnect = false;\\r\\n        this._authPromise = null;\\r\\n        this._heartbeatSentAt = null;\\r\\n        /**\\r\\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\\r\\n         *\\r\\n         * @internal\\r\\n         */\\r\\n        this._resolveFetch = (customFetch) => {\\r\\n            if (customFetch) {\\r\\n                return (...args) => customFetch(...args);\\r\\n            }\\r\\n            return (...args) => fetch(...args);\\r\\n        };\\r\\n        // Validate required parameters\\r\\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\\r\\n            throw new Error('API key is required to connect to Realtime');\\r\\n        }\\r\\n        this.apiKey = options.params.apikey;\\r\\n        // Initialize endpoint URLs\\r\\n        this.endPoint = `${endPoint}/${constants_1.TRANSPORTS.websocket}`;\\r\\n        this.httpEndpoint = (0, transformers_1.httpEndpointURL)(endPoint);\\r\\n        this._initializeOptions(options);\\r\\n        this._setupReconnectionTimer();\\r\\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\\r\\n    }\\r\\n    /**\\r\\n     * Connects the socket, unless already connected.\\r\\n     */\\r\\n    connect() {\\r\\n        // Skip if already connecting, disconnecting, or connected\\r\\n        if (this.isConnecting() ||\\r\\n            this.isDisconnecting() ||\\r\\n            (this.conn !== null && this.isConnected())) {\\r\\n            return;\\r\\n        }\\r\\n        this._setConnectionState('connecting');\\r\\n        // Trigger auth if needed and not already in progress\\r\\n        // This ensures auth is called for standalone RealtimeClient usage\\r\\n        // while avoiding race conditions with SupabaseClient's immediate setAuth call\\r\\n        if (this.accessToken && !this._authPromise) {\\r\\n            this._setAuthSafely('connect');\\r\\n        }\\r\\n        // Establish WebSocket connection\\r\\n        if (this.transport) {\\r\\n            // Use custom transport if provided\\r\\n            this.conn = new this.transport(this.endpointURL());\\r\\n        }\\r\\n        else {\\r\\n            // Try to use native WebSocket\\r\\n            try {\\r\\n                this.conn = websocket_factory_1.default.createWebSocket(this.endpointURL());\\r\\n            }\\r\\n            catch (error) {\\r\\n                this._setConnectionState('disconnected');\\r\\n                const errorMessage = error.message;\\r\\n                // Provide helpful error message based on environment\\r\\n                if (errorMessage.includes('Node.js')) {\\r\\n                    throw new Error(`${errorMessage}\\\\n\\\\n` +\\r\\n                        'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\\\n\\\\n' +\\r\\n                        'Option 1: Use Node.js 22+ which has native WebSocket support\\\\n' +\\r\\n                        'Option 2: Install and provide the \\\"ws\\\" package:\\\\n\\\\n' +\\r\\n                        '  npm install ws\\\\n\\\\n' +\\r\\n                        '  import ws from \\\"ws\\\"\\\\n' +\\r\\n                        '  const client = new RealtimeClient(url, {\\\\n' +\\r\\n                        '    ...options,\\\\n' +\\r\\n                        '    transport: ws\\\\n' +\\r\\n                        '  })');\\r\\n                }\\r\\n                throw new Error(`WebSocket not available: ${errorMessage}`);\\r\\n            }\\r\\n        }\\r\\n        this._setupConnectionHandlers();\\r\\n    }\\r\\n    /**\\r\\n     * Returns the URL of the websocket.\\r\\n     * @returns string The URL of the websocket.\\r\\n     */\\r\\n    endpointURL() {\\r\\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: this.vsn }));\\r\\n    }\\r\\n    /**\\r\\n     * Disconnects the socket.\\r\\n     *\\r\\n     * @param code A numeric status code to send on disconnect.\\r\\n     * @param reason A custom reason for the disconnect.\\r\\n     */\\r\\n    disconnect(code, reason) {\\r\\n        if (this.isDisconnecting()) {\\r\\n            return;\\r\\n        }\\r\\n        this._setConnectionState('disconnecting', true);\\r\\n        if (this.conn) {\\r\\n            // Setup fallback timer to prevent hanging in disconnecting state\\r\\n            const fallbackTimer = setTimeout(() => {\\r\\n                this._setConnectionState('disconnected');\\r\\n            }, 100);\\r\\n            this.conn.onclose = () => {\\r\\n                clearTimeout(fallbackTimer);\\r\\n                this._setConnectionState('disconnected');\\r\\n            };\\r\\n            // Close the WebSocket connection if close method exists\\r\\n            if (typeof this.conn.close === 'function') {\\r\\n                if (code) {\\r\\n                    this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\\r\\n                }\\r\\n                else {\\r\\n                    this.conn.close();\\r\\n                }\\r\\n            }\\r\\n            this._teardownConnection();\\r\\n        }\\r\\n        else {\\r\\n            this._setConnectionState('disconnected');\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Returns all created channels\\r\\n     */\\r\\n    getChannels() {\\r\\n        return this.channels;\\r\\n    }\\r\\n    /**\\r\\n     * Unsubscribes and removes a single channel\\r\\n     * @param channel A RealtimeChannel instance\\r\\n     */\\r\\n    async removeChannel(channel) {\\r\\n        const status = await channel.unsubscribe();\\r\\n        if (this.channels.length === 0) {\\r\\n            this.disconnect();\\r\\n        }\\r\\n        return status;\\r\\n    }\\r\\n    /**\\r\\n     * Unsubscribes and removes all channels\\r\\n     */\\r\\n    async removeAllChannels() {\\r\\n        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));\\r\\n        this.channels = [];\\r\\n        this.disconnect();\\r\\n        return values_1;\\r\\n    }\\r\\n    /**\\r\\n     * Logs the message.\\r\\n     *\\r\\n     * For customized logging, `this.logger` can be overridden.\\r\\n     */\\r\\n    log(kind, msg, data) {\\r\\n        this.logger(kind, msg, data);\\r\\n    }\\r\\n    /**\\r\\n     * Returns the current state of the socket.\\r\\n     */\\r\\n    connectionState() {\\r\\n        switch (this.conn && this.conn.readyState) {\\r\\n            case constants_1.SOCKET_STATES.connecting:\\r\\n                return constants_1.CONNECTION_STATE.Connecting;\\r\\n            case constants_1.SOCKET_STATES.open:\\r\\n                return constants_1.CONNECTION_STATE.Open;\\r\\n            case constants_1.SOCKET_STATES.closing:\\r\\n                return constants_1.CONNECTION_STATE.Closing;\\r\\n            default:\\r\\n                return constants_1.CONNECTION_STATE.Closed;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Returns `true` is the connection is open.\\r\\n     */\\r\\n    isConnected() {\\r\\n        return this.connectionState() === constants_1.CONNECTION_STATE.Open;\\r\\n    }\\r\\n    /**\\r\\n     * Returns `true` if the connection is currently connecting.\\r\\n     */\\r\\n    isConnecting() {\\r\\n        return this._connectionState === 'connecting';\\r\\n    }\\r\\n    /**\\r\\n     * Returns `true` if the connection is currently disconnecting.\\r\\n     */\\r\\n    isDisconnecting() {\\r\\n        return this._connectionState === 'disconnecting';\\r\\n    }\\r\\n    /**\\r\\n     * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.\\r\\n     *\\r\\n     * Topics are automatically prefixed with `realtime:` to match the Realtime service.\\r\\n     * If a channel with the same topic already exists it will be returned instead of creating\\r\\n     * a duplicate connection.\\r\\n     */\\r\\n    channel(topic, params = { config: {} }) {\\r\\n        const realtimeTopic = `realtime:${topic}`;\\r\\n        const exists = this.getChannels().find((c) => c.topic === realtimeTopic);\\r\\n        if (!exists) {\\r\\n            const chan = new RealtimeChannel_1.default(`realtime:${topic}`, params, this);\\r\\n            this.channels.push(chan);\\r\\n            return chan;\\r\\n        }\\r\\n        else {\\r\\n            return exists;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Push out a message if the socket is connected.\\r\\n     *\\r\\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\\r\\n     */\\r\\n    push(data) {\\r\\n        const { topic, event, payload, ref } = data;\\r\\n        const callback = () => {\\r\\n            this.encode(data, (result) => {\\r\\n                var _a;\\r\\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\\r\\n            });\\r\\n        };\\r\\n        this.log('push', `${topic} ${event} (${ref})`, payload);\\r\\n        if (this.isConnected()) {\\r\\n            callback();\\r\\n        }\\r\\n        else {\\r\\n            this.sendBuffer.push(callback);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\\r\\n     *\\r\\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\\r\\n     *\\r\\n     * On callback used, it will set the value of the token internal to the client.\\r\\n     *\\r\\n     * When a token is explicitly provided, it will be preserved across channel operations\\r\\n     * (including removeChannel and resubscribe). The `accessToken` callback will not be\\r\\n     * invoked until `setAuth()` is called without arguments.\\r\\n     *\\r\\n     * @param token A JWT string to override the token set on the client.\\r\\n     *\\r\\n     * @example\\r\\n     * // Use a manual token (preserved across resubscribes, ignores accessToken callback)\\r\\n     * client.realtime.setAuth('my-custom-jwt')\\r\\n     *\\r\\n     * // Switch back to using the accessToken callback\\r\\n     * client.realtime.setAuth()\\r\\n     */\\r\\n    async setAuth(token = null) {\\r\\n        this._authPromise = this._performAuth(token);\\r\\n        try {\\r\\n            await this._authPromise;\\r\\n        }\\r\\n        finally {\\r\\n            this._authPromise = null;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Returns true if the current access token was explicitly set via setAuth(token),\\r\\n     * false if it was obtained via the accessToken callback.\\r\\n     * @internal\\r\\n     */\\r\\n    _isManualToken() {\\r\\n        return this._manuallySetToken;\\r\\n    }\\r\\n    /**\\r\\n     * Sends a heartbeat message if the socket is connected.\\r\\n     */\\r\\n    async sendHeartbeat() {\\r\\n        var _a;\\r\\n        if (!this.isConnected()) {\\r\\n            try {\\r\\n                this.heartbeatCallback('disconnected');\\r\\n            }\\r\\n            catch (e) {\\r\\n                this.log('error', 'error in heartbeat callback', e);\\r\\n            }\\r\\n            return;\\r\\n        }\\r\\n        // Handle heartbeat timeout and force reconnection if needed\\r\\n        if (this.pendingHeartbeatRef) {\\r\\n            this.pendingHeartbeatRef = null;\\r\\n            this._heartbeatSentAt = null;\\r\\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\\r\\n            try {\\r\\n                this.heartbeatCallback('timeout');\\r\\n            }\\r\\n            catch (e) {\\r\\n                this.log('error', 'error in heartbeat callback', e);\\r\\n            }\\r\\n            // Force reconnection after heartbeat timeout\\r\\n            this._wasManualDisconnect = false;\\r\\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(constants_1.WS_CLOSE_NORMAL, 'heartbeat timeout');\\r\\n            setTimeout(() => {\\r\\n                var _a;\\r\\n                if (!this.isConnected()) {\\r\\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\\r\\n                }\\r\\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\\r\\n            return;\\r\\n        }\\r\\n        // Send heartbeat message to server\\r\\n        this._heartbeatSentAt = Date.now();\\r\\n        this.pendingHeartbeatRef = this._makeRef();\\r\\n        this.push({\\r\\n            topic: 'phoenix',\\r\\n            event: 'heartbeat',\\r\\n            payload: {},\\r\\n            ref: this.pendingHeartbeatRef,\\r\\n        });\\r\\n        try {\\r\\n            this.heartbeatCallback('sent');\\r\\n        }\\r\\n        catch (e) {\\r\\n            this.log('error', 'error in heartbeat callback', e);\\r\\n        }\\r\\n        this._setAuthSafely('heartbeat');\\r\\n    }\\r\\n    /**\\r\\n     * Sets a callback that receives lifecycle events for internal heartbeat messages.\\r\\n     * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).\\r\\n     */\\r\\n    onHeartbeat(callback) {\\r\\n        this.heartbeatCallback = callback;\\r\\n    }\\r\\n    /**\\r\\n     * Flushes send buffer\\r\\n     */\\r\\n    flushSendBuffer() {\\r\\n        if (this.isConnected() && this.sendBuffer.length > 0) {\\r\\n            this.sendBuffer.forEach((callback) => callback());\\r\\n            this.sendBuffer = [];\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Return the next message ref, accounting for overflows\\r\\n     *\\r\\n     * @internal\\r\\n     */\\r\\n    _makeRef() {\\r\\n        let newRef = this.ref + 1;\\r\\n        if (newRef === this.ref) {\\r\\n            this.ref = 0;\\r\\n        }\\r\\n        else {\\r\\n            this.ref = newRef;\\r\\n        }\\r\\n        return this.ref.toString();\\r\\n    }\\r\\n    /**\\r\\n     * Unsubscribe from channels with the specified topic.\\r\\n     *\\r\\n     * @internal\\r\\n     */\\r\\n    _leaveOpenTopic(topic) {\\r\\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\\r\\n        if (dupChannel) {\\r\\n            this.log('transport', `leaving duplicate topic \\\"${topic}\\\"`);\\r\\n            dupChannel.unsubscribe();\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Removes a subscription from the socket.\\r\\n     *\\r\\n     * @param channel An open subscription.\\r\\n     *\\r\\n     * @internal\\r\\n     */\\r\\n    _remove(channel) {\\r\\n        this.channels = this.channels.filter((c) => c.topic !== channel.topic);\\r\\n    }\\r\\n    /** @internal */\\r\\n    _onConnMessage(rawMessage) {\\r\\n        this.decode(rawMessage.data, (msg) => {\\r\\n            // Handle heartbeat responses\\r\\n            if (msg.topic === 'phoenix' &&\\r\\n                msg.event === 'phx_reply' &&\\r\\n                msg.ref &&\\r\\n                msg.ref === this.pendingHeartbeatRef) {\\r\\n                const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : undefined;\\r\\n                try {\\r\\n                    this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error', latency);\\r\\n                }\\r\\n                catch (e) {\\r\\n                    this.log('error', 'error in heartbeat callback', e);\\r\\n                }\\r\\n                this._heartbeatSentAt = null;\\r\\n                this.pendingHeartbeatRef = null;\\r\\n            }\\r\\n            // Log incoming message\\r\\n            const { topic, event, payload, ref } = msg;\\r\\n            const refString = ref ? `(${ref})` : '';\\r\\n            const status = payload.status || '';\\r\\n            this.log('receive', `${status} ${topic} ${event} ${refString}`.trim(), payload);\\r\\n            // Route message to appropriate channels\\r\\n            this.channels\\r\\n                .filter((channel) => channel._isMember(topic))\\r\\n                .forEach((channel) => channel._trigger(event, payload, ref));\\r\\n            this._triggerStateCallbacks('message', msg);\\r\\n        });\\r\\n    }\\r\\n    /**\\r\\n     * Clear specific timer\\r\\n     * @internal\\r\\n     */\\r\\n    _clearTimer(timer) {\\r\\n        var _a;\\r\\n        if (timer === 'heartbeat' && this.heartbeatTimer) {\\r\\n            clearInterval(this.heartbeatTimer);\\r\\n            this.heartbeatTimer = undefined;\\r\\n        }\\r\\n        else if (timer === 'reconnect') {\\r\\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Clear all timers\\r\\n     * @internal\\r\\n     */\\r\\n    _clearAllTimers() {\\r\\n        this._clearTimer('heartbeat');\\r\\n        this._clearTimer('reconnect');\\r\\n    }\\r\\n    /**\\r\\n     * Setup connection handlers for WebSocket events\\r\\n     * @internal\\r\\n     */\\r\\n    _setupConnectionHandlers() {\\r\\n        if (!this.conn)\\r\\n            return;\\r\\n        // Set binary type if supported (browsers and most WebSocket implementations)\\r\\n        if ('binaryType' in this.conn) {\\r\\n            ;\\r\\n            this.conn.binaryType = 'arraybuffer';\\r\\n        }\\r\\n        this.conn.onopen = () => this._onConnOpen();\\r\\n        this.conn.onerror = (error) => this._onConnError(error);\\r\\n        this.conn.onmessage = (event) => this._onConnMessage(event);\\r\\n        this.conn.onclose = (event) => this._onConnClose(event);\\r\\n        if (this.conn.readyState === constants_1.SOCKET_STATES.open) {\\r\\n            this._onConnOpen();\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Teardown connection and cleanup resources\\r\\n     * @internal\\r\\n     */\\r\\n    _teardownConnection() {\\r\\n        if (this.conn) {\\r\\n            if (this.conn.readyState === constants_1.SOCKET_STATES.open ||\\r\\n                this.conn.readyState === constants_1.SOCKET_STATES.connecting) {\\r\\n                try {\\r\\n                    this.conn.close();\\r\\n                }\\r\\n                catch (e) {\\r\\n                    this.log('error', 'Error closing connection', e);\\r\\n                }\\r\\n            }\\r\\n            this.conn.onopen = null;\\r\\n            this.conn.onerror = null;\\r\\n            this.conn.onmessage = null;\\r\\n            this.conn.onclose = null;\\r\\n            this.conn = null;\\r\\n        }\\r\\n        this._clearAllTimers();\\r\\n        this._terminateWorker();\\r\\n        this.channels.forEach((channel) => channel.teardown());\\r\\n    }\\r\\n    /** @internal */\\r\\n    _onConnOpen() {\\r\\n        this._setConnectionState('connected');\\r\\n        this.log('transport', `connected to ${this.endpointURL()}`);\\r\\n        // Wait for any pending auth operations before flushing send buffer\\r\\n        // This ensures channel join messages include the correct access token\\r\\n        const authPromise = this._authPromise ||\\r\\n            (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());\\r\\n        authPromise\\r\\n            .then(() => {\\r\\n            this.flushSendBuffer();\\r\\n        })\\r\\n            .catch((e) => {\\r\\n            this.log('error', 'error waiting for auth on connect', e);\\r\\n            // Proceed anyway to avoid hanging connections\\r\\n            this.flushSendBuffer();\\r\\n        });\\r\\n        this._clearTimer('reconnect');\\r\\n        if (!this.worker) {\\r\\n            this._startHeartbeat();\\r\\n        }\\r\\n        else {\\r\\n            if (!this.workerRef) {\\r\\n                this._startWorkerHeartbeat();\\r\\n            }\\r\\n        }\\r\\n        this._triggerStateCallbacks('open');\\r\\n    }\\r\\n    /** @internal */\\r\\n    _startHeartbeat() {\\r\\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\\r\\n        this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\\r\\n    }\\r\\n    /** @internal */\\r\\n    _startWorkerHeartbeat() {\\r\\n        if (this.workerUrl) {\\r\\n            this.log('worker', `starting worker for from ${this.workerUrl}`);\\r\\n        }\\r\\n        else {\\r\\n            this.log('worker', `starting default worker`);\\r\\n        }\\r\\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\\r\\n        this.workerRef = new Worker(objectUrl);\\r\\n        this.workerRef.onerror = (error) => {\\r\\n            this.log('worker', 'worker error', error.message);\\r\\n            this._terminateWorker();\\r\\n        };\\r\\n        this.workerRef.onmessage = (event) => {\\r\\n            if (event.data.event === 'keepAlive') {\\r\\n                this.sendHeartbeat();\\r\\n            }\\r\\n        };\\r\\n        this.workerRef.postMessage({\\r\\n            event: 'start',\\r\\n            interval: this.heartbeatIntervalMs,\\r\\n        });\\r\\n    }\\r\\n    /**\\r\\n     * Terminate the Web Worker and clear the reference\\r\\n     * @internal\\r\\n     */\\r\\n    _terminateWorker() {\\r\\n        if (this.workerRef) {\\r\\n            this.log('worker', 'terminating worker');\\r\\n            this.workerRef.terminate();\\r\\n            this.workerRef = undefined;\\r\\n        }\\r\\n    }\\r\\n    /** @internal */\\r\\n    _onConnClose(event) {\\r\\n        var _a;\\r\\n        this._setConnectionState('disconnected');\\r\\n        this.log('transport', 'close', event);\\r\\n        this._triggerChanError();\\r\\n        this._clearTimer('heartbeat');\\r\\n        // Only schedule reconnection if it wasn't a manual disconnect\\r\\n        if (!this._wasManualDisconnect) {\\r\\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\\r\\n        }\\r\\n        this._triggerStateCallbacks('close', event);\\r\\n    }\\r\\n    /** @internal */\\r\\n    _onConnError(error) {\\r\\n        this._setConnectionState('disconnected');\\r\\n        this.log('transport', `${error}`);\\r\\n        this._triggerChanError();\\r\\n        this._triggerStateCallbacks('error', error);\\r\\n        try {\\r\\n            this.heartbeatCallback('error');\\r\\n        }\\r\\n        catch (e) {\\r\\n            this.log('error', 'error in heartbeat callback', e);\\r\\n        }\\r\\n    }\\r\\n    /** @internal */\\r\\n    _triggerChanError() {\\r\\n        this.channels.forEach((channel) => channel._trigger(constants_1.CHANNEL_EVENTS.error));\\r\\n    }\\r\\n    /** @internal */\\r\\n    _appendParams(url, params) {\\r\\n        if (Object.keys(params).length === 0) {\\r\\n            return url;\\r\\n        }\\r\\n        const prefix = url.match(/\\\\?/) ? '&' : '?';\\r\\n        const query = new URLSearchParams(params);\\r\\n        return `${url}${prefix}${query}`;\\r\\n    }\\r\\n    _workerObjectUrl(url) {\\r\\n        let result_url;\\r\\n        if (url) {\\r\\n            result_url = url;\\r\\n        }\\r\\n        else {\\r\\n            const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });\\r\\n            result_url = URL.createObjectURL(blob);\\r\\n        }\\r\\n        return result_url;\\r\\n    }\\r\\n    /**\\r\\n     * Set connection state with proper state management\\r\\n     * @internal\\r\\n     */\\r\\n    _setConnectionState(state, manual = false) {\\r\\n        this._connectionState = state;\\r\\n        if (state === 'connecting') {\\r\\n            this._wasManualDisconnect = false;\\r\\n        }\\r\\n        else if (state === 'disconnecting') {\\r\\n            this._wasManualDisconnect = manual;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Perform the actual auth operation\\r\\n     * @internal\\r\\n     */\\r\\n    async _performAuth(token = null) {\\r\\n        let tokenToSend;\\r\\n        let isManualToken = false;\\r\\n        if (token) {\\r\\n            tokenToSend = token;\\r\\n            // Track if this is a manually-provided token\\r\\n            isManualToken = true;\\r\\n        }\\r\\n        else if (this.accessToken) {\\r\\n            // Call the accessToken callback to get fresh token\\r\\n            try {\\r\\n                tokenToSend = await this.accessToken();\\r\\n            }\\r\\n            catch (e) {\\r\\n                this.log('error', 'Error fetching access token from callback', e);\\r\\n                // Fall back to cached value if callback fails\\r\\n                tokenToSend = this.accessTokenValue;\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            tokenToSend = this.accessTokenValue;\\r\\n        }\\r\\n        // Track whether this token was manually set or fetched via callback\\r\\n        if (isManualToken) {\\r\\n            this._manuallySetToken = true;\\r\\n        }\\r\\n        else if (this.accessToken) {\\r\\n            // If we used the callback, clear the manual flag\\r\\n            this._manuallySetToken = false;\\r\\n        }\\r\\n        if (this.accessTokenValue != tokenToSend) {\\r\\n            this.accessTokenValue = tokenToSend;\\r\\n            this.channels.forEach((channel) => {\\r\\n                const payload = {\\r\\n                    access_token: tokenToSend,\\r\\n                    version: constants_1.DEFAULT_VERSION,\\r\\n                };\\r\\n                tokenToSend && channel.updateJoinPayload(payload);\\r\\n                if (channel.joinedOnce && channel._isJoined()) {\\r\\n                    channel._push(constants_1.CHANNEL_EVENTS.access_token, {\\r\\n                        access_token: tokenToSend,\\r\\n                    });\\r\\n                }\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Wait for any in-flight auth operations to complete\\r\\n     * @internal\\r\\n     */\\r\\n    async _waitForAuthIfNeeded() {\\r\\n        if (this._authPromise) {\\r\\n            await this._authPromise;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Safely call setAuth with standardized error handling\\r\\n     * @internal\\r\\n     */\\r\\n    _setAuthSafely(context = 'general') {\\r\\n        // Only refresh auth if using callback-based tokens\\r\\n        if (!this._isManualToken()) {\\r\\n            this.setAuth().catch((e) => {\\r\\n                this.log('error', `Error setting auth in ${context}`, e);\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Trigger state change callbacks with proper error handling\\r\\n     * @internal\\r\\n     */\\r\\n    _triggerStateCallbacks(event, data) {\\r\\n        try {\\r\\n            this.stateChangeCallbacks[event].forEach((callback) => {\\r\\n                try {\\r\\n                    callback(data);\\r\\n                }\\r\\n                catch (e) {\\r\\n                    this.log('error', `error in ${event} callback`, e);\\r\\n                }\\r\\n            });\\r\\n        }\\r\\n        catch (e) {\\r\\n            this.log('error', `error triggering ${event} callbacks`, e);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Setup reconnection timer with proper configuration\\r\\n     * @internal\\r\\n     */\\r\\n    _setupReconnectionTimer() {\\r\\n        this.reconnectTimer = new timer_1.default(async () => {\\r\\n            setTimeout(async () => {\\r\\n                await this._waitForAuthIfNeeded();\\r\\n                if (!this.isConnected()) {\\r\\n                    this.connect();\\r\\n                }\\r\\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\\r\\n        }, this.reconnectAfterMs);\\r\\n    }\\r\\n    /**\\r\\n     * Initialize client options with defaults\\r\\n     * @internal\\r\\n     */\\r\\n    _initializeOptions(options) {\\r\\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\\r\\n        // Set defaults\\r\\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\\r\\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_TIMEOUT;\\r\\n        this.heartbeatIntervalMs =\\r\\n            (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\\r\\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\\r\\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\\r\\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\\r\\n        this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : constants_1.DEFAULT_VSN;\\r\\n        // Handle special cases\\r\\n        if (options === null || options === void 0 ? void 0 : options.params)\\r\\n            this.params = options.params;\\r\\n        if (options === null || options === void 0 ? void 0 : options.logger)\\r\\n            this.logger = options.logger;\\r\\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\\r\\n            this.logLevel = options.logLevel || options.log_level;\\r\\n            this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });\\r\\n        }\\r\\n        // Set up functions with defaults\\r\\n        this.reconnectAfterMs =\\r\\n            (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : ((tries) => {\\r\\n                return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\\r\\n            });\\r\\n        switch (this.vsn) {\\r\\n            case constants_1.VSN_1_0_0:\\r\\n                this.encode =\\r\\n                    (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : ((payload, callback) => {\\r\\n                        return callback(JSON.stringify(payload));\\r\\n                    });\\r\\n                this.decode =\\r\\n                    (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : ((payload, callback) => {\\r\\n                        return callback(JSON.parse(payload));\\r\\n                    });\\r\\n                break;\\r\\n            case constants_1.VSN_2_0_0:\\r\\n                this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);\\r\\n                this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);\\r\\n                break;\\r\\n            default:\\r\\n                throw new Error(`Unsupported serializer version: ${this.vsn}`);\\r\\n        }\\r\\n        // Handle worker setup\\r\\n        if (this.worker) {\\r\\n            if (typeof window !== 'undefined' && !window.Worker) {\\r\\n                throw new Error('Web Worker is not supported');\\r\\n            }\\r\\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\\r\\n        }\\r\\n    }\\r\\n}\\r\\nexports.default = RealtimeClient;\\r\\n//# sourceMappingURL=RealtimeClient.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"tslib_1\",\"websocket_factory_1\",\"__importDefault\",\"constants_1\",\"serializer_1\",\"timer_1\",\"transformers_1\",\"RealtimeChannel_1\",\"noop\",\"RECONNECT_INTERVALS\",\"RealtimeClient\",\"constructor\",\"endPoint\",\"options\",\"_a\",\"apiKey\",\"accessTokenValue\",\"_manuallySetToken\",\"channels\",\"httpEndpoint\",\"headers\",\"params\",\"timeout\",\"DEFAULT_TIMEOUT\",\"transport\",\"heartbeatIntervalMs\",\"HEARTBEAT_INTERVAL\",\"heartbeatTimer\",\"undefined\",\"pendingHeartbeatRef\",\"heartbeatCallback\",\"ref\",\"reconnectTimer\",\"vsn\",\"DEFAULT_VSN\",\"logger\",\"conn\",\"sendBuffer\",\"serializer\",\"default\",\"stateChangeCallbacks\",\"open\",\"close\",\"error\",\"message\",\"accessToken\",\"_connectionState\",\"_wasManualDisconnect\",\"_heartbeatSentAt\",\"_authPromise\",\"_resolveFetch\",\"customFetch\",\"this._resolveFetch\",\"args\",\"fetch\",\"apikey\",\"Error\",\"TRANSPORTS\",\"websocket\",\"httpEndpointURL\",\"_initializeOptions\",\"_setupReconnectionTimer\",\"connect\",\"isConnecting\",\"isDisconnecting\",\"isConnected\",\"_setConnectionState\",\"_setAuthSafely\",\"endpointURL\",\"createWebSocket\",\"errorMessage\",\"includes\",\"_setupConnectionHandlers\",\"_appendParams\",\"assign\",\"disconnect\",\"code\",\"reason\",\"fallbackTimer\",\"setTimeout\",\"onclose\",\"this.conn.onclose\",\"clearTimeout\",\"_teardownConnection\",\"getChannels\",\"removeChannel\",\"channel\",\"status\",\"unsubscribe\",\"length\",\"removeAllChannels\",\"values_1\",\"Promise\",\"all\",\"map\",\"log\",\"kind\",\"msg\",\"data\",\"connectionState\",\"readyState\",\"SOCKET_STATES\",\"connecting\",\"CONNECTION_STATE\",\"Connecting\",\"Open\",\"closing\",\"Closing\",\"Closed\",\"topic\",\"config\",\"realtimeTopic\",\"exists\",\"find\",\"c\",\"chan\",\"push\",\"event\",\"payload\",\"callback\",\"encode\",\"result\",\"send\",\"setAuth\",\"token\",\"_performAuth\",\"_isManualToken\",\"sendHeartbeat\",\"e\",\"WS_CLOSE_NORMAL\",\"scheduleTimeout\",\"HEARTBEAT_TIMEOUT_FALLBACK\",\"Date\",\"now\",\"_makeRef\",\"onHeartbeat\",\"flushSendBuffer\",\"forEach\",\"newRef\",\"toString\",\"_leaveOpenTopic\",\"dupChannel\",\"_isJoined\",\"_isJoining\",\"_remove\",\"filter\",\"_onConnMessage\",\"rawMessage\",\"decode\",\"latency\",\"refString\",\"trim\",\"_isMember\",\"_trigger\",\"_triggerStateCallbacks\",\"_clearTimer\",\"timer\",\"clearInterval\",\"reset\",\"_clearAllTimers\",\"binaryType\",\"onopen\",\"this.conn.onopen\",\"_onConnOpen\",\"onerror\",\"this.conn.onerror\",\"_onConnError\",\"onmessage\",\"this.conn.onmessage\",\"_onConnClose\",\"_terminateWorker\",\"teardown\",\"then\",\"resolve\",\"catch\",\"worker\",\"workerRef\",\"_startWorkerHeartbeat\",\"_startHeartbeat\",\"setInterval\",\"workerUrl\",\"objectUrl\",\"_workerObjectUrl\",\"Worker\",\"this.workerRef.onerror\",\"this.workerRef.onmessage\",\"postMessage\",\"interval\",\"terminate\",\"_triggerChanError\",\"CHANNEL_EVENTS\",\"url\",\"keys\",\"prefix\",\"match\",\"query\",\"URLSearchParams\",\"blob\",\"Blob\",\"WORKER_SCRIPT\",\"type\",\"result_url\",\"URL\",\"createObjectURL\",\"state\",\"manual\",\"tokenToSend\",\"isManualToken\",\"access_token\",\"version\",\"DEFAULT_VERSION\",\"updateJoinPayload\",\"joinedOnce\",\"_push\",\"_waitForAuthIfNeeded\",\"context\",\"RECONNECT_DELAY\",\"reconnectAfterMs\",\"_b\",\"_c\",\"_d\",\"_e\",\"_f\",\"_g\",\"_h\",\"_j\",\"_k\",\"_l\",\"_m\",\"logLevel\",\"log_level\",\"tries\",\"DEFAULT_RECONNECT_FALLBACK\",\"VSN_1_0_0\",\"JSON\",\"stringify\",\"parse\",\"VSN_2_0_0\",\"bind\",\"window\"]\n}\n"]