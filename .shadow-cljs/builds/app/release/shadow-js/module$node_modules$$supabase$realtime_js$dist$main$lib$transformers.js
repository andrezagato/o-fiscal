["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/realtime-js/dist/main/lib/transformers.js"],"~:js","shadow$provide[25]=function(S,ka,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.httpEndpointURL=a.toTimestampString=a.toArray=a.toJson=a.toNumber=a.toBoolean=a.convertCell=a.convertColumn=a.convertChangeData=a.PostgresTypes=void 0;var I;(function(q){q.abstime=\"abstime\";q.bool=\"bool\";q.date=\"date\";q.daterange=\"daterange\";q.float4=\"float4\";q.float8=\"float8\";q.int2=\"int2\";q.int4=\"int4\";q.int4range=\"int4range\";q.int8=\"int8\";q.int8range=\"int8range\";q.json=\"json\";q.jsonb=\"jsonb\";q.money=\"money\";\nq.numeric=\"numeric\";q.oid=\"oid\";q.reltime=\"reltime\";q.text=\"text\";q.time=\"time\";q.timestamp=\"timestamp\";q.timestamptz=\"timestamptz\";q.timetz=\"timetz\";q.tsrange=\"tsrange\";q.tstzrange=\"tstzrange\"})(I||(a.PostgresTypes=I={}));a.convertChangeData=(q,D,C={})=>{var G;const E=(G=C.skipTypes)!==null&&G!==void 0?G:[];return D?Object.keys(D).reduce((M,d)=>{M[d]=(0,a.convertColumn)(d,q,D,E);return M},{}):{}};a.convertColumn=(q,D,C,G)=>{D=D.find(E=>E.name===q);D=D===null||D===void 0?void 0:D.type;C=C[q];return D&&\n!G.includes(D)?(0,a.convertCell)(D,C):C};a.convertCell=(q,D)=>{if(q.charAt(0)===\"_\")return q=q.slice(1,q.length),(0,a.toArray)(D,q);switch(q){case I.bool:return(0,a.toBoolean)(D);case I.float4:case I.float8:case I.int2:case I.int4:case I.int8:case I.numeric:case I.oid:return(0,a.toNumber)(D);case I.json:case I.jsonb:return(0,a.toJson)(D);case I.timestamp:return(0,a.toTimestampString)(D);case I.abstime:case I.date:case I.daterange:case I.int4range:case I.int8range:case I.money:case I.reltime:case I.text:case I.time:case I.timestamptz:case I.timetz:case I.tsrange:case I.tstzrange:return D;\ndefault:return D}};a.toBoolean=q=>{switch(q){case \"t\":return!0;case \"f\":return!1;default:return q}};a.toNumber=q=>{if(typeof q===\"string\"){const D=parseFloat(q);if(!Number.isNaN(D))return D}return q};a.toJson=q=>{if(typeof q===\"string\")try{return JSON.parse(q)}catch(D){}return q};a.toArray=(q,D)=>{if(typeof q!==\"string\")return q;const C=q.length-1,G=q[C];if(q[0]===\"{\"&&G===\"}\"){let E;q=q.slice(1,C);try{E=JSON.parse(\"[\"+q+\"]\")}catch(M){E=q?q.split(\",\"):[]}return E.map(M=>(0,a.convertCell)(D,M))}return q};\na.toTimestampString=q=>typeof q===\"string\"?q.replace(\" \",\"T\"):q;a.httpEndpointURL=q=>{q=new URL(q);q.protocol=q.protocol.replace(/^ws/i,\"http\");q.pathname=q.pathname.replace(/\\/+$/,\"\").replace(/\\/socket\\/websocket$/i,\"\").replace(/\\/socket$/i,\"\").replace(/\\/websocket$/i,\"\");q.pathname=q.pathname===\"\"||q.pathname===\"/\"?\"/api/broadcast\":q.pathname+\"/api/broadcast\";return q.href}}","~:source","shadow$provide[25] = function(require,module,exports) {\n\"use strict\";\r\n/**\r\n * Helpers to convert the change Payload into native JS types.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.httpEndpointURL = exports.toTimestampString = exports.toArray = exports.toJson = exports.toNumber = exports.toBoolean = exports.convertCell = exports.convertColumn = exports.convertChangeData = exports.PostgresTypes = void 0;\r\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\r\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\r\nvar PostgresTypes;\r\n(function (PostgresTypes) {\r\n    PostgresTypes[\"abstime\"] = \"abstime\";\r\n    PostgresTypes[\"bool\"] = \"bool\";\r\n    PostgresTypes[\"date\"] = \"date\";\r\n    PostgresTypes[\"daterange\"] = \"daterange\";\r\n    PostgresTypes[\"float4\"] = \"float4\";\r\n    PostgresTypes[\"float8\"] = \"float8\";\r\n    PostgresTypes[\"int2\"] = \"int2\";\r\n    PostgresTypes[\"int4\"] = \"int4\";\r\n    PostgresTypes[\"int4range\"] = \"int4range\";\r\n    PostgresTypes[\"int8\"] = \"int8\";\r\n    PostgresTypes[\"int8range\"] = \"int8range\";\r\n    PostgresTypes[\"json\"] = \"json\";\r\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\r\n    PostgresTypes[\"money\"] = \"money\";\r\n    PostgresTypes[\"numeric\"] = \"numeric\";\r\n    PostgresTypes[\"oid\"] = \"oid\";\r\n    PostgresTypes[\"reltime\"] = \"reltime\";\r\n    PostgresTypes[\"text\"] = \"text\";\r\n    PostgresTypes[\"time\"] = \"time\";\r\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\r\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\r\n    PostgresTypes[\"timetz\"] = \"timetz\";\r\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\r\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\r\n})(PostgresTypes || (exports.PostgresTypes = PostgresTypes = {}));\r\n/**\r\n * Takes an array of columns and an object of string values then converts each string value\r\n * to its mapped type.\r\n *\r\n * @param {{name: String, type: String}[]} columns\r\n * @param {Object} record\r\n * @param {Object} options The map of various options that can be applied to the mapper\r\n * @param {Array} options.skipTypes The array of types that should not be converted\r\n *\r\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\r\n * //=>{ first_name: 'Paul', age: 33 }\r\n */\r\nconst convertChangeData = (columns, record, options = {}) => {\r\n    var _a;\r\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\r\n    if (!record) {\r\n        return {};\r\n    }\r\n    return Object.keys(record).reduce((acc, rec_key) => {\r\n        acc[rec_key] = (0, exports.convertColumn)(rec_key, columns, record, skipTypes);\r\n        return acc;\r\n    }, {});\r\n};\r\nexports.convertChangeData = convertChangeData;\r\n/**\r\n * Converts the value of an individual column.\r\n *\r\n * @param {String} columnName The column that you want to convert\r\n * @param {{name: String, type: String}[]} columns All of the columns\r\n * @param {Object} record The map of string values\r\n * @param {Array} skipTypes An array of types that should not be converted\r\n * @return {object} Useless information\r\n *\r\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\r\n * //=> 33\r\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\r\n * //=> \"33\"\r\n */\r\nconst convertColumn = (columnName, columns, record, skipTypes) => {\r\n    const column = columns.find((x) => x.name === columnName);\r\n    const colType = column === null || column === void 0 ? void 0 : column.type;\r\n    const value = record[columnName];\r\n    if (colType && !skipTypes.includes(colType)) {\r\n        return (0, exports.convertCell)(colType, value);\r\n    }\r\n    return noop(value);\r\n};\r\nexports.convertColumn = convertColumn;\r\n/**\r\n * If the value of the cell is `null`, returns null.\r\n * Otherwise converts the string value to the correct type.\r\n * @param {String} type A postgres column type\r\n * @param {String} value The cell value\r\n *\r\n * @example convertCell('bool', 't')\r\n * //=> true\r\n * @example convertCell('int8', '10')\r\n * //=> 10\r\n * @example convertCell('_int4', '{1,2,3,4}')\r\n * //=> [1,2,3,4]\r\n */\r\nconst convertCell = (type, value) => {\r\n    // if data type is an array\r\n    if (type.charAt(0) === '_') {\r\n        const dataType = type.slice(1, type.length);\r\n        return (0, exports.toArray)(value, dataType);\r\n    }\r\n    // If not null, convert to correct type.\r\n    switch (type) {\r\n        case PostgresTypes.bool:\r\n            return (0, exports.toBoolean)(value);\r\n        case PostgresTypes.float4:\r\n        case PostgresTypes.float8:\r\n        case PostgresTypes.int2:\r\n        case PostgresTypes.int4:\r\n        case PostgresTypes.int8:\r\n        case PostgresTypes.numeric:\r\n        case PostgresTypes.oid:\r\n            return (0, exports.toNumber)(value);\r\n        case PostgresTypes.json:\r\n        case PostgresTypes.jsonb:\r\n            return (0, exports.toJson)(value);\r\n        case PostgresTypes.timestamp:\r\n            return (0, exports.toTimestampString)(value); // Format to be consistent with PostgREST\r\n        case PostgresTypes.abstime: // To allow users to cast it based on Timezone\r\n        case PostgresTypes.date: // To allow users to cast it based on Timezone\r\n        case PostgresTypes.daterange:\r\n        case PostgresTypes.int4range:\r\n        case PostgresTypes.int8range:\r\n        case PostgresTypes.money:\r\n        case PostgresTypes.reltime: // To allow users to cast it based on Timezone\r\n        case PostgresTypes.text:\r\n        case PostgresTypes.time: // To allow users to cast it based on Timezone\r\n        case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\r\n        case PostgresTypes.timetz: // To allow users to cast it based on Timezone\r\n        case PostgresTypes.tsrange:\r\n        case PostgresTypes.tstzrange:\r\n            return noop(value);\r\n        default:\r\n            // Return the value for remaining types\r\n            return noop(value);\r\n    }\r\n};\r\nexports.convertCell = convertCell;\r\nconst noop = (value) => {\r\n    return value;\r\n};\r\nconst toBoolean = (value) => {\r\n    switch (value) {\r\n        case 't':\r\n            return true;\r\n        case 'f':\r\n            return false;\r\n        default:\r\n            return value;\r\n    }\r\n};\r\nexports.toBoolean = toBoolean;\r\nconst toNumber = (value) => {\r\n    if (typeof value === 'string') {\r\n        const parsedValue = parseFloat(value);\r\n        if (!Number.isNaN(parsedValue)) {\r\n            return parsedValue;\r\n        }\r\n    }\r\n    return value;\r\n};\r\nexports.toNumber = toNumber;\r\nconst toJson = (value) => {\r\n    if (typeof value === 'string') {\r\n        try {\r\n            return JSON.parse(value);\r\n        }\r\n        catch (_a) {\r\n            return value;\r\n        }\r\n    }\r\n    return value;\r\n};\r\nexports.toJson = toJson;\r\n/**\r\n * Converts a Postgres Array into a native JS array\r\n *\r\n * @example toArray('{}', 'int4')\r\n * //=> []\r\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\r\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\r\n * @example toArray([1,2,3,4], 'int4')\r\n * //=> [1,2,3,4]\r\n */\r\nconst toArray = (value, type) => {\r\n    if (typeof value !== 'string') {\r\n        return value;\r\n    }\r\n    const lastIdx = value.length - 1;\r\n    const closeBrace = value[lastIdx];\r\n    const openBrace = value[0];\r\n    // Confirm value is a Postgres array by checking curly brackets\r\n    if (openBrace === '{' && closeBrace === '}') {\r\n        let arr;\r\n        const valTrim = value.slice(1, lastIdx);\r\n        // TODO: find a better solution to separate Postgres array data\r\n        try {\r\n            arr = JSON.parse('[' + valTrim + ']');\r\n        }\r\n        catch (_) {\r\n            // WARNING: splitting on comma does not cover all edge cases\r\n            arr = valTrim ? valTrim.split(',') : [];\r\n        }\r\n        return arr.map((val) => (0, exports.convertCell)(type, val));\r\n    }\r\n    return value;\r\n};\r\nexports.toArray = toArray;\r\n/**\r\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\r\n * See https://github.com/supabase/supabase/issues/18\r\n *\r\n * @example toTimestampString('2019-09-10 00:00:00')\r\n * //=> '2019-09-10T00:00:00'\r\n */\r\nconst toTimestampString = (value) => {\r\n    if (typeof value === 'string') {\r\n        return value.replace(' ', 'T');\r\n    }\r\n    return value;\r\n};\r\nexports.toTimestampString = toTimestampString;\r\nconst httpEndpointURL = (socketUrl) => {\r\n    const wsUrl = new URL(socketUrl);\r\n    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, 'http');\r\n    wsUrl.pathname = wsUrl.pathname\r\n        .replace(/\\/+$/, '') // remove all trailing slashes\r\n        .replace(/\\/socket\\/websocket$/i, '') // remove the socket/websocket path\r\n        .replace(/\\/socket$/i, '') // remove the socket path\r\n        .replace(/\\/websocket$/i, ''); // remove the websocket path\r\n    if (wsUrl.pathname === '' || wsUrl.pathname === '/') {\r\n        wsUrl.pathname = '/api/broadcast';\r\n    }\r\n    else {\r\n        wsUrl.pathname = wsUrl.pathname + '/api/broadcast';\r\n    }\r\n    return wsUrl.href;\r\n};\r\nexports.httpEndpointURL = httpEndpointURL;\r\n//# sourceMappingURL=transformers.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["toTimestampString","protocol","httpEndpointURL","pathname","__esModule","convertColumn","convertChangeData","PostgresTypes","value","convertCell","toBoolean","toJson","toNumber","toArray"]],"~:compiled-at",1771869280846,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$realtime_js$dist$main$lib$transformers.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/realtime-js/dist/main/lib/transformers.js\"],\n\"sourcesContent\":[\"shadow$provide[25] = function(require,module,exports) {\\n\\\"use strict\\\";\\r\\n/**\\r\\n * Helpers to convert the change Payload into native JS types.\\r\\n */\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.httpEndpointURL = exports.toTimestampString = exports.toArray = exports.toJson = exports.toNumber = exports.toBoolean = exports.convertCell = exports.convertColumn = exports.convertChangeData = exports.PostgresTypes = void 0;\\r\\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\\r\\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\\r\\nvar PostgresTypes;\\r\\n(function (PostgresTypes) {\\r\\n    PostgresTypes[\\\"abstime\\\"] = \\\"abstime\\\";\\r\\n    PostgresTypes[\\\"bool\\\"] = \\\"bool\\\";\\r\\n    PostgresTypes[\\\"date\\\"] = \\\"date\\\";\\r\\n    PostgresTypes[\\\"daterange\\\"] = \\\"daterange\\\";\\r\\n    PostgresTypes[\\\"float4\\\"] = \\\"float4\\\";\\r\\n    PostgresTypes[\\\"float8\\\"] = \\\"float8\\\";\\r\\n    PostgresTypes[\\\"int2\\\"] = \\\"int2\\\";\\r\\n    PostgresTypes[\\\"int4\\\"] = \\\"int4\\\";\\r\\n    PostgresTypes[\\\"int4range\\\"] = \\\"int4range\\\";\\r\\n    PostgresTypes[\\\"int8\\\"] = \\\"int8\\\";\\r\\n    PostgresTypes[\\\"int8range\\\"] = \\\"int8range\\\";\\r\\n    PostgresTypes[\\\"json\\\"] = \\\"json\\\";\\r\\n    PostgresTypes[\\\"jsonb\\\"] = \\\"jsonb\\\";\\r\\n    PostgresTypes[\\\"money\\\"] = \\\"money\\\";\\r\\n    PostgresTypes[\\\"numeric\\\"] = \\\"numeric\\\";\\r\\n    PostgresTypes[\\\"oid\\\"] = \\\"oid\\\";\\r\\n    PostgresTypes[\\\"reltime\\\"] = \\\"reltime\\\";\\r\\n    PostgresTypes[\\\"text\\\"] = \\\"text\\\";\\r\\n    PostgresTypes[\\\"time\\\"] = \\\"time\\\";\\r\\n    PostgresTypes[\\\"timestamp\\\"] = \\\"timestamp\\\";\\r\\n    PostgresTypes[\\\"timestamptz\\\"] = \\\"timestamptz\\\";\\r\\n    PostgresTypes[\\\"timetz\\\"] = \\\"timetz\\\";\\r\\n    PostgresTypes[\\\"tsrange\\\"] = \\\"tsrange\\\";\\r\\n    PostgresTypes[\\\"tstzrange\\\"] = \\\"tstzrange\\\";\\r\\n})(PostgresTypes || (exports.PostgresTypes = PostgresTypes = {}));\\r\\n/**\\r\\n * Takes an array of columns and an object of string values then converts each string value\\r\\n * to its mapped type.\\r\\n *\\r\\n * @param {{name: String, type: String}[]} columns\\r\\n * @param {Object} record\\r\\n * @param {Object} options The map of various options that can be applied to the mapper\\r\\n * @param {Array} options.skipTypes The array of types that should not be converted\\r\\n *\\r\\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\\r\\n * //=>{ first_name: 'Paul', age: 33 }\\r\\n */\\r\\nconst convertChangeData = (columns, record, options = {}) => {\\r\\n    var _a;\\r\\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\\r\\n    if (!record) {\\r\\n        return {};\\r\\n    }\\r\\n    return Object.keys(record).reduce((acc, rec_key) => {\\r\\n        acc[rec_key] = (0, exports.convertColumn)(rec_key, columns, record, skipTypes);\\r\\n        return acc;\\r\\n    }, {});\\r\\n};\\r\\nexports.convertChangeData = convertChangeData;\\r\\n/**\\r\\n * Converts the value of an individual column.\\r\\n *\\r\\n * @param {String} columnName The column that you want to convert\\r\\n * @param {{name: String, type: String}[]} columns All of the columns\\r\\n * @param {Object} record The map of string values\\r\\n * @param {Array} skipTypes An array of types that should not be converted\\r\\n * @return {object} Useless information\\r\\n *\\r\\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\\r\\n * //=> 33\\r\\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\\r\\n * //=> \\\"33\\\"\\r\\n */\\r\\nconst convertColumn = (columnName, columns, record, skipTypes) => {\\r\\n    const column = columns.find((x) => x.name === columnName);\\r\\n    const colType = column === null || column === void 0 ? void 0 : column.type;\\r\\n    const value = record[columnName];\\r\\n    if (colType && !skipTypes.includes(colType)) {\\r\\n        return (0, exports.convertCell)(colType, value);\\r\\n    }\\r\\n    return noop(value);\\r\\n};\\r\\nexports.convertColumn = convertColumn;\\r\\n/**\\r\\n * If the value of the cell is `null`, returns null.\\r\\n * Otherwise converts the string value to the correct type.\\r\\n * @param {String} type A postgres column type\\r\\n * @param {String} value The cell value\\r\\n *\\r\\n * @example convertCell('bool', 't')\\r\\n * //=> true\\r\\n * @example convertCell('int8', '10')\\r\\n * //=> 10\\r\\n * @example convertCell('_int4', '{1,2,3,4}')\\r\\n * //=> [1,2,3,4]\\r\\n */\\r\\nconst convertCell = (type, value) => {\\r\\n    // if data type is an array\\r\\n    if (type.charAt(0) === '_') {\\r\\n        const dataType = type.slice(1, type.length);\\r\\n        return (0, exports.toArray)(value, dataType);\\r\\n    }\\r\\n    // If not null, convert to correct type.\\r\\n    switch (type) {\\r\\n        case PostgresTypes.bool:\\r\\n            return (0, exports.toBoolean)(value);\\r\\n        case PostgresTypes.float4:\\r\\n        case PostgresTypes.float8:\\r\\n        case PostgresTypes.int2:\\r\\n        case PostgresTypes.int4:\\r\\n        case PostgresTypes.int8:\\r\\n        case PostgresTypes.numeric:\\r\\n        case PostgresTypes.oid:\\r\\n            return (0, exports.toNumber)(value);\\r\\n        case PostgresTypes.json:\\r\\n        case PostgresTypes.jsonb:\\r\\n            return (0, exports.toJson)(value);\\r\\n        case PostgresTypes.timestamp:\\r\\n            return (0, exports.toTimestampString)(value); // Format to be consistent with PostgREST\\r\\n        case PostgresTypes.abstime: // To allow users to cast it based on Timezone\\r\\n        case PostgresTypes.date: // To allow users to cast it based on Timezone\\r\\n        case PostgresTypes.daterange:\\r\\n        case PostgresTypes.int4range:\\r\\n        case PostgresTypes.int8range:\\r\\n        case PostgresTypes.money:\\r\\n        case PostgresTypes.reltime: // To allow users to cast it based on Timezone\\r\\n        case PostgresTypes.text:\\r\\n        case PostgresTypes.time: // To allow users to cast it based on Timezone\\r\\n        case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\\r\\n        case PostgresTypes.timetz: // To allow users to cast it based on Timezone\\r\\n        case PostgresTypes.tsrange:\\r\\n        case PostgresTypes.tstzrange:\\r\\n            return noop(value);\\r\\n        default:\\r\\n            // Return the value for remaining types\\r\\n            return noop(value);\\r\\n    }\\r\\n};\\r\\nexports.convertCell = convertCell;\\r\\nconst noop = (value) => {\\r\\n    return value;\\r\\n};\\r\\nconst toBoolean = (value) => {\\r\\n    switch (value) {\\r\\n        case 't':\\r\\n            return true;\\r\\n        case 'f':\\r\\n            return false;\\r\\n        default:\\r\\n            return value;\\r\\n    }\\r\\n};\\r\\nexports.toBoolean = toBoolean;\\r\\nconst toNumber = (value) => {\\r\\n    if (typeof value === 'string') {\\r\\n        const parsedValue = parseFloat(value);\\r\\n        if (!Number.isNaN(parsedValue)) {\\r\\n            return parsedValue;\\r\\n        }\\r\\n    }\\r\\n    return value;\\r\\n};\\r\\nexports.toNumber = toNumber;\\r\\nconst toJson = (value) => {\\r\\n    if (typeof value === 'string') {\\r\\n        try {\\r\\n            return JSON.parse(value);\\r\\n        }\\r\\n        catch (_a) {\\r\\n            return value;\\r\\n        }\\r\\n    }\\r\\n    return value;\\r\\n};\\r\\nexports.toJson = toJson;\\r\\n/**\\r\\n * Converts a Postgres Array into a native JS array\\r\\n *\\r\\n * @example toArray('{}', 'int4')\\r\\n * //=> []\\r\\n * @example toArray('{\\\"[2021-01-01,2021-12-31)\\\",\\\"(2021-01-01,2021-12-32]\\\"}', 'daterange')\\r\\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\\r\\n * @example toArray([1,2,3,4], 'int4')\\r\\n * //=> [1,2,3,4]\\r\\n */\\r\\nconst toArray = (value, type) => {\\r\\n    if (typeof value !== 'string') {\\r\\n        return value;\\r\\n    }\\r\\n    const lastIdx = value.length - 1;\\r\\n    const closeBrace = value[lastIdx];\\r\\n    const openBrace = value[0];\\r\\n    // Confirm value is a Postgres array by checking curly brackets\\r\\n    if (openBrace === '{' && closeBrace === '}') {\\r\\n        let arr;\\r\\n        const valTrim = value.slice(1, lastIdx);\\r\\n        // TODO: find a better solution to separate Postgres array data\\r\\n        try {\\r\\n            arr = JSON.parse('[' + valTrim + ']');\\r\\n        }\\r\\n        catch (_) {\\r\\n            // WARNING: splitting on comma does not cover all edge cases\\r\\n            arr = valTrim ? valTrim.split(',') : [];\\r\\n        }\\r\\n        return arr.map((val) => (0, exports.convertCell)(type, val));\\r\\n    }\\r\\n    return value;\\r\\n};\\r\\nexports.toArray = toArray;\\r\\n/**\\r\\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\\r\\n * See https://github.com/supabase/supabase/issues/18\\r\\n *\\r\\n * @example toTimestampString('2019-09-10 00:00:00')\\r\\n * //=> '2019-09-10T00:00:00'\\r\\n */\\r\\nconst toTimestampString = (value) => {\\r\\n    if (typeof value === 'string') {\\r\\n        return value.replace(' ', 'T');\\r\\n    }\\r\\n    return value;\\r\\n};\\r\\nexports.toTimestampString = toTimestampString;\\r\\nconst httpEndpointURL = (socketUrl) => {\\r\\n    const wsUrl = new URL(socketUrl);\\r\\n    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, 'http');\\r\\n    wsUrl.pathname = wsUrl.pathname\\r\\n        .replace(/\\\\/+$/, '') // remove all trailing slashes\\r\\n        .replace(/\\\\/socket\\\\/websocket$/i, '') // remove the socket/websocket path\\r\\n        .replace(/\\\\/socket$/i, '') // remove the socket path\\r\\n        .replace(/\\\\/websocket$/i, ''); // remove the websocket path\\r\\n    if (wsUrl.pathname === '' || wsUrl.pathname === '/') {\\r\\n        wsUrl.pathname = '/api/broadcast';\\r\\n    }\\r\\n    else {\\r\\n        wsUrl.pathname = wsUrl.pathname + '/api/broadcast';\\r\\n    }\\r\\n    return wsUrl.href;\\r\\n};\\r\\nexports.httpEndpointURL = httpEndpointURL;\\r\\n//# sourceMappingURL=transformers.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"httpEndpointURL\",\"toTimestampString\",\"toArray\",\"toJson\",\"toNumber\",\"toBoolean\",\"convertCell\",\"convertColumn\",\"convertChangeData\",\"PostgresTypes\",\"columns\",\"record\",\"options\",\"_a\",\"skipTypes\",\"keys\",\"reduce\",\"acc\",\"rec_key\",\"columnName\",\"column\",\"find\",\"x\",\"name\",\"colType\",\"type\",\"includes\",\"charAt\",\"dataType\",\"slice\",\"length\",\"bool\",\"float4\",\"float8\",\"int2\",\"int4\",\"int8\",\"numeric\",\"oid\",\"json\",\"jsonb\",\"timestamp\",\"abstime\",\"date\",\"daterange\",\"int4range\",\"int8range\",\"money\",\"reltime\",\"text\",\"time\",\"timestamptz\",\"timetz\",\"tsrange\",\"tstzrange\",\"parsedValue\",\"parseFloat\",\"Number\",\"isNaN\",\"JSON\",\"parse\",\"lastIdx\",\"closeBrace\",\"openBrace\",\"arr\",\"valTrim\",\"_\",\"split\",\"map\",\"val\",\"replace\",\"socketUrl\",\"wsUrl\",\"URL\",\"protocol\",\"pathname\",\"href\"]\n}\n"]