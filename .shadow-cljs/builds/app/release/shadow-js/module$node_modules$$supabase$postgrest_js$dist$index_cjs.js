["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/postgrest-js/dist/index.cjs"],"~:js","shadow$provide[19]=function(S,ka,a){function I(p){\"@babel/helpers - typeof\";return I=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(k){return typeof k}:function(k){return k&&\"function\"==typeof Symbol&&k.constructor===Symbol&&k!==Symbol.prototype?\"symbol\":typeof k},I(p)}function q(p,k){var y=Object.keys(p);if(Object.getOwnPropertySymbols){var v=Object.getOwnPropertySymbols(p);k&&(v=v.filter(function(z){return Object.getOwnPropertyDescriptor(p,z).enumerable}));y.push.apply(y,v)}return y}\nfunction D(p){for(var k=1;k<arguments.length;k++){var y=null!=arguments[k]?arguments[k]:{};k%2?q(Object(y),!0).forEach(function(v){var z,J=y[v];a:if(\"object\"==I(v)&&v){var l=v[Symbol.toPrimitive];if(void 0!==l){v=l.call(v,\"string\");if(\"object\"!=I(v))break a;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}v=String(v)}(z=\"symbol\"==I(v)?v:v+\"\")in p?Object.defineProperty(p,z,{value:J,enumerable:!0,configurable:!0,writable:!0}):p[z]=J}):Object.getOwnPropertyDescriptors?Object.defineProperties(p,\nObject.getOwnPropertyDescriptors(y)):q(Object(y)).forEach(function(v){Object.defineProperty(p,v,Object.getOwnPropertyDescriptor(y,v))})}return p}Object.defineProperty(a,\"__esModule\",{value:!0});var C=class extends Error{constructor(p){super(p.message);this.name=\"PostgrestError\";this.details=p.details;this.hint=p.hint;this.code=p.code}};S=class{constructor(p){var k,y,v;this.shouldThrowOnError=!1;this.method=p.method;this.url=p.url;this.headers=new Headers(p.headers);this.schema=p.schema;this.body=\np.body;this.shouldThrowOnError=(k=p.shouldThrowOnError)!==null&&k!==void 0?k:!1;this.signal=p.signal;this.isMaybeSingle=(y=p.isMaybeSingle)!==null&&y!==void 0?y:!1;this.urlLengthLimit=(v=p.urlLengthLimit)!==null&&v!==void 0?v:8E3;this.fetch=p.fetch?p.fetch:fetch}throwOnError(){this.shouldThrowOnError=!0;return this}setHeader(p,k){this.headers=new Headers(this.headers);this.headers.set(p,k);return this}then(p,k){var y=this;this.schema!==void 0&&([\"GET\",\"HEAD\"].includes(this.method)?this.headers.set(\"Accept-Profile\",\nthis.schema):this.headers.set(\"Content-Profile\",this.schema));this.method!==\"GET\"&&this.method!==\"HEAD\"&&this.headers.set(\"Content-Type\",\"application/json\");var v=this.fetch;v=v(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async z=>{let J=null,l=null,t=null,x=z.status,w=z.statusText;if(z.ok){var A,L;if(y.method!==\"HEAD\"){var P,T=await z.text();T!==\"\"&&(l=y.headers.get(\"Accept\")===\"text/csv\"?T:y.headers.get(\"Accept\")&&((P=y.headers.get(\"Accept\"))===\nnull||P===void 0?0:P.includes(\"application/vnd.pgrst.plan+text\"))?T:JSON.parse(T))}P=(A=y.headers.get(\"Prefer\"))===null||A===void 0?void 0:A.match(/count=(exact|planned|estimated)/);z=(L=z.headers.get(\"content-range\"))===null||L===void 0?void 0:L.split(\"/\");P&&z&&z.length>1&&(t=parseInt(z[1]));y.isMaybeSingle&&y.method===\"GET\"&&Array.isArray(l)&&(l.length>1?(J={code:\"PGRST116\",details:`Results contain ${l.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:\"JSON object requested, multiple (or no) rows returned\"},\nt=l=null,x=406,w=\"Not Acceptable\"):l=l.length===1?l[0]:null)}else{L=await z.text();try{J=JSON.parse(L),Array.isArray(J)&&z.status===404&&(l=[],J=null,x=200,w=\"OK\")}catch(Y){z.status===404&&L===\"\"?(x=204,w=\"No Content\"):J={message:L}}J&&y.isMaybeSingle&&(J===null||J===void 0||(T=J.details)===null||T===void 0?0:T.includes(\"0 rows\"))&&(J=null,x=200,w=\"OK\");if(J&&y.shouldThrowOnError)throw new C(J);}return{error:J,data:l,count:t,status:x,statusText:w}});this.shouldThrowOnError||(v=v.catch(z=>{var J,l;\nlet t=\"\",x=\"\";const w=z===null||z===void 0?void 0:z.cause;if(w){var A,L,P,T=(A=w===null||w===void 0?void 0:w.message)!==null&&A!==void 0?A:\"\";A=(l=w===null||w===void 0?void 0:w.code)!==null&&l!==void 0?l:\"\";l=`${(L=z===null||z===void 0?void 0:z.name)!==null&&L!==void 0?L:\"FetchError\"}: ${z===null||z===void 0?void 0:z.message}`;l+=`\\n\\nCaused by: ${(P=w===null||w===void 0?void 0:w.name)!==null&&P!==void 0?P:\"Error\"}: ${T}`;A&&(l+=` (${A})`);if(w===null||w===void 0?0:w.stack)l+=`\\n${w.stack}`}else l=\n(T=z===null||z===void 0?void 0:z.stack)!==null&&T!==void 0?T:\"\";L=this.url.toString().length;if((z===null||z===void 0?void 0:z.name)===\"AbortError\"||(z===null||z===void 0?void 0:z.code)===\"ABORT_ERR\")x=\"\",t=\"Request was aborted (timeout or manual cancellation)\",L>this.urlLengthLimit&&(t+=`. Note: Your request URL is ${L} characters, which may exceed server limits. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [many IDs])), consider using an RPC function to pass values server-side.`);\nelse if((w===null||w===void 0?void 0:w.name)===\"HeadersOverflowError\"||(w===null||w===void 0?void 0:w.code)===\"UND_ERR_HEADERS_OVERFLOW\")x=\"\",t=\"HTTP headers exceeded server limits (typically 16KB)\",L>this.urlLengthLimit&&(t+=`. Your request URL is ${L} characters. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [200+ IDs])), consider using an RPC function instead.`);return{error:{message:`${(J=z===null||z===void 0?void 0:z.name)!==null&&J!==void 0?\nJ:\"FetchError\"}: ${z===null||z===void 0?void 0:z.message}`,details:l,hint:t,code:x},data:null,count:null,status:0,statusText:\"\"}}));return v.then(p,k)}returns(){return this}overrideTypes(){return this}};ka=class extends S{select(p){let k=!1;p=(p!==null&&p!==void 0?p:\"*\").split(\"\").map(y=>{if(/\\s/.test(y)&&!k)return\"\";y==='\"'&&(k=!k);return y}).join(\"\");this.url.searchParams.set(\"select\",p);this.headers.append(\"Prefer\",\"return\\x3drepresentation\");return this}order(p,{ascending:k=!0,nullsFirst:y,foreignTable:v,\nreferencedTable:z=v}={}){v=z?`${z}.order`:\"order\";z=this.url.searchParams.get(v);this.url.searchParams.set(v,`${z?`${z},`:\"\"}${p}.${k?\"asc\":\"desc\"}${y===void 0?\"\":y?\".nullsfirst\":\".nullslast\"}`);return this}limit(p,{foreignTable:k,referencedTable:y=k}={}){this.url.searchParams.set(typeof y===\"undefined\"?\"limit\":`${y}.limit`,`${p}`);return this}range(p,k,{foreignTable:y,referencedTable:v=y}={}){y=typeof v===\"undefined\"?\"limit\":`${v}.limit`;this.url.searchParams.set(typeof v===\"undefined\"?\"offset\":\n`${v}.offset`,`${p}`);this.url.searchParams.set(y,`${k-p+1}`);return this}abortSignal(p){this.signal=p;return this}single(){this.headers.set(\"Accept\",\"application/vnd.pgrst.object+json\");return this}maybeSingle(){this.method===\"GET\"?this.headers.set(\"Accept\",\"application/json\"):this.headers.set(\"Accept\",\"application/vnd.pgrst.object+json\");this.isMaybeSingle=!0;return this}csv(){this.headers.set(\"Accept\",\"text/csv\");return this}geojson(){this.headers.set(\"Accept\",\"application/geo+json\");return this}explain({analyze:p=\n!1,verbose:k=!1,settings:y=!1,buffers:v=!1,wal:z=!1,format:J=\"text\"}={}){var l;p=[p?\"analyze\":null,k?\"verbose\":null,y?\"settings\":null,v?\"buffers\":null,z?\"wal\":null].filter(Boolean).join(\"|\");k=(l=this.headers.get(\"Accept\"))!==null&&l!==void 0?l:\"application/json\";this.headers.set(\"Accept\",`application/vnd.pgrst.plan+${J}; for=\"${k}\"; options=${p};`);return this}rollback(){this.headers.append(\"Prefer\",\"tx\\x3drollback\");return this}returns(){return this}maxAffected(p){this.headers.append(\"Prefer\",\"handling\\x3dstrict\");\nthis.headers.append(\"Prefer\",`max-affected=${p}`);return this}};const G=RegExp(\"[,()]\");var E=class extends ka{eq(p,k){this.url.searchParams.append(p,`eq.${k}`);return this}neq(p,k){this.url.searchParams.append(p,`neq.${k}`);return this}gt(p,k){this.url.searchParams.append(p,`gt.${k}`);return this}gte(p,k){this.url.searchParams.append(p,`gte.${k}`);return this}lt(p,k){this.url.searchParams.append(p,`lt.${k}`);return this}lte(p,k){this.url.searchParams.append(p,`lte.${k}`);return this}like(p,k){this.url.searchParams.append(p,\n`like.${k}`);return this}likeAllOf(p,k){this.url.searchParams.append(p,`like(all).{${k.join(\",\")}}`);return this}likeAnyOf(p,k){this.url.searchParams.append(p,`like(any).{${k.join(\",\")}}`);return this}ilike(p,k){this.url.searchParams.append(p,`ilike.${k}`);return this}ilikeAllOf(p,k){this.url.searchParams.append(p,`ilike(all).{${k.join(\",\")}}`);return this}ilikeAnyOf(p,k){this.url.searchParams.append(p,`ilike(any).{${k.join(\",\")}}`);return this}regexMatch(p,k){this.url.searchParams.append(p,`match.${k}`);\nreturn this}regexIMatch(p,k){this.url.searchParams.append(p,`imatch.${k}`);return this}is(p,k){this.url.searchParams.append(p,`is.${k}`);return this}isDistinct(p,k){this.url.searchParams.append(p,`isdistinct.${k}`);return this}in(p,k){k=Array.from(new Set(k)).map(y=>typeof y===\"string\"&&G.test(y)?`\"${y}\"`:`${y}`).join(\",\");this.url.searchParams.append(p,`in.(${k})`);return this}notIn(p,k){k=Array.from(new Set(k)).map(y=>typeof y===\"string\"&&G.test(y)?`\"${y}\"`:`${y}`).join(\",\");this.url.searchParams.append(p,\n`not.in.(${k})`);return this}contains(p,k){typeof k===\"string\"?this.url.searchParams.append(p,`cs.${k}`):Array.isArray(k)?this.url.searchParams.append(p,`cs.{${k.join(\",\")}}`):this.url.searchParams.append(p,`cs.${JSON.stringify(k)}`);return this}containedBy(p,k){typeof k===\"string\"?this.url.searchParams.append(p,`cd.${k}`):Array.isArray(k)?this.url.searchParams.append(p,`cd.{${k.join(\",\")}}`):this.url.searchParams.append(p,`cd.${JSON.stringify(k)}`);return this}rangeGt(p,k){this.url.searchParams.append(p,\n`sr.${k}`);return this}rangeGte(p,k){this.url.searchParams.append(p,`nxl.${k}`);return this}rangeLt(p,k){this.url.searchParams.append(p,`sl.${k}`);return this}rangeLte(p,k){this.url.searchParams.append(p,`nxr.${k}`);return this}rangeAdjacent(p,k){this.url.searchParams.append(p,`adj.${k}`);return this}overlaps(p,k){typeof k===\"string\"?this.url.searchParams.append(p,`ov.${k}`):this.url.searchParams.append(p,`ov.{${k.join(\",\")}}`);return this}textSearch(p,k,{config:y,type:v}={}){let z=\"\";v===\"plain\"?\nz=\"pl\":v===\"phrase\"?z=\"ph\":v===\"websearch\"&&(z=\"w\");this.url.searchParams.append(p,`${z}fts${y===void 0?\"\":`(${y})`}.${k}`);return this}match(p){Object.entries(p).forEach(([k,y])=>{this.url.searchParams.append(k,`eq.${y}`)});return this}not(p,k,y){this.url.searchParams.append(p,`not.${k}.${y}`);return this}or(p,{foreignTable:k,referencedTable:y=k}={}){this.url.searchParams.append(y?`${y}.or`:\"or\",`(${p})`);return this}filter(p,k,y){this.url.searchParams.append(p,`${k}.${y}`);return this}},M=class{constructor(p,\n{headers:k={},schema:y,fetch:v,urlLengthLimit:z=8E3}){this.url=p;this.headers=new Headers(k);this.schema=y;this.fetch=v;this.urlLengthLimit=z}cloneRequestState(){return{url:new URL(this.url.toString()),headers:new Headers(this.headers)}}select(p,k){const {head:y=!1,count:v}=k!==null&&k!==void 0?k:{};k=y?\"HEAD\":\"GET\";let z=!1;p=(p!==null&&p!==void 0?p:\"*\").split(\"\").map(t=>{if(/\\s/.test(t)&&!z)return\"\";t==='\"'&&(z=!z);return t}).join(\"\");const {url:J,headers:l}=this.cloneRequestState();J.searchParams.set(\"select\",\np);v&&l.append(\"Prefer\",`count=${v}`);return new E({method:k,url:J,headers:l,schema:this.schema,fetch:this.fetch,urlLengthLimit:this.urlLengthLimit})}insert(p,{count:k,defaultToNull:y=!0}={}){var v;const {url:z,headers:J}=this.cloneRequestState();k&&J.append(\"Prefer\",`count=${k}`);y||J.append(\"Prefer\",\"missing\\x3ddefault\");Array.isArray(p)&&(k=p.reduce((l,t)=>l.concat(Object.keys(t)),[]),k.length>0&&(k=[...(new Set(k))].map(l=>`\"${l}\"`),z.searchParams.set(\"columns\",k.join(\",\"))));return new E({method:\"POST\",\nurl:z,headers:J,schema:this.schema,body:p,fetch:(v=this.fetch)!==null&&v!==void 0?v:fetch,urlLengthLimit:this.urlLengthLimit})}upsert(p,{onConflict:k,ignoreDuplicates:y=!1,count:v,defaultToNull:z=!0}={}){var J;const {url:l,headers:t}=this.cloneRequestState();t.append(\"Prefer\",`resolution=${y?\"ignore\":\"merge\"}-duplicates`);k!==void 0&&l.searchParams.set(\"on_conflict\",k);v&&t.append(\"Prefer\",`count=${v}`);z||t.append(\"Prefer\",\"missing\\x3ddefault\");Array.isArray(p)&&(k=p.reduce((x,w)=>x.concat(Object.keys(w)),\n[]),k.length>0&&(k=[...(new Set(k))].map(x=>`\"${x}\"`),l.searchParams.set(\"columns\",k.join(\",\"))));return new E({method:\"POST\",url:l,headers:t,schema:this.schema,body:p,fetch:(J=this.fetch)!==null&&J!==void 0?J:fetch,urlLengthLimit:this.urlLengthLimit})}update(p,{count:k}={}){var y;const {url:v,headers:z}=this.cloneRequestState();k&&z.append(\"Prefer\",`count=${k}`);return new E({method:\"PATCH\",url:v,headers:z,schema:this.schema,body:p,fetch:(y=this.fetch)!==null&&y!==void 0?y:fetch,urlLengthLimit:this.urlLengthLimit})}delete({count:p}=\n{}){var k;const {url:y,headers:v}=this.cloneRequestState();p&&v.append(\"Prefer\",`count=${p}`);return new E({method:\"DELETE\",url:y,headers:v,schema:this.schema,fetch:(k=this.fetch)!==null&&k!==void 0?k:fetch,urlLengthLimit:this.urlLengthLimit})}},d=class p{constructor(k,{headers:y={},schema:v,fetch:z,timeout:J,urlLengthLimit:l=8E3}={}){this.url=k;this.headers=new Headers(y);this.schemaName=v;this.urlLengthLimit=l;const t=z!==null&&z!==void 0?z:globalThis.fetch;this.fetch=J!==void 0&&J>0?(x,w)=>{const A=\nnew AbortController,L=setTimeout(()=>A.abort(),J),P=w===null||w===void 0?void 0:w.signal;if(P){if(P.aborted)return clearTimeout(L),t(x,w);const T=()=>{clearTimeout(L);A.abort()};P.addEventListener(\"abort\",T,{once:!0});return t(x,D(D({},w),{},{signal:A.signal})).finally(()=>{clearTimeout(L);P.removeEventListener(\"abort\",T)})}return t(x,D(D({},w),{},{signal:A.signal})).finally(()=>clearTimeout(L))}:t}from(k){if(!k||typeof k!==\"string\"||k.trim()===\"\")throw Error(\"Invalid relation name: relation must be a non-empty string.\");\nreturn new M(new URL(`${this.url}/${k}`),{headers:new Headers(this.headers),schema:this.schemaName,fetch:this.fetch,urlLengthLimit:this.urlLengthLimit})}schema(k){return new p(this.url,{headers:this.headers,schema:k,fetch:this.fetch,urlLengthLimit:this.urlLengthLimit})}rpc(k,y={},{head:v=!1,get:z=!1,count:J}={}){var l;const t=new URL(`${this.url}/rpc/${k}`);let x;const w=A=>A!==null&&typeof A===\"object\"&&(!Array.isArray(A)||A.some(w));(k=v&&Object.values(y).some(w))?(v=\"POST\",x=y):v||z?(v=v?\"HEAD\":\n\"GET\",Object.entries(y).filter(([,A])=>A!==void 0).map(([A,L])=>[A,Array.isArray(L)?`{${L.join(\",\")}}`:`${L}`]).forEach(([A,L])=>{t.searchParams.append(A,L)})):(v=\"POST\",x=y);y=new Headers(this.headers);k?y.set(\"Prefer\",J?`count=${J},return=minimal`:\"return\\x3dminimal\"):J&&y.set(\"Prefer\",`count=${J}`);return new E({method:v,url:t,headers:y,schema:this.schemaName,body:x,fetch:(l=this.fetch)!==null&&l!==void 0?l:fetch,urlLengthLimit:this.urlLengthLimit})}},K={PostgrestClient:d,PostgrestQueryBuilder:M,\nPostgrestFilterBuilder:E,PostgrestTransformBuilder:ka,PostgrestBuilder:S,PostgrestError:C};a.PostgrestBuilder=S;a.PostgrestClient=d;a.PostgrestError=C;a.PostgrestFilterBuilder=E;a.PostgrestQueryBuilder=M;a.PostgrestTransformBuilder=ka;a.default=K}","~:source","shadow$provide[19] = function(require,module,exports) {\nObject.defineProperty(exports, '__esModule', { value: true });\n\n//#region src/PostgrestError.ts\n/**\n* Error format\n*\n* {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n*/\nvar PostgrestError = class extends Error {\n\t/**\n\t* @example\n\t* ```ts\n\t* import PostgrestError from '@supabase/postgrest-js'\n\t*\n\t* throw new PostgrestError({\n\t*   message: 'Row level security prevented the request',\n\t*   details: 'RLS denied the insert',\n\t*   hint: 'Check your policies',\n\t*   code: 'PGRST301',\n\t* })\n\t* ```\n\t*/\n\tconstructor(context) {\n\t\tsuper(context.message);\n\t\tthis.name = \"PostgrestError\";\n\t\tthis.details = context.details;\n\t\tthis.hint = context.hint;\n\t\tthis.code = context.code;\n\t}\n};\n\n//#endregion\n//#region src/PostgrestBuilder.ts\nvar PostgrestBuilder = class {\n\t/**\n\t* Creates a builder configured for a specific PostgREST request.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const builder = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: new Headers({ apikey: 'public-anon-key' }) }\n\t* )\n\t* ```\n\t*/\n\tconstructor(builder) {\n\t\tvar _builder$shouldThrowO, _builder$isMaybeSingl, _builder$urlLengthLim;\n\t\tthis.shouldThrowOnError = false;\n\t\tthis.method = builder.method;\n\t\tthis.url = builder.url;\n\t\tthis.headers = new Headers(builder.headers);\n\t\tthis.schema = builder.schema;\n\t\tthis.body = builder.body;\n\t\tthis.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;\n\t\tthis.signal = builder.signal;\n\t\tthis.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;\n\t\tthis.urlLengthLimit = (_builder$urlLengthLim = builder.urlLengthLimit) !== null && _builder$urlLengthLim !== void 0 ? _builder$urlLengthLim : 8e3;\n\t\tif (builder.fetch) this.fetch = builder.fetch;\n\t\telse this.fetch = fetch;\n\t}\n\t/**\n\t* If there's an error with the query, throwOnError will reject the promise by\n\t* throwing the error instead of returning it as part of a successful response.\n\t*\n\t* {@link https://github.com/supabase/supabase-js/issues/92}\n\t*/\n\tthrowOnError() {\n\t\tthis.shouldThrowOnError = true;\n\t\treturn this;\n\t}\n\t/**\n\t* Set an HTTP header for the request.\n\t*/\n\tsetHeader(name, value) {\n\t\tthis.headers = new Headers(this.headers);\n\t\tthis.headers.set(name, value);\n\t\treturn this;\n\t}\n\tthen(onfulfilled, onrejected) {\n\t\tvar _this = this;\n\t\tif (this.schema === void 0) {} else if ([\"GET\", \"HEAD\"].includes(this.method)) this.headers.set(\"Accept-Profile\", this.schema);\n\t\telse this.headers.set(\"Content-Profile\", this.schema);\n\t\tif (this.method !== \"GET\" && this.method !== \"HEAD\") this.headers.set(\"Content-Type\", \"application/json\");\n\t\tconst _fetch = this.fetch;\n\t\tlet res = _fetch(this.url.toString(), {\n\t\t\tmethod: this.method,\n\t\t\theaders: this.headers,\n\t\t\tbody: JSON.stringify(this.body),\n\t\t\tsignal: this.signal\n\t\t}).then(async (res$1) => {\n\t\t\tlet error = null;\n\t\t\tlet data = null;\n\t\t\tlet count = null;\n\t\t\tlet status = res$1.status;\n\t\t\tlet statusText = res$1.statusText;\n\t\t\tif (res$1.ok) {\n\t\t\t\tvar _this$headers$get2, _res$headers$get;\n\t\t\t\tif (_this.method !== \"HEAD\") {\n\t\t\t\t\tvar _this$headers$get;\n\t\t\t\t\tconst body = await res$1.text();\n\t\t\t\t\tif (body === \"\") {} else if (_this.headers.get(\"Accept\") === \"text/csv\") data = body;\n\t\t\t\t\telse if (_this.headers.get(\"Accept\") && ((_this$headers$get = _this.headers.get(\"Accept\")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes(\"application/vnd.pgrst.plan+text\"))) data = body;\n\t\t\t\t\telse data = JSON.parse(body);\n\t\t\t\t}\n\t\t\t\tconst countHeader = (_this$headers$get2 = _this.headers.get(\"Prefer\")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);\n\t\t\t\tconst contentRange = (_res$headers$get = res$1.headers.get(\"content-range\")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split(\"/\");\n\t\t\t\tif (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);\n\t\t\t\tif (_this.isMaybeSingle && _this.method === \"GET\" && Array.isArray(data)) if (data.length > 1) {\n\t\t\t\t\terror = {\n\t\t\t\t\t\tcode: \"PGRST116\",\n\t\t\t\t\t\tdetails: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n\t\t\t\t\t\thint: null,\n\t\t\t\t\t\tmessage: \"JSON object requested, multiple (or no) rows returned\"\n\t\t\t\t\t};\n\t\t\t\t\tdata = null;\n\t\t\t\t\tcount = null;\n\t\t\t\t\tstatus = 406;\n\t\t\t\t\tstatusText = \"Not Acceptable\";\n\t\t\t\t} else if (data.length === 1) data = data[0];\n\t\t\t\telse data = null;\n\t\t\t} else {\n\t\t\t\tvar _error$details;\n\t\t\t\tconst body = await res$1.text();\n\t\t\t\ttry {\n\t\t\t\t\terror = JSON.parse(body);\n\t\t\t\t\tif (Array.isArray(error) && res$1.status === 404) {\n\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\terror = null;\n\t\t\t\t\t\tstatus = 200;\n\t\t\t\t\t\tstatusText = \"OK\";\n\t\t\t\t\t}\n\t\t\t\t} catch (_unused) {\n\t\t\t\t\tif (res$1.status === 404 && body === \"\") {\n\t\t\t\t\t\tstatus = 204;\n\t\t\t\t\t\tstatusText = \"No Content\";\n\t\t\t\t\t} else error = { message: body };\n\t\t\t\t}\n\t\t\t\tif (error && _this.isMaybeSingle && (error === null || error === void 0 || (_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.includes(\"0 rows\"))) {\n\t\t\t\t\terror = null;\n\t\t\t\t\tstatus = 200;\n\t\t\t\t\tstatusText = \"OK\";\n\t\t\t\t}\n\t\t\t\tif (error && _this.shouldThrowOnError) throw new PostgrestError(error);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\terror,\n\t\t\t\tdata,\n\t\t\t\tcount,\n\t\t\t\tstatus,\n\t\t\t\tstatusText\n\t\t\t};\n\t\t});\n\t\tif (!this.shouldThrowOnError) res = res.catch((fetchError) => {\n\t\t\tvar _fetchError$name2;\n\t\t\tlet errorDetails = \"\";\n\t\t\tlet hint = \"\";\n\t\t\tlet code = \"\";\n\t\t\tconst cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;\n\t\t\tif (cause) {\n\t\t\t\tvar _cause$message, _cause$code, _fetchError$name, _cause$name;\n\t\t\t\tconst causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : \"\";\n\t\t\t\tconst causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : \"\";\n\t\t\t\terrorDetails = `${(_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;\n\t\t\t\terrorDetails += `\\n\\nCaused by: ${(_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : \"Error\"}: ${causeMessage}`;\n\t\t\t\tif (causeCode) errorDetails += ` (${causeCode})`;\n\t\t\t\tif (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += `\\n${cause.stack}`;\n\t\t\t} else {\n\t\t\t\tvar _fetchError$stack;\n\t\t\t\terrorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : \"\";\n\t\t\t}\n\t\t\tconst urlLength = this.url.toString().length;\n\t\t\tif ((fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) === \"AbortError\" || (fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) === \"ABORT_ERR\") {\n\t\t\t\tcode = \"\";\n\t\t\t\thint = \"Request was aborted (timeout or manual cancellation)\";\n\t\t\t\tif (urlLength > this.urlLengthLimit) hint += `. Note: Your request URL is ${urlLength} characters, which may exceed server limits. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [many IDs])), consider using an RPC function to pass values server-side.`;\n\t\t\t} else if ((cause === null || cause === void 0 ? void 0 : cause.name) === \"HeadersOverflowError\" || (cause === null || cause === void 0 ? void 0 : cause.code) === \"UND_ERR_HEADERS_OVERFLOW\") {\n\t\t\t\tcode = \"\";\n\t\t\t\thint = \"HTTP headers exceeded server limits (typically 16KB)\";\n\t\t\t\tif (urlLength > this.urlLengthLimit) hint += `. Your request URL is ${urlLength} characters. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [200+ IDs])), consider using an RPC function instead.`;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\terror: {\n\t\t\t\t\tmessage: `${(_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n\t\t\t\t\tdetails: errorDetails,\n\t\t\t\t\thint,\n\t\t\t\t\tcode\n\t\t\t\t},\n\t\t\t\tdata: null,\n\t\t\t\tcount: null,\n\t\t\t\tstatus: 0,\n\t\t\t\tstatusText: \"\"\n\t\t\t};\n\t\t});\n\t\treturn res.then(onfulfilled, onrejected);\n\t}\n\t/**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/\n\treturns() {\n\t\t/* istanbul ignore next */\n\t\treturn this;\n\t}\n\t/**\n\t* Override the type of the returned `data` field in the response.\n\t*\n\t* @typeParam NewResult - The new type to cast the response data to\n\t* @typeParam Options - Optional type configuration (defaults to { merge: true })\n\t* @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n\t* @example\n\t* ```typescript\n\t* // Merge with existing types (default behavior)\n\t* const query = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ custom_field: string }>()\n\t*\n\t* // Replace existing types completely\n\t* const replaceQuery = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n\t* ```\n\t* @returns A PostgrestBuilder instance with the new type\n\t*/\n\toverrideTypes() {\n\t\treturn this;\n\t}\n};\n\n//#endregion\n//#region src/PostgrestTransformBuilder.ts\nvar PostgrestTransformBuilder = class extends PostgrestBuilder {\n\t/**\n\t* Perform a SELECT on the query result.\n\t*\n\t* By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n\t* return modified rows. By calling this method, modified rows are returned in\n\t* `data`.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas\n\t*/\n\tselect(columns) {\n\t\tlet quoted = false;\n\t\tconst cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c) => {\n\t\t\tif (/\\s/.test(c) && !quoted) return \"\";\n\t\t\tif (c === \"\\\"\") quoted = !quoted;\n\t\t\treturn c;\n\t\t}).join(\"\");\n\t\tthis.url.searchParams.set(\"select\", cleanedColumns);\n\t\tthis.headers.append(\"Prefer\", \"return=representation\");\n\t\treturn this;\n\t}\n\t/**\n\t* Order the query result by `column`.\n\t*\n\t* You can call this method multiple times to order by multiple columns.\n\t*\n\t* You can order referenced tables, but it only affects the ordering of the\n\t* parent table if you use `!inner` in the query.\n\t*\n\t* @param column - The column to order by\n\t* @param options - Named parameters\n\t* @param options.ascending - If `true`, the result will be in ascending order\n\t* @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n\t* `null`s appear last.\n\t* @param options.referencedTable - Set this to order a referenced table by\n\t* its columns\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/\n\torder(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {\n\t\tconst key = referencedTable ? `${referencedTable}.order` : \"order\";\n\t\tconst existingOrder = this.url.searchParams.get(key);\n\t\tthis.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \"\"}${column}.${ascending ? \"asc\" : \"desc\"}${nullsFirst === void 0 ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Limit the query result by `count`.\n\t*\n\t* @param count - The maximum number of rows to return\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/\n\tlimit(count, { foreignTable, referencedTable = foreignTable } = {}) {\n\t\tconst key = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n\t\tthis.url.searchParams.set(key, `${count}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Limit the query result by starting at an offset `from` and ending at the offset `to`.\n\t* Only records within this range are returned.\n\t* This respects the query order and if there is no order clause the range could behave unexpectedly.\n\t* The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n\t* and fourth rows of the query.\n\t*\n\t* @param from - The starting index from which to limit the result\n\t* @param to - The last index to which to limit the result\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/\n\trange(from, to, { foreignTable, referencedTable = foreignTable } = {}) {\n\t\tconst keyOffset = typeof referencedTable === \"undefined\" ? \"offset\" : `${referencedTable}.offset`;\n\t\tconst keyLimit = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n\t\tthis.url.searchParams.set(keyOffset, `${from}`);\n\t\tthis.url.searchParams.set(keyLimit, `${to - from + 1}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Set the AbortSignal for the fetch request.\n\t*\n\t* @param signal - The AbortSignal to use for the fetch request\n\t*/\n\tabortSignal(signal) {\n\t\tthis.signal = signal;\n\t\treturn this;\n\t}\n\t/**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be one row (e.g. using `.limit(1)`), otherwise this\n\t* returns an error.\n\t*/\n\tsingle() {\n\t\tthis.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n\t\treturn this;\n\t}\n\t/**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n\t* this returns an error.\n\t*/\n\tmaybeSingle() {\n\t\tif (this.method === \"GET\") this.headers.set(\"Accept\", \"application/json\");\n\t\telse this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n\t\tthis.isMaybeSingle = true;\n\t\treturn this;\n\t}\n\t/**\n\t* Return `data` as a string in CSV format.\n\t*/\n\tcsv() {\n\t\tthis.headers.set(\"Accept\", \"text/csv\");\n\t\treturn this;\n\t}\n\t/**\n\t* Return `data` as an object in [GeoJSON](https://geojson.org) format.\n\t*/\n\tgeojson() {\n\t\tthis.headers.set(\"Accept\", \"application/geo+json\");\n\t\treturn this;\n\t}\n\t/**\n\t* Return `data` as the EXPLAIN plan for the query.\n\t*\n\t* You need to enable the\n\t* [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n\t* setting before using this method.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.analyze - If `true`, the query will be executed and the\n\t* actual run time will be returned\n\t*\n\t* @param options.verbose - If `true`, the query identifier will be returned\n\t* and `data` will include the output columns of the query\n\t*\n\t* @param options.settings - If `true`, include information on configuration\n\t* parameters that affect query planning\n\t*\n\t* @param options.buffers - If `true`, include information on buffer usage\n\t*\n\t* @param options.wal - If `true`, include information on WAL record generation\n\t*\n\t* @param options.format - The format of the output, can be `\"text\"` (default)\n\t* or `\"json\"`\n\t*/\n\texplain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \"text\" } = {}) {\n\t\tvar _this$headers$get;\n\t\tconst options = [\n\t\t\tanalyze ? \"analyze\" : null,\n\t\t\tverbose ? \"verbose\" : null,\n\t\t\tsettings ? \"settings\" : null,\n\t\t\tbuffers ? \"buffers\" : null,\n\t\t\twal ? \"wal\" : null\n\t\t].filter(Boolean).join(\"|\");\n\t\tconst forMediatype = (_this$headers$get = this.headers.get(\"Accept\")) !== null && _this$headers$get !== void 0 ? _this$headers$get : \"application/json\";\n\t\tthis.headers.set(\"Accept\", `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`);\n\t\tif (format === \"json\") return this;\n\t\telse return this;\n\t}\n\t/**\n\t* Rollback the query.\n\t*\n\t* `data` will still be returned, but the query is not committed.\n\t*/\n\trollback() {\n\t\tthis.headers.append(\"Prefer\", \"tx=rollback\");\n\t\treturn this;\n\t}\n\t/**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/\n\treturns() {\n\t\treturn this;\n\t}\n\t/**\n\t* Set the maximum number of rows that can be affected by the query.\n\t* Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n\t*\n\t* @param value - The maximum number of rows that can be affected\n\t*/\n\tmaxAffected(value) {\n\t\tthis.headers.append(\"Prefer\", \"handling=strict\");\n\t\tthis.headers.append(\"Prefer\", `max-affected=${value}`);\n\t\treturn this;\n\t}\n};\n\n//#endregion\n//#region src/PostgrestFilterBuilder.ts\nconst PostgrestReservedCharsRegexp = /* @__PURE__ */ new RegExp(\"[,()]\");\nvar PostgrestFilterBuilder = class extends PostgrestTransformBuilder {\n\t/**\n\t* Match only rows where `column` is equal to `value`.\n\t*\n\t* To check if the value of `column` is NULL, you should use `.is()` instead.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/\n\teq(column, value) {\n\t\tthis.url.searchParams.append(column, `eq.${value}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` is not equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/\n\tneq(column, value) {\n\t\tthis.url.searchParams.append(column, `neq.${value}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` is greater than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/\n\tgt(column, value) {\n\t\tthis.url.searchParams.append(column, `gt.${value}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` is greater than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/\n\tgte(column, value) {\n\t\tthis.url.searchParams.append(column, `gte.${value}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` is less than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/\n\tlt(column, value) {\n\t\tthis.url.searchParams.append(column, `lt.${value}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` is less than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/\n\tlte(column, value) {\n\t\tthis.url.searchParams.append(column, `lte.${value}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` matches `pattern` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/\n\tlike(column, pattern) {\n\t\tthis.url.searchParams.append(column, `like.${pattern}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` matches all of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/\n\tlikeAllOf(column, patterns) {\n\t\tthis.url.searchParams.append(column, `like(all).{${patterns.join(\",\")}}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` matches any of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/\n\tlikeAnyOf(column, patterns) {\n\t\tthis.url.searchParams.append(column, `like(any).{${patterns.join(\",\")}}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` matches `pattern` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/\n\tilike(column, pattern) {\n\t\tthis.url.searchParams.append(column, `ilike.${pattern}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` matches all of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/\n\tilikeAllOf(column, patterns) {\n\t\tthis.url.searchParams.append(column, `ilike(all).{${patterns.join(\",\")}}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` matches any of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/\n\tilikeAnyOf(column, patterns) {\n\t\tthis.url.searchParams.append(column, `ilike(any).{${patterns.join(\",\")}}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-sensitively (using the `~` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/\n\tregexMatch(column, pattern) {\n\t\tthis.url.searchParams.append(column, `match.${pattern}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-insensitively (using the `~*` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/\n\tregexIMatch(column, pattern) {\n\t\tthis.url.searchParams.append(column, `imatch.${pattern}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` IS `value`.\n\t*\n\t* For non-boolean columns, this is only relevant for checking if the value of\n\t* `column` is NULL by setting `value` to `null`.\n\t*\n\t* For boolean columns, you can also set `value` to `true` or `false` and it\n\t* will behave the same way as `.eq()`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/\n\tis(column, value) {\n\t\tthis.url.searchParams.append(column, `is.${value}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` IS DISTINCT FROM `value`.\n\t*\n\t* Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values\n\t* are considered equal (not distinct), and comparing `NULL` with any non-NULL\n\t* value returns true (distinct).\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/\n\tisDistinct(column, value) {\n\t\tthis.url.searchParams.append(column, `isdistinct.${value}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` is included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/\n\tin(column, values) {\n\t\tconst cleanedValues = Array.from(new Set(values)).map((s) => {\n\t\t\tif (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n\t\t\telse return `${s}`;\n\t\t}).join(\",\");\n\t\tthis.url.searchParams.append(column, `in.(${cleanedValues})`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where `column` is NOT included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/\n\tnotIn(column, values) {\n\t\tconst cleanedValues = Array.from(new Set(values)).map((s) => {\n\t\t\tif (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n\t\t\telse return `${s}`;\n\t\t}).join(\",\");\n\t\tthis.url.searchParams.append(column, `not.in.(${cleanedValues})`);\n\t\treturn this;\n\t}\n\t/**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* `column` contains every element appearing in `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/\n\tcontains(column, value) {\n\t\tif (typeof value === \"string\") this.url.searchParams.append(column, `cs.${value}`);\n\t\telse if (Array.isArray(value)) this.url.searchParams.append(column, `cs.{${value.join(\",\")}}`);\n\t\telse this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* every element appearing in `column` is contained by `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/\n\tcontainedBy(column, value) {\n\t\tif (typeof value === \"string\") this.url.searchParams.append(column, `cd.${value}`);\n\t\telse if (Array.isArray(value)) this.url.searchParams.append(column, `cd.{${value.join(\",\")}}`);\n\t\telse this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is greater than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/\n\trangeGt(column, range) {\n\t\tthis.url.searchParams.append(column, `sr.${range}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or greater than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/\n\trangeGte(column, range) {\n\t\tthis.url.searchParams.append(column, `nxl.${range}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is less than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/\n\trangeLt(column, range) {\n\t\tthis.url.searchParams.append(column, `sl.${range}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or less than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/\n\trangeLte(column, range) {\n\t\tthis.url.searchParams.append(column, `nxr.${range}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Only relevant for range columns. Match only rows where `column` is\n\t* mutually exclusive to `range` and there can be no element between the two\n\t* ranges.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/\n\trangeAdjacent(column, range) {\n\t\tthis.url.searchParams.append(column, `adj.${range}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Only relevant for array and range columns. Match only rows where\n\t* `column` and `value` have an element in common.\n\t*\n\t* @param column - The array or range column to filter on\n\t* @param value - The array or range value to filter with\n\t*/\n\toverlaps(column, value) {\n\t\tif (typeof value === \"string\") this.url.searchParams.append(column, `ov.${value}`);\n\t\telse this.url.searchParams.append(column, `ov.{${value.join(\",\")}}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Only relevant for text and tsvector columns. Match only rows where\n\t* `column` matches the query string in `query`.\n\t*\n\t* @param column - The text or tsvector column to filter on\n\t* @param query - The query text to match with\n\t* @param options - Named parameters\n\t* @param options.config - The text search configuration to use\n\t* @param options.type - Change how the `query` text is interpreted\n\t*/\n\ttextSearch(column, query, { config, type } = {}) {\n\t\tlet typePart = \"\";\n\t\tif (type === \"plain\") typePart = \"pl\";\n\t\telse if (type === \"phrase\") typePart = \"ph\";\n\t\telse if (type === \"websearch\") typePart = \"w\";\n\t\tconst configPart = config === void 0 ? \"\" : `(${config})`;\n\t\tthis.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows where each column in `query` keys is equal to its\n\t* associated value. Shorthand for multiple `.eq()`s.\n\t*\n\t* @param query - The object to filter with, with column names as keys mapped\n\t* to their filter values\n\t*/\n\tmatch(query) {\n\t\tObject.entries(query).forEach(([column, value]) => {\n\t\t\tthis.url.searchParams.append(column, `eq.${value}`);\n\t\t});\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows which doesn't satisfy the filter.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to be negated to filter with, following\n\t* PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/\n\tnot(column, operator, value) {\n\t\tthis.url.searchParams.append(column, `not.${operator}.${value}`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows which satisfy at least one of the filters.\n\t*\n\t* Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure it's properly sanitized.\n\t*\n\t* It's currently not possible to do an `.or()` filter across multiple tables.\n\t*\n\t* @param filters - The filters to use, following PostgREST syntax\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to filter on referenced tables\n\t* instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `referencedTable` instead\n\t*/\n\tor(filters, { foreignTable, referencedTable = foreignTable } = {}) {\n\t\tconst key = referencedTable ? `${referencedTable}.or` : \"or\";\n\t\tthis.url.searchParams.append(key, `(${filters})`);\n\t\treturn this;\n\t}\n\t/**\n\t* Match only rows which satisfy the filter. This is an escape hatch - you\n\t* should use the specific filter methods wherever possible.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to filter with, following PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/\n\tfilter(column, operator, value) {\n\t\tthis.url.searchParams.append(column, `${operator}.${value}`);\n\t\treturn this;\n\t}\n};\n\n//#endregion\n//#region src/PostgrestQueryBuilder.ts\nvar PostgrestQueryBuilder = class {\n\t/**\n\t* Creates a query builder scoped to a Postgres table or view.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const query = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: { apikey: 'public-anon-key' } }\n\t* )\n\t* ```\n\t*/\n\tconstructor(url, { headers = {}, schema, fetch: fetch$1, urlLengthLimit = 8e3 }) {\n\t\tthis.url = url;\n\t\tthis.headers = new Headers(headers);\n\t\tthis.schema = schema;\n\t\tthis.fetch = fetch$1;\n\t\tthis.urlLengthLimit = urlLengthLimit;\n\t}\n\t/**\n\t* Clone URL and headers to prevent shared state between operations.\n\t*/\n\tcloneRequestState() {\n\t\treturn {\n\t\t\turl: new URL(this.url.toString()),\n\t\t\theaders: new Headers(this.headers)\n\t\t};\n\t}\n\t/**\n\t* Perform a SELECT query on the table or view.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t*\n\t* @param options.count - Count algorithm to use to count rows in the table or view.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @remarks\n\t* When using `count` with `.range()` or `.limit()`, the returned `count` is the total number of rows\n\t* that match your filters, not the number of rows in the current page. Use this to build pagination UI.\n\t*/\n\tselect(columns, options) {\n\t\tconst { head = false, count } = options !== null && options !== void 0 ? options : {};\n\t\tconst method = head ? \"HEAD\" : \"GET\";\n\t\tlet quoted = false;\n\t\tconst cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c) => {\n\t\t\tif (/\\s/.test(c) && !quoted) return \"\";\n\t\t\tif (c === \"\\\"\") quoted = !quoted;\n\t\t\treturn c;\n\t\t}).join(\"\");\n\t\tconst { url, headers } = this.cloneRequestState();\n\t\turl.searchParams.set(\"select\", cleanedColumns);\n\t\tif (count) headers.append(\"Prefer\", `count=${count}`);\n\t\treturn new PostgrestFilterBuilder({\n\t\t\tmethod,\n\t\t\turl,\n\t\t\theaders,\n\t\t\tschema: this.schema,\n\t\t\tfetch: this.fetch,\n\t\t\turlLengthLimit: this.urlLengthLimit\n\t\t});\n\t}\n\t/**\n\t* Perform an INSERT into the table or view.\n\t*\n\t* By default, inserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to insert. Pass an object to insert a single row\n\t* or an array to insert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count inserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. Only applies for bulk\n\t* inserts.\n\t*/\n\tinsert(values, { count, defaultToNull = true } = {}) {\n\t\tvar _this$fetch;\n\t\tconst method = \"POST\";\n\t\tconst { url, headers } = this.cloneRequestState();\n\t\tif (count) headers.append(\"Prefer\", `count=${count}`);\n\t\tif (!defaultToNull) headers.append(\"Prefer\", `missing=default`);\n\t\tif (Array.isArray(values)) {\n\t\t\tconst columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n\t\t\tif (columns.length > 0) {\n\t\t\t\tconst uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n\t\t\t\turl.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n\t\t\t}\n\t\t}\n\t\treturn new PostgrestFilterBuilder({\n\t\t\tmethod,\n\t\t\turl,\n\t\t\theaders,\n\t\t\tschema: this.schema,\n\t\t\tbody: values,\n\t\t\tfetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch,\n\t\t\turlLengthLimit: this.urlLengthLimit\n\t\t});\n\t}\n\t/**\n\t* Perform an UPSERT on the table or view. Depending on the column(s) passed\n\t* to `onConflict`, `.upsert()` allows you to perform the equivalent of\n\t* `.insert()` if a row with the corresponding `onConflict` columns doesn't\n\t* exist, or if it does exist, perform an alternative action depending on\n\t* `ignoreDuplicates`.\n\t*\n\t* By default, upserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to upsert with. Pass an object to upsert a\n\t* single row or an array to upsert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n\t* duplicate rows are determined. Two rows are duplicates if all the\n\t* `onConflict` columns are equal.\n\t*\n\t* @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n\t* `false`, duplicate rows are merged with existing rows.\n\t*\n\t* @param options.count - Count algorithm to use to count upserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. This only applies when\n\t* inserting new rows, not when merging with existing rows under\n\t* `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n\t*\n\t* @example Upsert a single row using a unique key\n\t* ```ts\n\t* // Upserting a single row, overwriting based on the 'username' unique column\n\t* const { data, error } = await supabase\n\t*   .from('users')\n\t*   .upsert({ username: 'supabot' }, { onConflict: 'username' })\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     { id: 4, message: 'bar', username: 'supabot' }\n\t* //   ],\n\t* //   error: null\n\t* // }\n\t* ```\n\t*\n\t* @example Upsert with conflict resolution and exact row counting\n\t* ```ts\n\t* // Upserting and returning exact count\n\t* const { data, error, count } = await supabase\n\t*   .from('users')\n\t*   .upsert(\n\t*     {\n\t*       id: 3,\n\t*       message: 'foo',\n\t*       username: 'supabot'\n\t*     },\n\t*     {\n\t*       onConflict: 'username',\n\t*       count: 'exact'\n\t*     }\n\t*   )\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     {\n\t* //       id: 42,\n\t* //       handle: \"saoirse\",\n\t* //       display_name: \"Saoirse\"\n\t* //     }\n\t* //   ],\n\t* //   count: 1,\n\t* //   error: null\n\t* // }\n\t* ```\n\t*/\n\tupsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {\n\t\tvar _this$fetch2;\n\t\tconst method = \"POST\";\n\t\tconst { url, headers } = this.cloneRequestState();\n\t\theaders.append(\"Prefer\", `resolution=${ignoreDuplicates ? \"ignore\" : \"merge\"}-duplicates`);\n\t\tif (onConflict !== void 0) url.searchParams.set(\"on_conflict\", onConflict);\n\t\tif (count) headers.append(\"Prefer\", `count=${count}`);\n\t\tif (!defaultToNull) headers.append(\"Prefer\", \"missing=default\");\n\t\tif (Array.isArray(values)) {\n\t\t\tconst columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n\t\t\tif (columns.length > 0) {\n\t\t\t\tconst uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n\t\t\t\turl.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n\t\t\t}\n\t\t}\n\t\treturn new PostgrestFilterBuilder({\n\t\t\tmethod,\n\t\t\turl,\n\t\t\theaders,\n\t\t\tschema: this.schema,\n\t\t\tbody: values,\n\t\t\tfetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch,\n\t\t\turlLengthLimit: this.urlLengthLimit\n\t\t});\n\t}\n\t/**\n\t* Perform an UPDATE on the table or view.\n\t*\n\t* By default, updated rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param values - The values to update with\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count updated rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/\n\tupdate(values, { count } = {}) {\n\t\tvar _this$fetch3;\n\t\tconst method = \"PATCH\";\n\t\tconst { url, headers } = this.cloneRequestState();\n\t\tif (count) headers.append(\"Prefer\", `count=${count}`);\n\t\treturn new PostgrestFilterBuilder({\n\t\t\tmethod,\n\t\t\turl,\n\t\t\theaders,\n\t\t\tschema: this.schema,\n\t\t\tbody: values,\n\t\t\tfetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch,\n\t\t\turlLengthLimit: this.urlLengthLimit\n\t\t});\n\t}\n\t/**\n\t* Perform a DELETE on the table or view.\n\t*\n\t* By default, deleted rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count deleted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/\n\tdelete({ count } = {}) {\n\t\tvar _this$fetch4;\n\t\tconst method = \"DELETE\";\n\t\tconst { url, headers } = this.cloneRequestState();\n\t\tif (count) headers.append(\"Prefer\", `count=${count}`);\n\t\treturn new PostgrestFilterBuilder({\n\t\t\tmethod,\n\t\t\turl,\n\t\t\theaders,\n\t\t\tschema: this.schema,\n\t\t\tfetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch,\n\t\t\turlLengthLimit: this.urlLengthLimit\n\t\t});\n\t}\n};\n\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n\t\"@babel/helpers - typeof\";\n\treturn _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n\t\treturn typeof o$1;\n\t} : function(o$1) {\n\t\treturn o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n\t}, _typeof(o);\n}\n\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n\tif (\"object\" != _typeof(t) || !t) return t;\n\tvar e = t[Symbol.toPrimitive];\n\tif (void 0 !== e) {\n\t\tvar i = e.call(t, r || \"default\");\n\t\tif (\"object\" != _typeof(i)) return i;\n\t\tthrow new TypeError(\"@@toPrimitive must return a primitive value.\");\n\t}\n\treturn (\"string\" === r ? String : Number)(t);\n}\n\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n\tvar i = toPrimitive(t, \"string\");\n\treturn \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n\treturn (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n\t\tvalue: t,\n\t\tenumerable: !0,\n\t\tconfigurable: !0,\n\t\twritable: !0\n\t}) : e[r] = t, e;\n}\n\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n\tvar t = Object.keys(e);\n\tif (Object.getOwnPropertySymbols) {\n\t\tvar o = Object.getOwnPropertySymbols(e);\n\t\tr && (o = o.filter(function(r$1) {\n\t\t\treturn Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n\t\t})), t.push.apply(t, o);\n\t}\n\treturn t;\n}\nfunction _objectSpread2(e) {\n\tfor (var r = 1; r < arguments.length; r++) {\n\t\tvar t = null != arguments[r] ? arguments[r] : {};\n\t\tr % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n\t\t\t_defineProperty(e, r$1, t[r$1]);\n\t\t}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n\t\t\tObject.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n\t\t});\n\t}\n\treturn e;\n}\n\n//#endregion\n//#region src/PostgrestClient.ts\n/**\n* PostgREST client.\n*\n* @typeParam Database - Types for the schema from the [type\n* generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n*\n* @typeParam SchemaName - Postgres schema to switch to. Must be a string\n* literal, the same one passed to the constructor. If the schema is not\n* `\"public\"`, this must be supplied manually.\n*/\nvar PostgrestClient = class PostgrestClient {\n\t/**\n\t* Creates a PostgREST client.\n\t*\n\t* @param url - URL of the PostgREST endpoint\n\t* @param options - Named parameters\n\t* @param options.headers - Custom headers\n\t* @param options.schema - Postgres schema to switch to\n\t* @param options.fetch - Custom fetch\n\t* @param options.timeout - Optional timeout in milliseconds for all requests. When set, requests will automatically abort after this duration to prevent indefinite hangs.\n\t* @param options.urlLengthLimit - Maximum URL length in characters before warnings/errors are triggered. Defaults to 8000.\n\t* @example\n\t* ```ts\n\t* import PostgrestClient from '@supabase/postgrest-js'\n\t*\n\t* const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {\n\t*   headers: { apikey: 'public-anon-key' },\n\t*   schema: 'public',\n\t*   timeout: 30000, // 30 second timeout\n\t* })\n\t* ```\n\t*/\n\tconstructor(url, { headers = {}, schema, fetch: fetch$1, timeout, urlLengthLimit = 8e3 } = {}) {\n\t\tthis.url = url;\n\t\tthis.headers = new Headers(headers);\n\t\tthis.schemaName = schema;\n\t\tthis.urlLengthLimit = urlLengthLimit;\n\t\tconst originalFetch = fetch$1 !== null && fetch$1 !== void 0 ? fetch$1 : globalThis.fetch;\n\t\tif (timeout !== void 0 && timeout > 0) this.fetch = (input, init) => {\n\t\t\tconst controller = new AbortController();\n\t\t\tconst timeoutId = setTimeout(() => controller.abort(), timeout);\n\t\t\tconst existingSignal = init === null || init === void 0 ? void 0 : init.signal;\n\t\t\tif (existingSignal) {\n\t\t\t\tif (existingSignal.aborted) {\n\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t\treturn originalFetch(input, init);\n\t\t\t\t}\n\t\t\t\tconst abortHandler = () => {\n\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t\tcontroller.abort();\n\t\t\t\t};\n\t\t\t\texistingSignal.addEventListener(\"abort\", abortHandler, { once: true });\n\t\t\t\treturn originalFetch(input, _objectSpread2(_objectSpread2({}, init), {}, { signal: controller.signal })).finally(() => {\n\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t\texistingSignal.removeEventListener(\"abort\", abortHandler);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn originalFetch(input, _objectSpread2(_objectSpread2({}, init), {}, { signal: controller.signal })).finally(() => clearTimeout(timeoutId));\n\t\t};\n\t\telse this.fetch = originalFetch;\n\t}\n\t/**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/\n\tfrom(relation) {\n\t\tif (!relation || typeof relation !== \"string\" || relation.trim() === \"\") throw new Error(\"Invalid relation name: relation must be a non-empty string.\");\n\t\treturn new PostgrestQueryBuilder(new URL(`${this.url}/${relation}`), {\n\t\t\theaders: new Headers(this.headers),\n\t\t\tschema: this.schemaName,\n\t\t\tfetch: this.fetch,\n\t\t\turlLengthLimit: this.urlLengthLimit\n\t\t});\n\t}\n\t/**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/\n\tschema(schema) {\n\t\treturn new PostgrestClient(this.url, {\n\t\t\theaders: this.headers,\n\t\t\tschema,\n\t\t\tfetch: this.fetch,\n\t\t\turlLengthLimit: this.urlLengthLimit\n\t\t});\n\t}\n\t/**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @example\n\t* ```ts\n\t* // For cross-schema functions where type inference fails, use overrideTypes:\n\t* const { data } = await supabase\n\t*   .schema('schema_b')\n\t*   .rpc('function_a', {})\n\t*   .overrideTypes<{ id: string; user_id: string }[]>()\n\t* ```\n\t*/\n\trpc(fn, args = {}, { head = false, get = false, count } = {}) {\n\t\tvar _this$fetch;\n\t\tlet method;\n\t\tconst url = new URL(`${this.url}/rpc/${fn}`);\n\t\tlet body;\n\t\tconst _isObject = (v) => v !== null && typeof v === \"object\" && (!Array.isArray(v) || v.some(_isObject));\n\t\tconst _hasObjectArg = head && Object.values(args).some(_isObject);\n\t\tif (_hasObjectArg) {\n\t\t\tmethod = \"POST\";\n\t\t\tbody = args;\n\t\t} else if (head || get) {\n\t\t\tmethod = head ? \"HEAD\" : \"GET\";\n\t\t\tObject.entries(args).filter(([_, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(\",\")}}` : `${value}`]).forEach(([name, value]) => {\n\t\t\t\turl.searchParams.append(name, value);\n\t\t\t});\n\t\t} else {\n\t\t\tmethod = \"POST\";\n\t\t\tbody = args;\n\t\t}\n\t\tconst headers = new Headers(this.headers);\n\t\tif (_hasObjectArg) headers.set(\"Prefer\", count ? `count=${count},return=minimal` : \"return=minimal\");\n\t\telse if (count) headers.set(\"Prefer\", `count=${count}`);\n\t\treturn new PostgrestFilterBuilder({\n\t\t\tmethod,\n\t\t\turl,\n\t\t\theaders,\n\t\t\tschema: this.schemaName,\n\t\t\tbody,\n\t\t\tfetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch,\n\t\t\turlLengthLimit: this.urlLengthLimit\n\t\t});\n\t}\n};\n\n//#endregion\n//#region src/index.ts\nvar src_default = {\n\tPostgrestClient,\n\tPostgrestQueryBuilder,\n\tPostgrestFilterBuilder,\n\tPostgrestTransformBuilder,\n\tPostgrestBuilder,\n\tPostgrestError\n};\n\n//#endregion\nexports.PostgrestBuilder = PostgrestBuilder;\nexports.PostgrestClient = PostgrestClient;\nexports.PostgrestError = PostgrestError;\nexports.PostgrestFilterBuilder = PostgrestFilterBuilder;\nexports.PostgrestQueryBuilder = PostgrestQueryBuilder;\nexports.PostgrestTransformBuilder = PostgrestTransformBuilder;\nexports.default = src_default;\n//# sourceMappingURL=index.cjs.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["message","urlLengthLimit","hint","PostgrestClient","fetch","schemaName","url","body","once","isMaybeSingle","method","__esModule","schema","error","count","signal","name","configurable","value","enumerable","status","PostgrestQueryBuilder","statusText","writable","shouldThrowOnError","PostgrestError","PostgrestFilterBuilder","PostgrestTransformBuilder","details","data","default","code","PostgrestBuilder","headers"]],"~:compiled-at",1771991938817,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$postgrest_js$dist$index_cjs.js\",\n\"lineCount\":29,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/postgrest-js/dist/index.cjs\"],\n\"sourcesContent\":[\"shadow$provide[19] = function(require,module,exports) {\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\n//#region src/PostgrestError.ts\\n/**\\n* Error format\\n*\\n* {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\\n*/\\nvar PostgrestError = class extends Error {\\n\\t/**\\n\\t* @example\\n\\t* ```ts\\n\\t* import PostgrestError from '@supabase/postgrest-js'\\n\\t*\\n\\t* throw new PostgrestError({\\n\\t*   message: 'Row level security prevented the request',\\n\\t*   details: 'RLS denied the insert',\\n\\t*   hint: 'Check your policies',\\n\\t*   code: 'PGRST301',\\n\\t* })\\n\\t* ```\\n\\t*/\\n\\tconstructor(context) {\\n\\t\\tsuper(context.message);\\n\\t\\tthis.name = \\\"PostgrestError\\\";\\n\\t\\tthis.details = context.details;\\n\\t\\tthis.hint = context.hint;\\n\\t\\tthis.code = context.code;\\n\\t}\\n};\\n\\n//#endregion\\n//#region src/PostgrestBuilder.ts\\nvar PostgrestBuilder = class {\\n\\t/**\\n\\t* Creates a builder configured for a specific PostgREST request.\\n\\t*\\n\\t* @example\\n\\t* ```ts\\n\\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\\n\\t*\\n\\t* const builder = new PostgrestQueryBuilder(\\n\\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\\n\\t*   { headers: new Headers({ apikey: 'public-anon-key' }) }\\n\\t* )\\n\\t* ```\\n\\t*/\\n\\tconstructor(builder) {\\n\\t\\tvar _builder$shouldThrowO, _builder$isMaybeSingl, _builder$urlLengthLim;\\n\\t\\tthis.shouldThrowOnError = false;\\n\\t\\tthis.method = builder.method;\\n\\t\\tthis.url = builder.url;\\n\\t\\tthis.headers = new Headers(builder.headers);\\n\\t\\tthis.schema = builder.schema;\\n\\t\\tthis.body = builder.body;\\n\\t\\tthis.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;\\n\\t\\tthis.signal = builder.signal;\\n\\t\\tthis.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;\\n\\t\\tthis.urlLengthLimit = (_builder$urlLengthLim = builder.urlLengthLimit) !== null && _builder$urlLengthLim !== void 0 ? _builder$urlLengthLim : 8e3;\\n\\t\\tif (builder.fetch) this.fetch = builder.fetch;\\n\\t\\telse this.fetch = fetch;\\n\\t}\\n\\t/**\\n\\t* If there's an error with the query, throwOnError will reject the promise by\\n\\t* throwing the error instead of returning it as part of a successful response.\\n\\t*\\n\\t* {@link https://github.com/supabase/supabase-js/issues/92}\\n\\t*/\\n\\tthrowOnError() {\\n\\t\\tthis.shouldThrowOnError = true;\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Set an HTTP header for the request.\\n\\t*/\\n\\tsetHeader(name, value) {\\n\\t\\tthis.headers = new Headers(this.headers);\\n\\t\\tthis.headers.set(name, value);\\n\\t\\treturn this;\\n\\t}\\n\\tthen(onfulfilled, onrejected) {\\n\\t\\tvar _this = this;\\n\\t\\tif (this.schema === void 0) {} else if ([\\\"GET\\\", \\\"HEAD\\\"].includes(this.method)) this.headers.set(\\\"Accept-Profile\\\", this.schema);\\n\\t\\telse this.headers.set(\\\"Content-Profile\\\", this.schema);\\n\\t\\tif (this.method !== \\\"GET\\\" && this.method !== \\\"HEAD\\\") this.headers.set(\\\"Content-Type\\\", \\\"application/json\\\");\\n\\t\\tconst _fetch = this.fetch;\\n\\t\\tlet res = _fetch(this.url.toString(), {\\n\\t\\t\\tmethod: this.method,\\n\\t\\t\\theaders: this.headers,\\n\\t\\t\\tbody: JSON.stringify(this.body),\\n\\t\\t\\tsignal: this.signal\\n\\t\\t}).then(async (res$1) => {\\n\\t\\t\\tlet error = null;\\n\\t\\t\\tlet data = null;\\n\\t\\t\\tlet count = null;\\n\\t\\t\\tlet status = res$1.status;\\n\\t\\t\\tlet statusText = res$1.statusText;\\n\\t\\t\\tif (res$1.ok) {\\n\\t\\t\\t\\tvar _this$headers$get2, _res$headers$get;\\n\\t\\t\\t\\tif (_this.method !== \\\"HEAD\\\") {\\n\\t\\t\\t\\t\\tvar _this$headers$get;\\n\\t\\t\\t\\t\\tconst body = await res$1.text();\\n\\t\\t\\t\\t\\tif (body === \\\"\\\") {} else if (_this.headers.get(\\\"Accept\\\") === \\\"text/csv\\\") data = body;\\n\\t\\t\\t\\t\\telse if (_this.headers.get(\\\"Accept\\\") && ((_this$headers$get = _this.headers.get(\\\"Accept\\\")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes(\\\"application/vnd.pgrst.plan+text\\\"))) data = body;\\n\\t\\t\\t\\t\\telse data = JSON.parse(body);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tconst countHeader = (_this$headers$get2 = _this.headers.get(\\\"Prefer\\\")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);\\n\\t\\t\\t\\tconst contentRange = (_res$headers$get = res$1.headers.get(\\\"content-range\\\")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split(\\\"/\\\");\\n\\t\\t\\t\\tif (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);\\n\\t\\t\\t\\tif (_this.isMaybeSingle && _this.method === \\\"GET\\\" && Array.isArray(data)) if (data.length > 1) {\\n\\t\\t\\t\\t\\terror = {\\n\\t\\t\\t\\t\\t\\tcode: \\\"PGRST116\\\",\\n\\t\\t\\t\\t\\t\\tdetails: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\\n\\t\\t\\t\\t\\t\\thint: null,\\n\\t\\t\\t\\t\\t\\tmessage: \\\"JSON object requested, multiple (or no) rows returned\\\"\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\tdata = null;\\n\\t\\t\\t\\t\\tcount = null;\\n\\t\\t\\t\\t\\tstatus = 406;\\n\\t\\t\\t\\t\\tstatusText = \\\"Not Acceptable\\\";\\n\\t\\t\\t\\t} else if (data.length === 1) data = data[0];\\n\\t\\t\\t\\telse data = null;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar _error$details;\\n\\t\\t\\t\\tconst body = await res$1.text();\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\terror = JSON.parse(body);\\n\\t\\t\\t\\t\\tif (Array.isArray(error) && res$1.status === 404) {\\n\\t\\t\\t\\t\\t\\tdata = [];\\n\\t\\t\\t\\t\\t\\terror = null;\\n\\t\\t\\t\\t\\t\\tstatus = 200;\\n\\t\\t\\t\\t\\t\\tstatusText = \\\"OK\\\";\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch (_unused) {\\n\\t\\t\\t\\t\\tif (res$1.status === 404 && body === \\\"\\\") {\\n\\t\\t\\t\\t\\t\\tstatus = 204;\\n\\t\\t\\t\\t\\t\\tstatusText = \\\"No Content\\\";\\n\\t\\t\\t\\t\\t} else error = { message: body };\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (error && _this.isMaybeSingle && (error === null || error === void 0 || (_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.includes(\\\"0 rows\\\"))) {\\n\\t\\t\\t\\t\\terror = null;\\n\\t\\t\\t\\t\\tstatus = 200;\\n\\t\\t\\t\\t\\tstatusText = \\\"OK\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (error && _this.shouldThrowOnError) throw new PostgrestError(error);\\n\\t\\t\\t}\\n\\t\\t\\treturn {\\n\\t\\t\\t\\terror,\\n\\t\\t\\t\\tdata,\\n\\t\\t\\t\\tcount,\\n\\t\\t\\t\\tstatus,\\n\\t\\t\\t\\tstatusText\\n\\t\\t\\t};\\n\\t\\t});\\n\\t\\tif (!this.shouldThrowOnError) res = res.catch((fetchError) => {\\n\\t\\t\\tvar _fetchError$name2;\\n\\t\\t\\tlet errorDetails = \\\"\\\";\\n\\t\\t\\tlet hint = \\\"\\\";\\n\\t\\t\\tlet code = \\\"\\\";\\n\\t\\t\\tconst cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;\\n\\t\\t\\tif (cause) {\\n\\t\\t\\t\\tvar _cause$message, _cause$code, _fetchError$name, _cause$name;\\n\\t\\t\\t\\tconst causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : \\\"\\\";\\n\\t\\t\\t\\tconst causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : \\\"\\\";\\n\\t\\t\\t\\terrorDetails = `${(_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : \\\"FetchError\\\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;\\n\\t\\t\\t\\terrorDetails += `\\\\n\\\\nCaused by: ${(_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : \\\"Error\\\"}: ${causeMessage}`;\\n\\t\\t\\t\\tif (causeCode) errorDetails += ` (${causeCode})`;\\n\\t\\t\\t\\tif (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += `\\\\n${cause.stack}`;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar _fetchError$stack;\\n\\t\\t\\t\\terrorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : \\\"\\\";\\n\\t\\t\\t}\\n\\t\\t\\tconst urlLength = this.url.toString().length;\\n\\t\\t\\tif ((fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) === \\\"AbortError\\\" || (fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) === \\\"ABORT_ERR\\\") {\\n\\t\\t\\t\\tcode = \\\"\\\";\\n\\t\\t\\t\\thint = \\\"Request was aborted (timeout or manual cancellation)\\\";\\n\\t\\t\\t\\tif (urlLength > this.urlLengthLimit) hint += `. Note: Your request URL is ${urlLength} characters, which may exceed server limits. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [many IDs])), consider using an RPC function to pass values server-side.`;\\n\\t\\t\\t} else if ((cause === null || cause === void 0 ? void 0 : cause.name) === \\\"HeadersOverflowError\\\" || (cause === null || cause === void 0 ? void 0 : cause.code) === \\\"UND_ERR_HEADERS_OVERFLOW\\\") {\\n\\t\\t\\t\\tcode = \\\"\\\";\\n\\t\\t\\t\\thint = \\\"HTTP headers exceeded server limits (typically 16KB)\\\";\\n\\t\\t\\t\\tif (urlLength > this.urlLengthLimit) hint += `. Your request URL is ${urlLength} characters. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [200+ IDs])), consider using an RPC function instead.`;\\n\\t\\t\\t}\\n\\t\\t\\treturn {\\n\\t\\t\\t\\terror: {\\n\\t\\t\\t\\t\\tmessage: `${(_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : \\\"FetchError\\\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\\n\\t\\t\\t\\t\\tdetails: errorDetails,\\n\\t\\t\\t\\t\\thint,\\n\\t\\t\\t\\t\\tcode\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tdata: null,\\n\\t\\t\\t\\tcount: null,\\n\\t\\t\\t\\tstatus: 0,\\n\\t\\t\\t\\tstatusText: \\\"\\\"\\n\\t\\t\\t};\\n\\t\\t});\\n\\t\\treturn res.then(onfulfilled, onrejected);\\n\\t}\\n\\t/**\\n\\t* Override the type of the returned `data`.\\n\\t*\\n\\t* @typeParam NewResult - The new result type to override with\\n\\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\\n\\t*/\\n\\treturns() {\\n\\t\\t/* istanbul ignore next */\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Override the type of the returned `data` field in the response.\\n\\t*\\n\\t* @typeParam NewResult - The new type to cast the response data to\\n\\t* @typeParam Options - Optional type configuration (defaults to { merge: true })\\n\\t* @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\\n\\t* @example\\n\\t* ```typescript\\n\\t* // Merge with existing types (default behavior)\\n\\t* const query = supabase\\n\\t*   .from('users')\\n\\t*   .select()\\n\\t*   .overrideTypes<{ custom_field: string }>()\\n\\t*\\n\\t* // Replace existing types completely\\n\\t* const replaceQuery = supabase\\n\\t*   .from('users')\\n\\t*   .select()\\n\\t*   .overrideTypes<{ id: number; name: string }, { merge: false }>()\\n\\t* ```\\n\\t* @returns A PostgrestBuilder instance with the new type\\n\\t*/\\n\\toverrideTypes() {\\n\\t\\treturn this;\\n\\t}\\n};\\n\\n//#endregion\\n//#region src/PostgrestTransformBuilder.ts\\nvar PostgrestTransformBuilder = class extends PostgrestBuilder {\\n\\t/**\\n\\t* Perform a SELECT on the query result.\\n\\t*\\n\\t* By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\\n\\t* return modified rows. By calling this method, modified rows are returned in\\n\\t* `data`.\\n\\t*\\n\\t* @param columns - The columns to retrieve, separated by commas\\n\\t*/\\n\\tselect(columns) {\\n\\t\\tlet quoted = false;\\n\\t\\tconst cleanedColumns = (columns !== null && columns !== void 0 ? columns : \\\"*\\\").split(\\\"\\\").map((c) => {\\n\\t\\t\\tif (/\\\\s/.test(c) && !quoted) return \\\"\\\";\\n\\t\\t\\tif (c === \\\"\\\\\\\"\\\") quoted = !quoted;\\n\\t\\t\\treturn c;\\n\\t\\t}).join(\\\"\\\");\\n\\t\\tthis.url.searchParams.set(\\\"select\\\", cleanedColumns);\\n\\t\\tthis.headers.append(\\\"Prefer\\\", \\\"return=representation\\\");\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Order the query result by `column`.\\n\\t*\\n\\t* You can call this method multiple times to order by multiple columns.\\n\\t*\\n\\t* You can order referenced tables, but it only affects the ordering of the\\n\\t* parent table if you use `!inner` in the query.\\n\\t*\\n\\t* @param column - The column to order by\\n\\t* @param options - Named parameters\\n\\t* @param options.ascending - If `true`, the result will be in ascending order\\n\\t* @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\\n\\t* `null`s appear last.\\n\\t* @param options.referencedTable - Set this to order a referenced table by\\n\\t* its columns\\n\\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\\n\\t* instead\\n\\t*/\\n\\torder(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {\\n\\t\\tconst key = referencedTable ? `${referencedTable}.order` : \\\"order\\\";\\n\\t\\tconst existingOrder = this.url.searchParams.get(key);\\n\\t\\tthis.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \\\"\\\"}${column}.${ascending ? \\\"asc\\\" : \\\"desc\\\"}${nullsFirst === void 0 ? \\\"\\\" : nullsFirst ? \\\".nullsfirst\\\" : \\\".nullslast\\\"}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Limit the query result by `count`.\\n\\t*\\n\\t* @param count - The maximum number of rows to return\\n\\t* @param options - Named parameters\\n\\t* @param options.referencedTable - Set this to limit rows of referenced\\n\\t* tables instead of the parent table\\n\\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\\n\\t* instead\\n\\t*/\\n\\tlimit(count, { foreignTable, referencedTable = foreignTable } = {}) {\\n\\t\\tconst key = typeof referencedTable === \\\"undefined\\\" ? \\\"limit\\\" : `${referencedTable}.limit`;\\n\\t\\tthis.url.searchParams.set(key, `${count}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Limit the query result by starting at an offset `from` and ending at the offset `to`.\\n\\t* Only records within this range are returned.\\n\\t* This respects the query order and if there is no order clause the range could behave unexpectedly.\\n\\t* The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\\n\\t* and fourth rows of the query.\\n\\t*\\n\\t* @param from - The starting index from which to limit the result\\n\\t* @param to - The last index to which to limit the result\\n\\t* @param options - Named parameters\\n\\t* @param options.referencedTable - Set this to limit rows of referenced\\n\\t* tables instead of the parent table\\n\\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\\n\\t* instead\\n\\t*/\\n\\trange(from, to, { foreignTable, referencedTable = foreignTable } = {}) {\\n\\t\\tconst keyOffset = typeof referencedTable === \\\"undefined\\\" ? \\\"offset\\\" : `${referencedTable}.offset`;\\n\\t\\tconst keyLimit = typeof referencedTable === \\\"undefined\\\" ? \\\"limit\\\" : `${referencedTable}.limit`;\\n\\t\\tthis.url.searchParams.set(keyOffset, `${from}`);\\n\\t\\tthis.url.searchParams.set(keyLimit, `${to - from + 1}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Set the AbortSignal for the fetch request.\\n\\t*\\n\\t* @param signal - The AbortSignal to use for the fetch request\\n\\t*/\\n\\tabortSignal(signal) {\\n\\t\\tthis.signal = signal;\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Return `data` as a single object instead of an array of objects.\\n\\t*\\n\\t* Query result must be one row (e.g. using `.limit(1)`), otherwise this\\n\\t* returns an error.\\n\\t*/\\n\\tsingle() {\\n\\t\\tthis.headers.set(\\\"Accept\\\", \\\"application/vnd.pgrst.object+json\\\");\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Return `data` as a single object instead of an array of objects.\\n\\t*\\n\\t* Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\\n\\t* this returns an error.\\n\\t*/\\n\\tmaybeSingle() {\\n\\t\\tif (this.method === \\\"GET\\\") this.headers.set(\\\"Accept\\\", \\\"application/json\\\");\\n\\t\\telse this.headers.set(\\\"Accept\\\", \\\"application/vnd.pgrst.object+json\\\");\\n\\t\\tthis.isMaybeSingle = true;\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Return `data` as a string in CSV format.\\n\\t*/\\n\\tcsv() {\\n\\t\\tthis.headers.set(\\\"Accept\\\", \\\"text/csv\\\");\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Return `data` as an object in [GeoJSON](https://geojson.org) format.\\n\\t*/\\n\\tgeojson() {\\n\\t\\tthis.headers.set(\\\"Accept\\\", \\\"application/geo+json\\\");\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Return `data` as the EXPLAIN plan for the query.\\n\\t*\\n\\t* You need to enable the\\n\\t* [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\\n\\t* setting before using this method.\\n\\t*\\n\\t* @param options - Named parameters\\n\\t*\\n\\t* @param options.analyze - If `true`, the query will be executed and the\\n\\t* actual run time will be returned\\n\\t*\\n\\t* @param options.verbose - If `true`, the query identifier will be returned\\n\\t* and `data` will include the output columns of the query\\n\\t*\\n\\t* @param options.settings - If `true`, include information on configuration\\n\\t* parameters that affect query planning\\n\\t*\\n\\t* @param options.buffers - If `true`, include information on buffer usage\\n\\t*\\n\\t* @param options.wal - If `true`, include information on WAL record generation\\n\\t*\\n\\t* @param options.format - The format of the output, can be `\\\"text\\\"` (default)\\n\\t* or `\\\"json\\\"`\\n\\t*/\\n\\texplain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \\\"text\\\" } = {}) {\\n\\t\\tvar _this$headers$get;\\n\\t\\tconst options = [\\n\\t\\t\\tanalyze ? \\\"analyze\\\" : null,\\n\\t\\t\\tverbose ? \\\"verbose\\\" : null,\\n\\t\\t\\tsettings ? \\\"settings\\\" : null,\\n\\t\\t\\tbuffers ? \\\"buffers\\\" : null,\\n\\t\\t\\twal ? \\\"wal\\\" : null\\n\\t\\t].filter(Boolean).join(\\\"|\\\");\\n\\t\\tconst forMediatype = (_this$headers$get = this.headers.get(\\\"Accept\\\")) !== null && _this$headers$get !== void 0 ? _this$headers$get : \\\"application/json\\\";\\n\\t\\tthis.headers.set(\\\"Accept\\\", `application/vnd.pgrst.plan+${format}; for=\\\"${forMediatype}\\\"; options=${options};`);\\n\\t\\tif (format === \\\"json\\\") return this;\\n\\t\\telse return this;\\n\\t}\\n\\t/**\\n\\t* Rollback the query.\\n\\t*\\n\\t* `data` will still be returned, but the query is not committed.\\n\\t*/\\n\\trollback() {\\n\\t\\tthis.headers.append(\\\"Prefer\\\", \\\"tx=rollback\\\");\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Override the type of the returned `data`.\\n\\t*\\n\\t* @typeParam NewResult - The new result type to override with\\n\\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\\n\\t*/\\n\\treturns() {\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Set the maximum number of rows that can be affected by the query.\\n\\t* Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\\n\\t*\\n\\t* @param value - The maximum number of rows that can be affected\\n\\t*/\\n\\tmaxAffected(value) {\\n\\t\\tthis.headers.append(\\\"Prefer\\\", \\\"handling=strict\\\");\\n\\t\\tthis.headers.append(\\\"Prefer\\\", `max-affected=${value}`);\\n\\t\\treturn this;\\n\\t}\\n};\\n\\n//#endregion\\n//#region src/PostgrestFilterBuilder.ts\\nconst PostgrestReservedCharsRegexp = /* @__PURE__ */ new RegExp(\\\"[,()]\\\");\\nvar PostgrestFilterBuilder = class extends PostgrestTransformBuilder {\\n\\t/**\\n\\t* Match only rows where `column` is equal to `value`.\\n\\t*\\n\\t* To check if the value of `column` is NULL, you should use `.is()` instead.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param value - The value to filter with\\n\\t*/\\n\\teq(column, value) {\\n\\t\\tthis.url.searchParams.append(column, `eq.${value}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` is not equal to `value`.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param value - The value to filter with\\n\\t*/\\n\\tneq(column, value) {\\n\\t\\tthis.url.searchParams.append(column, `neq.${value}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` is greater than `value`.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param value - The value to filter with\\n\\t*/\\n\\tgt(column, value) {\\n\\t\\tthis.url.searchParams.append(column, `gt.${value}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` is greater than or equal to `value`.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param value - The value to filter with\\n\\t*/\\n\\tgte(column, value) {\\n\\t\\tthis.url.searchParams.append(column, `gte.${value}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` is less than `value`.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param value - The value to filter with\\n\\t*/\\n\\tlt(column, value) {\\n\\t\\tthis.url.searchParams.append(column, `lt.${value}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` is less than or equal to `value`.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param value - The value to filter with\\n\\t*/\\n\\tlte(column, value) {\\n\\t\\tthis.url.searchParams.append(column, `lte.${value}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` matches `pattern` case-sensitively.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param pattern - The pattern to match with\\n\\t*/\\n\\tlike(column, pattern) {\\n\\t\\tthis.url.searchParams.append(column, `like.${pattern}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` matches all of `patterns` case-sensitively.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param patterns - The patterns to match with\\n\\t*/\\n\\tlikeAllOf(column, patterns) {\\n\\t\\tthis.url.searchParams.append(column, `like(all).{${patterns.join(\\\",\\\")}}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` matches any of `patterns` case-sensitively.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param patterns - The patterns to match with\\n\\t*/\\n\\tlikeAnyOf(column, patterns) {\\n\\t\\tthis.url.searchParams.append(column, `like(any).{${patterns.join(\\\",\\\")}}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` matches `pattern` case-insensitively.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param pattern - The pattern to match with\\n\\t*/\\n\\tilike(column, pattern) {\\n\\t\\tthis.url.searchParams.append(column, `ilike.${pattern}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` matches all of `patterns` case-insensitively.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param patterns - The patterns to match with\\n\\t*/\\n\\tilikeAllOf(column, patterns) {\\n\\t\\tthis.url.searchParams.append(column, `ilike(all).{${patterns.join(\\\",\\\")}}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` matches any of `patterns` case-insensitively.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param patterns - The patterns to match with\\n\\t*/\\n\\tilikeAnyOf(column, patterns) {\\n\\t\\tthis.url.searchParams.append(column, `ilike(any).{${patterns.join(\\\",\\\")}}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\\n\\t* case-sensitively (using the `~` operator).\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param pattern - The PostgreSQL regular expression pattern to match with\\n\\t*/\\n\\tregexMatch(column, pattern) {\\n\\t\\tthis.url.searchParams.append(column, `match.${pattern}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\\n\\t* case-insensitively (using the `~*` operator).\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param pattern - The PostgreSQL regular expression pattern to match with\\n\\t*/\\n\\tregexIMatch(column, pattern) {\\n\\t\\tthis.url.searchParams.append(column, `imatch.${pattern}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` IS `value`.\\n\\t*\\n\\t* For non-boolean columns, this is only relevant for checking if the value of\\n\\t* `column` is NULL by setting `value` to `null`.\\n\\t*\\n\\t* For boolean columns, you can also set `value` to `true` or `false` and it\\n\\t* will behave the same way as `.eq()`.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param value - The value to filter with\\n\\t*/\\n\\tis(column, value) {\\n\\t\\tthis.url.searchParams.append(column, `is.${value}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` IS DISTINCT FROM `value`.\\n\\t*\\n\\t* Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values\\n\\t* are considered equal (not distinct), and comparing `NULL` with any non-NULL\\n\\t* value returns true (distinct).\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param value - The value to filter with\\n\\t*/\\n\\tisDistinct(column, value) {\\n\\t\\tthis.url.searchParams.append(column, `isdistinct.${value}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` is included in the `values` array.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param values - The values array to filter with\\n\\t*/\\n\\tin(column, values) {\\n\\t\\tconst cleanedValues = Array.from(new Set(values)).map((s) => {\\n\\t\\t\\tif (typeof s === \\\"string\\\" && PostgrestReservedCharsRegexp.test(s)) return `\\\"${s}\\\"`;\\n\\t\\t\\telse return `${s}`;\\n\\t\\t}).join(\\\",\\\");\\n\\t\\tthis.url.searchParams.append(column, `in.(${cleanedValues})`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where `column` is NOT included in the `values` array.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param values - The values array to filter with\\n\\t*/\\n\\tnotIn(column, values) {\\n\\t\\tconst cleanedValues = Array.from(new Set(values)).map((s) => {\\n\\t\\t\\tif (typeof s === \\\"string\\\" && PostgrestReservedCharsRegexp.test(s)) return `\\\"${s}\\\"`;\\n\\t\\t\\telse return `${s}`;\\n\\t\\t}).join(\\\",\\\");\\n\\t\\tthis.url.searchParams.append(column, `not.in.(${cleanedValues})`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Only relevant for jsonb, array, and range columns. Match only rows where\\n\\t* `column` contains every element appearing in `value`.\\n\\t*\\n\\t* @param column - The jsonb, array, or range column to filter on\\n\\t* @param value - The jsonb, array, or range value to filter with\\n\\t*/\\n\\tcontains(column, value) {\\n\\t\\tif (typeof value === \\\"string\\\") this.url.searchParams.append(column, `cs.${value}`);\\n\\t\\telse if (Array.isArray(value)) this.url.searchParams.append(column, `cs.{${value.join(\\\",\\\")}}`);\\n\\t\\telse this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Only relevant for jsonb, array, and range columns. Match only rows where\\n\\t* every element appearing in `column` is contained by `value`.\\n\\t*\\n\\t* @param column - The jsonb, array, or range column to filter on\\n\\t* @param value - The jsonb, array, or range value to filter with\\n\\t*/\\n\\tcontainedBy(column, value) {\\n\\t\\tif (typeof value === \\\"string\\\") this.url.searchParams.append(column, `cd.${value}`);\\n\\t\\telse if (Array.isArray(value)) this.url.searchParams.append(column, `cd.{${value.join(\\\",\\\")}}`);\\n\\t\\telse this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Only relevant for range columns. Match only rows where every element in\\n\\t* `column` is greater than any element in `range`.\\n\\t*\\n\\t* @param column - The range column to filter on\\n\\t* @param range - The range to filter with\\n\\t*/\\n\\trangeGt(column, range) {\\n\\t\\tthis.url.searchParams.append(column, `sr.${range}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Only relevant for range columns. Match only rows where every element in\\n\\t* `column` is either contained in `range` or greater than any element in\\n\\t* `range`.\\n\\t*\\n\\t* @param column - The range column to filter on\\n\\t* @param range - The range to filter with\\n\\t*/\\n\\trangeGte(column, range) {\\n\\t\\tthis.url.searchParams.append(column, `nxl.${range}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Only relevant for range columns. Match only rows where every element in\\n\\t* `column` is less than any element in `range`.\\n\\t*\\n\\t* @param column - The range column to filter on\\n\\t* @param range - The range to filter with\\n\\t*/\\n\\trangeLt(column, range) {\\n\\t\\tthis.url.searchParams.append(column, `sl.${range}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Only relevant for range columns. Match only rows where every element in\\n\\t* `column` is either contained in `range` or less than any element in\\n\\t* `range`.\\n\\t*\\n\\t* @param column - The range column to filter on\\n\\t* @param range - The range to filter with\\n\\t*/\\n\\trangeLte(column, range) {\\n\\t\\tthis.url.searchParams.append(column, `nxr.${range}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Only relevant for range columns. Match only rows where `column` is\\n\\t* mutually exclusive to `range` and there can be no element between the two\\n\\t* ranges.\\n\\t*\\n\\t* @param column - The range column to filter on\\n\\t* @param range - The range to filter with\\n\\t*/\\n\\trangeAdjacent(column, range) {\\n\\t\\tthis.url.searchParams.append(column, `adj.${range}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Only relevant for array and range columns. Match only rows where\\n\\t* `column` and `value` have an element in common.\\n\\t*\\n\\t* @param column - The array or range column to filter on\\n\\t* @param value - The array or range value to filter with\\n\\t*/\\n\\toverlaps(column, value) {\\n\\t\\tif (typeof value === \\\"string\\\") this.url.searchParams.append(column, `ov.${value}`);\\n\\t\\telse this.url.searchParams.append(column, `ov.{${value.join(\\\",\\\")}}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Only relevant for text and tsvector columns. Match only rows where\\n\\t* `column` matches the query string in `query`.\\n\\t*\\n\\t* @param column - The text or tsvector column to filter on\\n\\t* @param query - The query text to match with\\n\\t* @param options - Named parameters\\n\\t* @param options.config - The text search configuration to use\\n\\t* @param options.type - Change how the `query` text is interpreted\\n\\t*/\\n\\ttextSearch(column, query, { config, type } = {}) {\\n\\t\\tlet typePart = \\\"\\\";\\n\\t\\tif (type === \\\"plain\\\") typePart = \\\"pl\\\";\\n\\t\\telse if (type === \\\"phrase\\\") typePart = \\\"ph\\\";\\n\\t\\telse if (type === \\\"websearch\\\") typePart = \\\"w\\\";\\n\\t\\tconst configPart = config === void 0 ? \\\"\\\" : `(${config})`;\\n\\t\\tthis.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows where each column in `query` keys is equal to its\\n\\t* associated value. Shorthand for multiple `.eq()`s.\\n\\t*\\n\\t* @param query - The object to filter with, with column names as keys mapped\\n\\t* to their filter values\\n\\t*/\\n\\tmatch(query) {\\n\\t\\tObject.entries(query).forEach(([column, value]) => {\\n\\t\\t\\tthis.url.searchParams.append(column, `eq.${value}`);\\n\\t\\t});\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows which doesn't satisfy the filter.\\n\\t*\\n\\t* Unlike most filters, `opearator` and `value` are used as-is and need to\\n\\t* follow [PostgREST\\n\\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\\n\\t* to make sure they are properly sanitized.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param operator - The operator to be negated to filter with, following\\n\\t* PostgREST syntax\\n\\t* @param value - The value to filter with, following PostgREST syntax\\n\\t*/\\n\\tnot(column, operator, value) {\\n\\t\\tthis.url.searchParams.append(column, `not.${operator}.${value}`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows which satisfy at least one of the filters.\\n\\t*\\n\\t* Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\\n\\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\\n\\t* to make sure it's properly sanitized.\\n\\t*\\n\\t* It's currently not possible to do an `.or()` filter across multiple tables.\\n\\t*\\n\\t* @param filters - The filters to use, following PostgREST syntax\\n\\t* @param options - Named parameters\\n\\t* @param options.referencedTable - Set this to filter on referenced tables\\n\\t* instead of the parent table\\n\\t* @param options.foreignTable - Deprecated, use `referencedTable` instead\\n\\t*/\\n\\tor(filters, { foreignTable, referencedTable = foreignTable } = {}) {\\n\\t\\tconst key = referencedTable ? `${referencedTable}.or` : \\\"or\\\";\\n\\t\\tthis.url.searchParams.append(key, `(${filters})`);\\n\\t\\treturn this;\\n\\t}\\n\\t/**\\n\\t* Match only rows which satisfy the filter. This is an escape hatch - you\\n\\t* should use the specific filter methods wherever possible.\\n\\t*\\n\\t* Unlike most filters, `opearator` and `value` are used as-is and need to\\n\\t* follow [PostgREST\\n\\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\\n\\t* to make sure they are properly sanitized.\\n\\t*\\n\\t* @param column - The column to filter on\\n\\t* @param operator - The operator to filter with, following PostgREST syntax\\n\\t* @param value - The value to filter with, following PostgREST syntax\\n\\t*/\\n\\tfilter(column, operator, value) {\\n\\t\\tthis.url.searchParams.append(column, `${operator}.${value}`);\\n\\t\\treturn this;\\n\\t}\\n};\\n\\n//#endregion\\n//#region src/PostgrestQueryBuilder.ts\\nvar PostgrestQueryBuilder = class {\\n\\t/**\\n\\t* Creates a query builder scoped to a Postgres table or view.\\n\\t*\\n\\t* @example\\n\\t* ```ts\\n\\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\\n\\t*\\n\\t* const query = new PostgrestQueryBuilder(\\n\\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\\n\\t*   { headers: { apikey: 'public-anon-key' } }\\n\\t* )\\n\\t* ```\\n\\t*/\\n\\tconstructor(url, { headers = {}, schema, fetch: fetch$1, urlLengthLimit = 8e3 }) {\\n\\t\\tthis.url = url;\\n\\t\\tthis.headers = new Headers(headers);\\n\\t\\tthis.schema = schema;\\n\\t\\tthis.fetch = fetch$1;\\n\\t\\tthis.urlLengthLimit = urlLengthLimit;\\n\\t}\\n\\t/**\\n\\t* Clone URL and headers to prevent shared state between operations.\\n\\t*/\\n\\tcloneRequestState() {\\n\\t\\treturn {\\n\\t\\t\\turl: new URL(this.url.toString()),\\n\\t\\t\\theaders: new Headers(this.headers)\\n\\t\\t};\\n\\t}\\n\\t/**\\n\\t* Perform a SELECT query on the table or view.\\n\\t*\\n\\t* @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\\n\\t*\\n\\t* @param options - Named parameters\\n\\t*\\n\\t* @param options.head - When set to `true`, `data` will not be returned.\\n\\t* Useful if you only need the count.\\n\\t*\\n\\t* @param options.count - Count algorithm to use to count rows in the table or view.\\n\\t*\\n\\t* `\\\"exact\\\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\\n\\t* hood.\\n\\t*\\n\\t* `\\\"planned\\\"`: Approximated but fast count algorithm. Uses the Postgres\\n\\t* statistics under the hood.\\n\\t*\\n\\t* `\\\"estimated\\\"`: Uses exact count for low numbers and planned count for high\\n\\t* numbers.\\n\\t*\\n\\t* @remarks\\n\\t* When using `count` with `.range()` or `.limit()`, the returned `count` is the total number of rows\\n\\t* that match your filters, not the number of rows in the current page. Use this to build pagination UI.\\n\\t*/\\n\\tselect(columns, options) {\\n\\t\\tconst { head = false, count } = options !== null && options !== void 0 ? options : {};\\n\\t\\tconst method = head ? \\\"HEAD\\\" : \\\"GET\\\";\\n\\t\\tlet quoted = false;\\n\\t\\tconst cleanedColumns = (columns !== null && columns !== void 0 ? columns : \\\"*\\\").split(\\\"\\\").map((c) => {\\n\\t\\t\\tif (/\\\\s/.test(c) && !quoted) return \\\"\\\";\\n\\t\\t\\tif (c === \\\"\\\\\\\"\\\") quoted = !quoted;\\n\\t\\t\\treturn c;\\n\\t\\t}).join(\\\"\\\");\\n\\t\\tconst { url, headers } = this.cloneRequestState();\\n\\t\\turl.searchParams.set(\\\"select\\\", cleanedColumns);\\n\\t\\tif (count) headers.append(\\\"Prefer\\\", `count=${count}`);\\n\\t\\treturn new PostgrestFilterBuilder({\\n\\t\\t\\tmethod,\\n\\t\\t\\turl,\\n\\t\\t\\theaders,\\n\\t\\t\\tschema: this.schema,\\n\\t\\t\\tfetch: this.fetch,\\n\\t\\t\\turlLengthLimit: this.urlLengthLimit\\n\\t\\t});\\n\\t}\\n\\t/**\\n\\t* Perform an INSERT into the table or view.\\n\\t*\\n\\t* By default, inserted rows are not returned. To return it, chain the call\\n\\t* with `.select()`.\\n\\t*\\n\\t* @param values - The values to insert. Pass an object to insert a single row\\n\\t* or an array to insert multiple rows.\\n\\t*\\n\\t* @param options - Named parameters\\n\\t*\\n\\t* @param options.count - Count algorithm to use to count inserted rows.\\n\\t*\\n\\t* `\\\"exact\\\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\\n\\t* hood.\\n\\t*\\n\\t* `\\\"planned\\\"`: Approximated but fast count algorithm. Uses the Postgres\\n\\t* statistics under the hood.\\n\\t*\\n\\t* `\\\"estimated\\\"`: Uses exact count for low numbers and planned count for high\\n\\t* numbers.\\n\\t*\\n\\t* @param options.defaultToNull - Make missing fields default to `null`.\\n\\t* Otherwise, use the default value for the column. Only applies for bulk\\n\\t* inserts.\\n\\t*/\\n\\tinsert(values, { count, defaultToNull = true } = {}) {\\n\\t\\tvar _this$fetch;\\n\\t\\tconst method = \\\"POST\\\";\\n\\t\\tconst { url, headers } = this.cloneRequestState();\\n\\t\\tif (count) headers.append(\\\"Prefer\\\", `count=${count}`);\\n\\t\\tif (!defaultToNull) headers.append(\\\"Prefer\\\", `missing=default`);\\n\\t\\tif (Array.isArray(values)) {\\n\\t\\t\\tconst columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\\n\\t\\t\\tif (columns.length > 0) {\\n\\t\\t\\t\\tconst uniqueColumns = [...new Set(columns)].map((column) => `\\\"${column}\\\"`);\\n\\t\\t\\t\\turl.searchParams.set(\\\"columns\\\", uniqueColumns.join(\\\",\\\"));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn new PostgrestFilterBuilder({\\n\\t\\t\\tmethod,\\n\\t\\t\\turl,\\n\\t\\t\\theaders,\\n\\t\\t\\tschema: this.schema,\\n\\t\\t\\tbody: values,\\n\\t\\t\\tfetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch,\\n\\t\\t\\turlLengthLimit: this.urlLengthLimit\\n\\t\\t});\\n\\t}\\n\\t/**\\n\\t* Perform an UPSERT on the table or view. Depending on the column(s) passed\\n\\t* to `onConflict`, `.upsert()` allows you to perform the equivalent of\\n\\t* `.insert()` if a row with the corresponding `onConflict` columns doesn't\\n\\t* exist, or if it does exist, perform an alternative action depending on\\n\\t* `ignoreDuplicates`.\\n\\t*\\n\\t* By default, upserted rows are not returned. To return it, chain the call\\n\\t* with `.select()`.\\n\\t*\\n\\t* @param values - The values to upsert with. Pass an object to upsert a\\n\\t* single row or an array to upsert multiple rows.\\n\\t*\\n\\t* @param options - Named parameters\\n\\t*\\n\\t* @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\\n\\t* duplicate rows are determined. Two rows are duplicates if all the\\n\\t* `onConflict` columns are equal.\\n\\t*\\n\\t* @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\\n\\t* `false`, duplicate rows are merged with existing rows.\\n\\t*\\n\\t* @param options.count - Count algorithm to use to count upserted rows.\\n\\t*\\n\\t* `\\\"exact\\\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\\n\\t* hood.\\n\\t*\\n\\t* `\\\"planned\\\"`: Approximated but fast count algorithm. Uses the Postgres\\n\\t* statistics under the hood.\\n\\t*\\n\\t* `\\\"estimated\\\"`: Uses exact count for low numbers and planned count for high\\n\\t* numbers.\\n\\t*\\n\\t* @param options.defaultToNull - Make missing fields default to `null`.\\n\\t* Otherwise, use the default value for the column. This only applies when\\n\\t* inserting new rows, not when merging with existing rows under\\n\\t* `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\\n\\t*\\n\\t* @example Upsert a single row using a unique key\\n\\t* ```ts\\n\\t* // Upserting a single row, overwriting based on the 'username' unique column\\n\\t* const { data, error } = await supabase\\n\\t*   .from('users')\\n\\t*   .upsert({ username: 'supabot' }, { onConflict: 'username' })\\n\\t*\\n\\t* // Example response:\\n\\t* // {\\n\\t* //   data: [\\n\\t* //     { id: 4, message: 'bar', username: 'supabot' }\\n\\t* //   ],\\n\\t* //   error: null\\n\\t* // }\\n\\t* ```\\n\\t*\\n\\t* @example Upsert with conflict resolution and exact row counting\\n\\t* ```ts\\n\\t* // Upserting and returning exact count\\n\\t* const { data, error, count } = await supabase\\n\\t*   .from('users')\\n\\t*   .upsert(\\n\\t*     {\\n\\t*       id: 3,\\n\\t*       message: 'foo',\\n\\t*       username: 'supabot'\\n\\t*     },\\n\\t*     {\\n\\t*       onConflict: 'username',\\n\\t*       count: 'exact'\\n\\t*     }\\n\\t*   )\\n\\t*\\n\\t* // Example response:\\n\\t* // {\\n\\t* //   data: [\\n\\t* //     {\\n\\t* //       id: 42,\\n\\t* //       handle: \\\"saoirse\\\",\\n\\t* //       display_name: \\\"Saoirse\\\"\\n\\t* //     }\\n\\t* //   ],\\n\\t* //   count: 1,\\n\\t* //   error: null\\n\\t* // }\\n\\t* ```\\n\\t*/\\n\\tupsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {\\n\\t\\tvar _this$fetch2;\\n\\t\\tconst method = \\\"POST\\\";\\n\\t\\tconst { url, headers } = this.cloneRequestState();\\n\\t\\theaders.append(\\\"Prefer\\\", `resolution=${ignoreDuplicates ? \\\"ignore\\\" : \\\"merge\\\"}-duplicates`);\\n\\t\\tif (onConflict !== void 0) url.searchParams.set(\\\"on_conflict\\\", onConflict);\\n\\t\\tif (count) headers.append(\\\"Prefer\\\", `count=${count}`);\\n\\t\\tif (!defaultToNull) headers.append(\\\"Prefer\\\", \\\"missing=default\\\");\\n\\t\\tif (Array.isArray(values)) {\\n\\t\\t\\tconst columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\\n\\t\\t\\tif (columns.length > 0) {\\n\\t\\t\\t\\tconst uniqueColumns = [...new Set(columns)].map((column) => `\\\"${column}\\\"`);\\n\\t\\t\\t\\turl.searchParams.set(\\\"columns\\\", uniqueColumns.join(\\\",\\\"));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn new PostgrestFilterBuilder({\\n\\t\\t\\tmethod,\\n\\t\\t\\turl,\\n\\t\\t\\theaders,\\n\\t\\t\\tschema: this.schema,\\n\\t\\t\\tbody: values,\\n\\t\\t\\tfetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch,\\n\\t\\t\\turlLengthLimit: this.urlLengthLimit\\n\\t\\t});\\n\\t}\\n\\t/**\\n\\t* Perform an UPDATE on the table or view.\\n\\t*\\n\\t* By default, updated rows are not returned. To return it, chain the call\\n\\t* with `.select()` after filters.\\n\\t*\\n\\t* @param values - The values to update with\\n\\t*\\n\\t* @param options - Named parameters\\n\\t*\\n\\t* @param options.count - Count algorithm to use to count updated rows.\\n\\t*\\n\\t* `\\\"exact\\\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\\n\\t* hood.\\n\\t*\\n\\t* `\\\"planned\\\"`: Approximated but fast count algorithm. Uses the Postgres\\n\\t* statistics under the hood.\\n\\t*\\n\\t* `\\\"estimated\\\"`: Uses exact count for low numbers and planned count for high\\n\\t* numbers.\\n\\t*/\\n\\tupdate(values, { count } = {}) {\\n\\t\\tvar _this$fetch3;\\n\\t\\tconst method = \\\"PATCH\\\";\\n\\t\\tconst { url, headers } = this.cloneRequestState();\\n\\t\\tif (count) headers.append(\\\"Prefer\\\", `count=${count}`);\\n\\t\\treturn new PostgrestFilterBuilder({\\n\\t\\t\\tmethod,\\n\\t\\t\\turl,\\n\\t\\t\\theaders,\\n\\t\\t\\tschema: this.schema,\\n\\t\\t\\tbody: values,\\n\\t\\t\\tfetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch,\\n\\t\\t\\turlLengthLimit: this.urlLengthLimit\\n\\t\\t});\\n\\t}\\n\\t/**\\n\\t* Perform a DELETE on the table or view.\\n\\t*\\n\\t* By default, deleted rows are not returned. To return it, chain the call\\n\\t* with `.select()` after filters.\\n\\t*\\n\\t* @param options - Named parameters\\n\\t*\\n\\t* @param options.count - Count algorithm to use to count deleted rows.\\n\\t*\\n\\t* `\\\"exact\\\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\\n\\t* hood.\\n\\t*\\n\\t* `\\\"planned\\\"`: Approximated but fast count algorithm. Uses the Postgres\\n\\t* statistics under the hood.\\n\\t*\\n\\t* `\\\"estimated\\\"`: Uses exact count for low numbers and planned count for high\\n\\t* numbers.\\n\\t*/\\n\\tdelete({ count } = {}) {\\n\\t\\tvar _this$fetch4;\\n\\t\\tconst method = \\\"DELETE\\\";\\n\\t\\tconst { url, headers } = this.cloneRequestState();\\n\\t\\tif (count) headers.append(\\\"Prefer\\\", `count=${count}`);\\n\\t\\treturn new PostgrestFilterBuilder({\\n\\t\\t\\tmethod,\\n\\t\\t\\turl,\\n\\t\\t\\theaders,\\n\\t\\t\\tschema: this.schema,\\n\\t\\t\\tfetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch,\\n\\t\\t\\turlLengthLimit: this.urlLengthLimit\\n\\t\\t});\\n\\t}\\n};\\n\\n//#endregion\\n//#region \\\\0@oxc-project+runtime@0.101.0/helpers/typeof.js\\nfunction _typeof(o) {\\n\\t\\\"@babel/helpers - typeof\\\";\\n\\treturn _typeof = \\\"function\\\" == typeof Symbol && \\\"symbol\\\" == typeof Symbol.iterator ? function(o$1) {\\n\\t\\treturn typeof o$1;\\n\\t} : function(o$1) {\\n\\t\\treturn o$1 && \\\"function\\\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \\\"symbol\\\" : typeof o$1;\\n\\t}, _typeof(o);\\n}\\n\\n//#endregion\\n//#region \\\\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\\nfunction toPrimitive(t, r) {\\n\\tif (\\\"object\\\" != _typeof(t) || !t) return t;\\n\\tvar e = t[Symbol.toPrimitive];\\n\\tif (void 0 !== e) {\\n\\t\\tvar i = e.call(t, r || \\\"default\\\");\\n\\t\\tif (\\\"object\\\" != _typeof(i)) return i;\\n\\t\\tthrow new TypeError(\\\"@@toPrimitive must return a primitive value.\\\");\\n\\t}\\n\\treturn (\\\"string\\\" === r ? String : Number)(t);\\n}\\n\\n//#endregion\\n//#region \\\\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\\nfunction toPropertyKey(t) {\\n\\tvar i = toPrimitive(t, \\\"string\\\");\\n\\treturn \\\"symbol\\\" == _typeof(i) ? i : i + \\\"\\\";\\n}\\n\\n//#endregion\\n//#region \\\\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\\nfunction _defineProperty(e, r, t) {\\n\\treturn (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\\n\\t\\tvalue: t,\\n\\t\\tenumerable: !0,\\n\\t\\tconfigurable: !0,\\n\\t\\twritable: !0\\n\\t}) : e[r] = t, e;\\n}\\n\\n//#endregion\\n//#region \\\\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\\nfunction ownKeys(e, r) {\\n\\tvar t = Object.keys(e);\\n\\tif (Object.getOwnPropertySymbols) {\\n\\t\\tvar o = Object.getOwnPropertySymbols(e);\\n\\t\\tr && (o = o.filter(function(r$1) {\\n\\t\\t\\treturn Object.getOwnPropertyDescriptor(e, r$1).enumerable;\\n\\t\\t})), t.push.apply(t, o);\\n\\t}\\n\\treturn t;\\n}\\nfunction _objectSpread2(e) {\\n\\tfor (var r = 1; r < arguments.length; r++) {\\n\\t\\tvar t = null != arguments[r] ? arguments[r] : {};\\n\\t\\tr % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\\n\\t\\t\\t_defineProperty(e, r$1, t[r$1]);\\n\\t\\t}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\\n\\t\\t\\tObject.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\\n\\t\\t});\\n\\t}\\n\\treturn e;\\n}\\n\\n//#endregion\\n//#region src/PostgrestClient.ts\\n/**\\n* PostgREST client.\\n*\\n* @typeParam Database - Types for the schema from the [type\\n* generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\\n*\\n* @typeParam SchemaName - Postgres schema to switch to. Must be a string\\n* literal, the same one passed to the constructor. If the schema is not\\n* `\\\"public\\\"`, this must be supplied manually.\\n*/\\nvar PostgrestClient = class PostgrestClient {\\n\\t/**\\n\\t* Creates a PostgREST client.\\n\\t*\\n\\t* @param url - URL of the PostgREST endpoint\\n\\t* @param options - Named parameters\\n\\t* @param options.headers - Custom headers\\n\\t* @param options.schema - Postgres schema to switch to\\n\\t* @param options.fetch - Custom fetch\\n\\t* @param options.timeout - Optional timeout in milliseconds for all requests. When set, requests will automatically abort after this duration to prevent indefinite hangs.\\n\\t* @param options.urlLengthLimit - Maximum URL length in characters before warnings/errors are triggered. Defaults to 8000.\\n\\t* @example\\n\\t* ```ts\\n\\t* import PostgrestClient from '@supabase/postgrest-js'\\n\\t*\\n\\t* const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {\\n\\t*   headers: { apikey: 'public-anon-key' },\\n\\t*   schema: 'public',\\n\\t*   timeout: 30000, // 30 second timeout\\n\\t* })\\n\\t* ```\\n\\t*/\\n\\tconstructor(url, { headers = {}, schema, fetch: fetch$1, timeout, urlLengthLimit = 8e3 } = {}) {\\n\\t\\tthis.url = url;\\n\\t\\tthis.headers = new Headers(headers);\\n\\t\\tthis.schemaName = schema;\\n\\t\\tthis.urlLengthLimit = urlLengthLimit;\\n\\t\\tconst originalFetch = fetch$1 !== null && fetch$1 !== void 0 ? fetch$1 : globalThis.fetch;\\n\\t\\tif (timeout !== void 0 && timeout > 0) this.fetch = (input, init) => {\\n\\t\\t\\tconst controller = new AbortController();\\n\\t\\t\\tconst timeoutId = setTimeout(() => controller.abort(), timeout);\\n\\t\\t\\tconst existingSignal = init === null || init === void 0 ? void 0 : init.signal;\\n\\t\\t\\tif (existingSignal) {\\n\\t\\t\\t\\tif (existingSignal.aborted) {\\n\\t\\t\\t\\t\\tclearTimeout(timeoutId);\\n\\t\\t\\t\\t\\treturn originalFetch(input, init);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tconst abortHandler = () => {\\n\\t\\t\\t\\t\\tclearTimeout(timeoutId);\\n\\t\\t\\t\\t\\tcontroller.abort();\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\texistingSignal.addEventListener(\\\"abort\\\", abortHandler, { once: true });\\n\\t\\t\\t\\treturn originalFetch(input, _objectSpread2(_objectSpread2({}, init), {}, { signal: controller.signal })).finally(() => {\\n\\t\\t\\t\\t\\tclearTimeout(timeoutId);\\n\\t\\t\\t\\t\\texistingSignal.removeEventListener(\\\"abort\\\", abortHandler);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\treturn originalFetch(input, _objectSpread2(_objectSpread2({}, init), {}, { signal: controller.signal })).finally(() => clearTimeout(timeoutId));\\n\\t\\t};\\n\\t\\telse this.fetch = originalFetch;\\n\\t}\\n\\t/**\\n\\t* Perform a query on a table or a view.\\n\\t*\\n\\t* @param relation - The table or view name to query\\n\\t*/\\n\\tfrom(relation) {\\n\\t\\tif (!relation || typeof relation !== \\\"string\\\" || relation.trim() === \\\"\\\") throw new Error(\\\"Invalid relation name: relation must be a non-empty string.\\\");\\n\\t\\treturn new PostgrestQueryBuilder(new URL(`${this.url}/${relation}`), {\\n\\t\\t\\theaders: new Headers(this.headers),\\n\\t\\t\\tschema: this.schemaName,\\n\\t\\t\\tfetch: this.fetch,\\n\\t\\t\\turlLengthLimit: this.urlLengthLimit\\n\\t\\t});\\n\\t}\\n\\t/**\\n\\t* Select a schema to query or perform an function (rpc) call.\\n\\t*\\n\\t* The schema needs to be on the list of exposed schemas inside Supabase.\\n\\t*\\n\\t* @param schema - The schema to query\\n\\t*/\\n\\tschema(schema) {\\n\\t\\treturn new PostgrestClient(this.url, {\\n\\t\\t\\theaders: this.headers,\\n\\t\\t\\tschema,\\n\\t\\t\\tfetch: this.fetch,\\n\\t\\t\\turlLengthLimit: this.urlLengthLimit\\n\\t\\t});\\n\\t}\\n\\t/**\\n\\t* Perform a function call.\\n\\t*\\n\\t* @param fn - The function name to call\\n\\t* @param args - The arguments to pass to the function call\\n\\t* @param options - Named parameters\\n\\t* @param options.head - When set to `true`, `data` will not be returned.\\n\\t* Useful if you only need the count.\\n\\t* @param options.get - When set to `true`, the function will be called with\\n\\t* read-only access mode.\\n\\t* @param options.count - Count algorithm to use to count rows returned by the\\n\\t* function. Only applicable for [set-returning\\n\\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\\n\\t*\\n\\t* `\\\"exact\\\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\\n\\t* hood.\\n\\t*\\n\\t* `\\\"planned\\\"`: Approximated but fast count algorithm. Uses the Postgres\\n\\t* statistics under the hood.\\n\\t*\\n\\t* `\\\"estimated\\\"`: Uses exact count for low numbers and planned count for high\\n\\t* numbers.\\n\\t*\\n\\t* @example\\n\\t* ```ts\\n\\t* // For cross-schema functions where type inference fails, use overrideTypes:\\n\\t* const { data } = await supabase\\n\\t*   .schema('schema_b')\\n\\t*   .rpc('function_a', {})\\n\\t*   .overrideTypes<{ id: string; user_id: string }[]>()\\n\\t* ```\\n\\t*/\\n\\trpc(fn, args = {}, { head = false, get = false, count } = {}) {\\n\\t\\tvar _this$fetch;\\n\\t\\tlet method;\\n\\t\\tconst url = new URL(`${this.url}/rpc/${fn}`);\\n\\t\\tlet body;\\n\\t\\tconst _isObject = (v) => v !== null && typeof v === \\\"object\\\" && (!Array.isArray(v) || v.some(_isObject));\\n\\t\\tconst _hasObjectArg = head && Object.values(args).some(_isObject);\\n\\t\\tif (_hasObjectArg) {\\n\\t\\t\\tmethod = \\\"POST\\\";\\n\\t\\t\\tbody = args;\\n\\t\\t} else if (head || get) {\\n\\t\\t\\tmethod = head ? \\\"HEAD\\\" : \\\"GET\\\";\\n\\t\\t\\tObject.entries(args).filter(([_, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(\\\",\\\")}}` : `${value}`]).forEach(([name, value]) => {\\n\\t\\t\\t\\turl.searchParams.append(name, value);\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tmethod = \\\"POST\\\";\\n\\t\\t\\tbody = args;\\n\\t\\t}\\n\\t\\tconst headers = new Headers(this.headers);\\n\\t\\tif (_hasObjectArg) headers.set(\\\"Prefer\\\", count ? `count=${count},return=minimal` : \\\"return=minimal\\\");\\n\\t\\telse if (count) headers.set(\\\"Prefer\\\", `count=${count}`);\\n\\t\\treturn new PostgrestFilterBuilder({\\n\\t\\t\\tmethod,\\n\\t\\t\\turl,\\n\\t\\t\\theaders,\\n\\t\\t\\tschema: this.schemaName,\\n\\t\\t\\tbody,\\n\\t\\t\\tfetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch,\\n\\t\\t\\turlLengthLimit: this.urlLengthLimit\\n\\t\\t});\\n\\t}\\n};\\n\\n//#endregion\\n//#region src/index.ts\\nvar src_default = {\\n\\tPostgrestClient,\\n\\tPostgrestQueryBuilder,\\n\\tPostgrestFilterBuilder,\\n\\tPostgrestTransformBuilder,\\n\\tPostgrestBuilder,\\n\\tPostgrestError\\n};\\n\\n//#endregion\\nexports.PostgrestBuilder = PostgrestBuilder;\\nexports.PostgrestClient = PostgrestClient;\\nexports.PostgrestError = PostgrestError;\\nexports.PostgrestFilterBuilder = PostgrestFilterBuilder;\\nexports.PostgrestQueryBuilder = PostgrestQueryBuilder;\\nexports.PostgrestTransformBuilder = PostgrestTransformBuilder;\\nexports.default = src_default;\\n//# sourceMappingURL=index.cjs.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"_typeof\",\"o\",\"Symbol\",\"iterator\",\"o$1\",\"constructor\",\"prototype\",\"ownKeys\",\"e\",\"r\",\"t\",\"Object\",\"keys\",\"getOwnPropertySymbols\",\"filter\",\"r$1\",\"getOwnPropertyDescriptor\",\"enumerable\",\"push\",\"apply\",\"_objectSpread2\",\"arguments\",\"length\",\"forEach\",\"toPrimitive\",\"i\",\"call\",\"TypeError\",\"String\",\"defineProperty\",\"value\",\"configurable\",\"writable\",\"getOwnPropertyDescriptors\",\"defineProperties\",\"PostgrestError\",\"Error\",\"context\",\"message\",\"name\",\"details\",\"hint\",\"code\",\"PostgrestBuilder\",\"builder\",\"_builder$shouldThrowO\",\"_builder$isMaybeSingl\",\"_builder$urlLengthLim\",\"shouldThrowOnError\",\"method\",\"url\",\"headers\",\"Headers\",\"schema\",\"body\",\"signal\",\"isMaybeSingle\",\"urlLengthLimit\",\"fetch\",\"throwOnError\",\"setHeader\",\"set\",\"then\",\"onfulfilled\",\"onrejected\",\"_this\",\"includes\",\"_fetch\",\"res\",\"toString\",\"JSON\",\"stringify\",\"res$1\",\"error\",\"data\",\"count\",\"status\",\"statusText\",\"ok\",\"_this$headers$get2\",\"_res$headers$get\",\"_this$headers$get\",\"text\",\"get\",\"parse\",\"countHeader\",\"match\",\"contentRange\",\"split\",\"parseInt\",\"Array\",\"isArray\",\"_unused\",\"_error$details\",\"catch\",\"fetchError\",\"_fetchError$name2\",\"errorDetails\",\"cause\",\"_cause$message\",\"_fetchError$name\",\"_cause$name\",\"causeMessage\",\"causeCode\",\"_cause$code\",\"stack\",\"_fetchError$stack\",\"urlLength\",\"returns\",\"overrideTypes\",\"PostgrestTransformBuilder\",\"select\",\"columns\",\"quoted\",\"cleanedColumns\",\"map\",\"c\",\"test\",\"join\",\"searchParams\",\"append\",\"order\",\"column\",\"ascending\",\"nullsFirst\",\"foreignTable\",\"referencedTable\",\"key\",\"existingOrder\",\"limit\",\"range\",\"from\",\"to\",\"keyLimit\",\"keyOffset\",\"abortSignal\",\"single\",\"maybeSingle\",\"csv\",\"geojson\",\"explain\",\"analyze\",\"verbose\",\"settings\",\"buffers\",\"wal\",\"format\",\"options\",\"Boolean\",\"forMediatype\",\"rollback\",\"maxAffected\",\"PostgrestReservedCharsRegexp\",\"RegExp\",\"PostgrestFilterBuilder\",\"eq\",\"neq\",\"gt\",\"gte\",\"lt\",\"lte\",\"like\",\"pattern\",\"likeAllOf\",\"patterns\",\"likeAnyOf\",\"ilike\",\"ilikeAllOf\",\"ilikeAnyOf\",\"regexMatch\",\"regexIMatch\",\"is\",\"isDistinct\",\"in\",\"values\",\"cleanedValues\",\"Set\",\"s\",\"notIn\",\"contains\",\"containedBy\",\"rangeGt\",\"rangeGte\",\"rangeLt\",\"rangeLte\",\"rangeAdjacent\",\"overlaps\",\"textSearch\",\"query\",\"config\",\"type\",\"typePart\",\"configPart\",\"entries\",\"not\",\"operator\",\"or\",\"filters\",\"PostgrestQueryBuilder\",\"fetch$1\",\"cloneRequestState\",\"URL\",\"head\",\"insert\",\"defaultToNull\",\"_this$fetch\",\"reduce\",\"acc\",\"x\",\"concat\",\"uniqueColumns\",\"upsert\",\"onConflict\",\"ignoreDuplicates\",\"_this$fetch2\",\"update\",\"_this$fetch3\",\"delete\",\"_this$fetch4\",\"PostgrestClient\",\"timeout\",\"schemaName\",\"originalFetch\",\"globalThis\",\"input\",\"init\",\"this.fetch\",\"controller\",\"AbortController\",\"timeoutId\",\"setTimeout\",\"abort\",\"existingSignal\",\"aborted\",\"clearTimeout\",\"abortHandler\",\"addEventListener\",\"once\",\"finally\",\"removeEventListener\",\"relation\",\"trim\",\"rpc\",\"fn\",\"args\",\"_isObject\",\"v\",\"some\",\"_hasObjectArg\",\"src_default\",\"default\"]\n}\n"]