["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/iceberg-js/dist/index.cjs"],"~:js","shadow$provide[31]=function(I,R,a){async function G(f){return f&&f.type!==\"none\"?f.type===\"bearer\"?{Authorization:`Bearer ${f.token}`}:f.type===\"header\"?{[f.name]:f.value}:f.type===\"custom\"?await f.getHeaders():{}:{}}function l(f){const t=f.fetchImpl??globalThis.fetch;return{async request({method:n,path:v,query:A,body:h,headers:m}){v=new URL(v,f.baseUrl);if(A)for(const [r,p]of Object.entries(A))p!==void 0&&v.searchParams.set(r,p);A=v.toString();v=await G(f.auth);n=await t(A,{method:n,headers:{...(h?\n{\"Content-Type\":\"application/json\"}:{}),...v,...m},body:h?JSON.stringify(h):void 0});m=await n.text();m=(h=(n.headers.get(\"content-type\")||\"\").includes(\"application/json\"))&&m?JSON.parse(m):m;if(!n.ok)throw h=h?m:void 0,m=h?.error,new y(m?.message??`Request failed with status ${n.status}`,{status:n.status,icebergType:m?.type,icebergCode:m?.code,details:h});return{status:n.status,headers:n.headers,data:m}}}}function x(f){return f.join(\"\u001F\")}function w(f){return(f=f.match(D))?{precision:parseInt(f[1],\n10),scale:parseInt(f[2],10)}:null}function z(f){return(f=f.match(k))?{length:parseInt(f[1],10)}:null}var y=class extends Error{constructor(f,t){super(f);this.name=\"IcebergError\";this.status=t.status;this.icebergType=t.icebergType;this.icebergCode=t.icebergCode;this.details=t.details;this.isCommitStateUnknown=t.icebergType===\"CommitStateUnknownException\"||[500,502,504].includes(t.status)&&t.icebergType?.includes(\"CommitState\")===!0}isNotFound(){return this.status===404}isConflict(){return this.status===\n409}isAuthenticationTimeout(){return this.status===419}},F=class{constructor(f,t=\"\"){this.client=f;this.prefix=t}async listNamespaces(f){f=f?{parent:f.namespace.join(\"\u001F\")}:void 0;return(await this.client.request({method:\"GET\",path:`${this.prefix}/namespaces`,query:f})).data.namespaces.map(t=>({namespace:t}))}async createNamespace(f,t){return(await this.client.request({method:\"POST\",path:`${this.prefix}/namespaces`,body:{namespace:f.namespace,properties:t?.properties}})).data}async dropNamespace(f){await this.client.request({method:\"DELETE\",\npath:`${this.prefix}/namespaces/${f.namespace.join(\"\u001F\")}`})}async loadNamespaceMetadata(f){return{properties:(await this.client.request({method:\"GET\",path:`${this.prefix}/namespaces/${f.namespace.join(\"\u001F\")}`})).data.properties}}async namespaceExists(f){try{return await this.client.request({method:\"HEAD\",path:`${this.prefix}/namespaces/${f.namespace.join(\"\u001F\")}`}),!0}catch(t){if(t instanceof y&&t.status===404)return!1;throw t;}}async createNamespaceIfNotExists(f,t){try{return await this.createNamespace(f,\nt)}catch(n){if(!(n instanceof y&&n.status===409))throw n;}}},b=class{constructor(f,t=\"\",n){this.client=f;this.prefix=t;this.accessDelegation=n}async listTables(f){return(await this.client.request({method:\"GET\",path:`${this.prefix}/namespaces/${x(f.namespace)}/tables`})).data.identifiers}async createTable(f,t){const n={};this.accessDelegation&&(n[\"X-Iceberg-Access-Delegation\"]=this.accessDelegation);return(await this.client.request({method:\"POST\",path:`${this.prefix}/namespaces/${x(f.namespace)}/tables`,\nbody:t,headers:n})).data.metadata}async updateTable(f,t){f=await this.client.request({method:\"POST\",path:`${this.prefix}/namespaces/${x(f.namespace)}/tables/${f.name}`,body:t});return{\"metadata-location\":f.data[\"metadata-location\"],metadata:f.data.metadata}}async dropTable(f,t){await this.client.request({method:\"DELETE\",path:`${this.prefix}/namespaces/${x(f.namespace)}/tables/${f.name}`,query:{purgeRequested:String(t?.purge??!1)}})}async loadTable(f){const t={};this.accessDelegation&&(t[\"X-Iceberg-Access-Delegation\"]=\nthis.accessDelegation);return(await this.client.request({method:\"GET\",path:`${this.prefix}/namespaces/${x(f.namespace)}/tables/${f.name}`,headers:t})).data.metadata}async tableExists(f){const t={};this.accessDelegation&&(t[\"X-Iceberg-Access-Delegation\"]=this.accessDelegation);try{return await this.client.request({method:\"HEAD\",path:`${this.prefix}/namespaces/${x(f.namespace)}/tables/${f.name}`,headers:t}),!0}catch(n){if(n instanceof y&&n.status===404)return!1;throw n;}}async createTableIfNotExists(f,\nt){try{return await this.createTable(f,t)}catch(n){if(n instanceof y&&n.status===409)return await this.loadTable({namespace:f.namespace,name:t.name});throw n;}}};I=class{constructor(f){let t=\"v1\";f.catalogName&&(t+=`/${f.catalogName}`);const n=f.baseUrl.endsWith(\"/\")?f.baseUrl:`${f.baseUrl}/`;this.client=l({baseUrl:n,auth:f.auth,fetchImpl:f.fetch});this.accessDelegation=f.accessDelegation?.join(\",\");this.namespaceOps=new F(this.client,t);this.tableOps=new b(this.client,t,this.accessDelegation)}async listNamespaces(f){return this.namespaceOps.listNamespaces(f)}async createNamespace(f,\nt){return this.namespaceOps.createNamespace(f,t)}async dropNamespace(f){await this.namespaceOps.dropNamespace(f)}async loadNamespaceMetadata(f){return this.namespaceOps.loadNamespaceMetadata(f)}async listTables(f){return this.tableOps.listTables(f)}async createTable(f,t){return this.tableOps.createTable(f,t)}async updateTable(f,t){return this.tableOps.updateTable(f,t)}async dropTable(f,t){await this.tableOps.dropTable(f,t)}async loadTable(f){return this.tableOps.loadTable(f)}async namespaceExists(f){return this.namespaceOps.namespaceExists(f)}async tableExists(f){return this.tableOps.tableExists(f)}async createNamespaceIfNotExists(f,\nt){return this.namespaceOps.createNamespaceIfNotExists(f,t)}async createTableIfNotExists(f,t){return this.tableOps.createTableIfNotExists(f,t)}};var D=/^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/,k=/^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;a.IcebergError=y;a.IcebergRestCatalog=I;a.getCurrentSchema=function(f){return f.schemas.find(t=>t[\"schema-id\"]===f[\"current-schema-id\"])};a.isDecimalType=function(f){return D.test(f)};a.isFixedType=function(f){return k.test(f)};a.parseDecimalType=w;a.parseFixedType=z;a.typesEqual=\nfunction(f,t){var n=w(f),v=w(t);if(n&&v)return n.precision===v.precision&&n.scale===v.scale;n=z(f);v=z(t);return n&&v?n.length===v.length:f===t}}","~:source","shadow$provide[31] = function(require,module,exports) {\n'use strict';\n\n// src/errors/IcebergError.ts\nvar IcebergError = class extends Error {\n  constructor(message, opts) {\n    super(message);\n    this.name = \"IcebergError\";\n    this.status = opts.status;\n    this.icebergType = opts.icebergType;\n    this.icebergCode = opts.icebergCode;\n    this.details = opts.details;\n    this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [500, 502, 504].includes(opts.status) && opts.icebergType?.includes(\"CommitState\") === true;\n  }\n  /**\n   * Returns true if the error is a 404 Not Found error.\n   */\n  isNotFound() {\n    return this.status === 404;\n  }\n  /**\n   * Returns true if the error is a 409 Conflict error.\n   */\n  isConflict() {\n    return this.status === 409;\n  }\n  /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */\n  isAuthenticationTimeout() {\n    return this.status === 419;\n  }\n};\n\n// src/utils/url.ts\nfunction buildUrl(baseUrl, path, query) {\n  const url = new URL(path, baseUrl);\n  if (query) {\n    for (const [key, value] of Object.entries(query)) {\n      if (value !== void 0) {\n        url.searchParams.set(key, value);\n      }\n    }\n  }\n  return url.toString();\n}\n\n// src/http/createFetchClient.ts\nasync function buildAuthHeaders(auth) {\n  if (!auth || auth.type === \"none\") {\n    return {};\n  }\n  if (auth.type === \"bearer\") {\n    return { Authorization: `Bearer ${auth.token}` };\n  }\n  if (auth.type === \"header\") {\n    return { [auth.name]: auth.value };\n  }\n  if (auth.type === \"custom\") {\n    return await auth.getHeaders();\n  }\n  return {};\n}\nfunction createFetchClient(options) {\n  const fetchFn = options.fetchImpl ?? globalThis.fetch;\n  return {\n    async request({\n      method,\n      path,\n      query,\n      body,\n      headers\n    }) {\n      const url = buildUrl(options.baseUrl, path, query);\n      const authHeaders = await buildAuthHeaders(options.auth);\n      const res = await fetchFn(url, {\n        method,\n        headers: {\n          ...body ? { \"Content-Type\": \"application/json\" } : {},\n          ...authHeaders,\n          ...headers\n        },\n        body: body ? JSON.stringify(body) : void 0\n      });\n      const text = await res.text();\n      const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\n      const data = isJson && text ? JSON.parse(text) : text;\n      if (!res.ok) {\n        const errBody = isJson ? data : void 0;\n        const errorDetail = errBody?.error;\n        throw new IcebergError(\n          errorDetail?.message ?? `Request failed with status ${res.status}`,\n          {\n            status: res.status,\n            icebergType: errorDetail?.type,\n            icebergCode: errorDetail?.code,\n            details: errBody\n          }\n        );\n      }\n      return { status: res.status, headers: res.headers, data };\n    }\n  };\n}\n\n// src/catalog/namespaces.ts\nfunction namespaceToPath(namespace) {\n  return namespace.join(\"\u001F\");\n}\nvar NamespaceOperations = class {\n  constructor(client, prefix = \"\") {\n    this.client = client;\n    this.prefix = prefix;\n  }\n  async listNamespaces(parent) {\n    const query = parent ? { parent: namespaceToPath(parent.namespace) } : void 0;\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces`,\n      query\n    });\n    return response.data.namespaces.map((ns) => ({ namespace: ns }));\n  }\n  async createNamespace(id, metadata) {\n    const request = {\n      namespace: id.namespace,\n      properties: metadata?.properties\n    };\n    const response = await this.client.request({\n      method: \"POST\",\n      path: `${this.prefix}/namespaces`,\n      body: request\n    });\n    return response.data;\n  }\n  async dropNamespace(id) {\n    await this.client.request({\n      method: \"DELETE\",\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n    });\n  }\n  async loadNamespaceMetadata(id) {\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n    });\n    return {\n      properties: response.data.properties\n    };\n  }\n  async namespaceExists(id) {\n    try {\n      await this.client.request({\n        method: \"HEAD\",\n        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n      });\n      return true;\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false;\n      }\n      throw error;\n    }\n  }\n  async createNamespaceIfNotExists(id, metadata) {\n    try {\n      return await this.createNamespace(id, metadata);\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return;\n      }\n      throw error;\n    }\n  }\n};\n\n// src/catalog/tables.ts\nfunction namespaceToPath2(namespace) {\n  return namespace.join(\"\u001F\");\n}\nvar TableOperations = class {\n  constructor(client, prefix = \"\", accessDelegation) {\n    this.client = client;\n    this.prefix = prefix;\n    this.accessDelegation = accessDelegation;\n  }\n  async listTables(namespace) {\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`\n    });\n    return response.data.identifiers;\n  }\n  async createTable(namespace, request) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    const response = await this.client.request({\n      method: \"POST\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,\n      body: request,\n      headers\n    });\n    return response.data.metadata;\n  }\n  async updateTable(id, request) {\n    const response = await this.client.request({\n      method: \"POST\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n      body: request\n    });\n    return {\n      \"metadata-location\": response.data[\"metadata-location\"],\n      metadata: response.data.metadata\n    };\n  }\n  async dropTable(id, options) {\n    await this.client.request({\n      method: \"DELETE\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n      query: { purgeRequested: String(options?.purge ?? false) }\n    });\n  }\n  async loadTable(id) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n      headers\n    });\n    return response.data.metadata;\n  }\n  async tableExists(id) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    try {\n      await this.client.request({\n        method: \"HEAD\",\n        path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n        headers\n      });\n      return true;\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false;\n      }\n      throw error;\n    }\n  }\n  async createTableIfNotExists(namespace, request) {\n    try {\n      return await this.createTable(namespace, request);\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return await this.loadTable({ namespace: namespace.namespace, name: request.name });\n      }\n      throw error;\n    }\n  }\n};\n\n// src/catalog/IcebergRestCatalog.ts\nvar IcebergRestCatalog = class {\n  /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */\n  constructor(options) {\n    let prefix = \"v1\";\n    if (options.catalogName) {\n      prefix += `/${options.catalogName}`;\n    }\n    const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : `${options.baseUrl}/`;\n    this.client = createFetchClient({\n      baseUrl,\n      auth: options.auth,\n      fetchImpl: options.fetch\n    });\n    this.accessDelegation = options.accessDelegation?.join(\",\");\n    this.namespaceOps = new NamespaceOperations(this.client, prefix);\n    this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\n  }\n  /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */\n  async listNamespaces(parent) {\n    return this.namespaceOps.listNamespaces(parent);\n  }\n  /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */\n  async createNamespace(id, metadata) {\n    return this.namespaceOps.createNamespace(id, metadata);\n  }\n  /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */\n  async dropNamespace(id) {\n    await this.namespaceOps.dropNamespace(id);\n  }\n  /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */\n  async loadNamespaceMetadata(id) {\n    return this.namespaceOps.loadNamespaceMetadata(id);\n  }\n  /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */\n  async listTables(namespace) {\n    return this.tableOps.listTables(namespace);\n  }\n  /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTable(namespace, request) {\n    return this.tableOps.createTable(namespace, request);\n  }\n  /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */\n  async updateTable(id, request) {\n    return this.tableOps.updateTable(id, request);\n  }\n  /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */\n  async dropTable(id, options) {\n    await this.tableOps.dropTable(id, options);\n  }\n  /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */\n  async loadTable(id) {\n    return this.tableOps.loadTable(id);\n  }\n  /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async namespaceExists(id) {\n    return this.namespaceOps.namespaceExists(id);\n  }\n  /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async tableExists(id) {\n    return this.tableOps.tableExists(id);\n  }\n  /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */\n  async createNamespaceIfNotExists(id, metadata) {\n    return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\n  }\n  /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTableIfNotExists(namespace, request) {\n    return this.tableOps.createTableIfNotExists(namespace, request);\n  }\n};\n\n// src/catalog/types.ts\nvar DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\nvar FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;\nfunction parseDecimalType(type) {\n  const match = type.match(DECIMAL_REGEX);\n  if (!match) return null;\n  return {\n    precision: parseInt(match[1], 10),\n    scale: parseInt(match[2], 10)\n  };\n}\nfunction parseFixedType(type) {\n  const match = type.match(FIXED_REGEX);\n  if (!match) return null;\n  return {\n    length: parseInt(match[1], 10)\n  };\n}\nfunction isDecimalType(type) {\n  return DECIMAL_REGEX.test(type);\n}\nfunction isFixedType(type) {\n  return FIXED_REGEX.test(type);\n}\nfunction typesEqual(a, b) {\n  const decimalA = parseDecimalType(a);\n  const decimalB = parseDecimalType(b);\n  if (decimalA && decimalB) {\n    return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\n  }\n  const fixedA = parseFixedType(a);\n  const fixedB = parseFixedType(b);\n  if (fixedA && fixedB) {\n    return fixedA.length === fixedB.length;\n  }\n  return a === b;\n}\nfunction getCurrentSchema(metadata) {\n  return metadata.schemas.find((s) => s[\"schema-id\"] === metadata[\"current-schema-id\"]);\n}\n\nexports.IcebergError = IcebergError;\nexports.IcebergRestCatalog = IcebergRestCatalog;\nexports.getCurrentSchema = getCurrentSchema;\nexports.isDecimalType = isDecimalType;\nexports.isFixedType = isFixedType;\nexports.parseDecimalType = parseDecimalType;\nexports.parseFixedType = parseFixedType;\nexports.typesEqual = typesEqual;\n//# sourceMappingURL=index.cjs.map\n//# sourceMappingURL=index.cjs.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["properties","parseDecimalType","getCurrentSchema","parseFixedType","tableOps","namespaceOps","fetchImpl","IcebergRestCatalog","precision","body","Authorization","typesEqual","prefix","scale","method","parent","query","auth","purgeRequested","path","isCommitStateUnknown","IcebergError","name","accessDelegation","baseUrl","icebergCode","status","metadata","length","isDecimalType","details","namespace","client","isFixedType","data","icebergType","headers"]],"~:compiled-at",1771725993764,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$iceberg_js$dist$index_cjs.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/iceberg-js/dist/index.cjs\"],\n\"sourcesContent\":[\"shadow$provide[31] = function(require,module,exports) {\\n'use strict';\\n\\n// src/errors/IcebergError.ts\\nvar IcebergError = class extends Error {\\n  constructor(message, opts) {\\n    super(message);\\n    this.name = \\\"IcebergError\\\";\\n    this.status = opts.status;\\n    this.icebergType = opts.icebergType;\\n    this.icebergCode = opts.icebergCode;\\n    this.details = opts.details;\\n    this.isCommitStateUnknown = opts.icebergType === \\\"CommitStateUnknownException\\\" || [500, 502, 504].includes(opts.status) && opts.icebergType?.includes(\\\"CommitState\\\") === true;\\n  }\\n  /**\\n   * Returns true if the error is a 404 Not Found error.\\n   */\\n  isNotFound() {\\n    return this.status === 404;\\n  }\\n  /**\\n   * Returns true if the error is a 409 Conflict error.\\n   */\\n  isConflict() {\\n    return this.status === 409;\\n  }\\n  /**\\n   * Returns true if the error is a 419 Authentication Timeout error.\\n   */\\n  isAuthenticationTimeout() {\\n    return this.status === 419;\\n  }\\n};\\n\\n// src/utils/url.ts\\nfunction buildUrl(baseUrl, path, query) {\\n  const url = new URL(path, baseUrl);\\n  if (query) {\\n    for (const [key, value] of Object.entries(query)) {\\n      if (value !== void 0) {\\n        url.searchParams.set(key, value);\\n      }\\n    }\\n  }\\n  return url.toString();\\n}\\n\\n// src/http/createFetchClient.ts\\nasync function buildAuthHeaders(auth) {\\n  if (!auth || auth.type === \\\"none\\\") {\\n    return {};\\n  }\\n  if (auth.type === \\\"bearer\\\") {\\n    return { Authorization: `Bearer ${auth.token}` };\\n  }\\n  if (auth.type === \\\"header\\\") {\\n    return { [auth.name]: auth.value };\\n  }\\n  if (auth.type === \\\"custom\\\") {\\n    return await auth.getHeaders();\\n  }\\n  return {};\\n}\\nfunction createFetchClient(options) {\\n  const fetchFn = options.fetchImpl ?? globalThis.fetch;\\n  return {\\n    async request({\\n      method,\\n      path,\\n      query,\\n      body,\\n      headers\\n    }) {\\n      const url = buildUrl(options.baseUrl, path, query);\\n      const authHeaders = await buildAuthHeaders(options.auth);\\n      const res = await fetchFn(url, {\\n        method,\\n        headers: {\\n          ...body ? { \\\"Content-Type\\\": \\\"application/json\\\" } : {},\\n          ...authHeaders,\\n          ...headers\\n        },\\n        body: body ? JSON.stringify(body) : void 0\\n      });\\n      const text = await res.text();\\n      const isJson = (res.headers.get(\\\"content-type\\\") || \\\"\\\").includes(\\\"application/json\\\");\\n      const data = isJson && text ? JSON.parse(text) : text;\\n      if (!res.ok) {\\n        const errBody = isJson ? data : void 0;\\n        const errorDetail = errBody?.error;\\n        throw new IcebergError(\\n          errorDetail?.message ?? `Request failed with status ${res.status}`,\\n          {\\n            status: res.status,\\n            icebergType: errorDetail?.type,\\n            icebergCode: errorDetail?.code,\\n            details: errBody\\n          }\\n        );\\n      }\\n      return { status: res.status, headers: res.headers, data };\\n    }\\n  };\\n}\\n\\n// src/catalog/namespaces.ts\\nfunction namespaceToPath(namespace) {\\n  return namespace.join(\\\"\\u001f\\\");\\n}\\nvar NamespaceOperations = class {\\n  constructor(client, prefix = \\\"\\\") {\\n    this.client = client;\\n    this.prefix = prefix;\\n  }\\n  async listNamespaces(parent) {\\n    const query = parent ? { parent: namespaceToPath(parent.namespace) } : void 0;\\n    const response = await this.client.request({\\n      method: \\\"GET\\\",\\n      path: `${this.prefix}/namespaces`,\\n      query\\n    });\\n    return response.data.namespaces.map((ns) => ({ namespace: ns }));\\n  }\\n  async createNamespace(id, metadata) {\\n    const request = {\\n      namespace: id.namespace,\\n      properties: metadata?.properties\\n    };\\n    const response = await this.client.request({\\n      method: \\\"POST\\\",\\n      path: `${this.prefix}/namespaces`,\\n      body: request\\n    });\\n    return response.data;\\n  }\\n  async dropNamespace(id) {\\n    await this.client.request({\\n      method: \\\"DELETE\\\",\\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\\n    });\\n  }\\n  async loadNamespaceMetadata(id) {\\n    const response = await this.client.request({\\n      method: \\\"GET\\\",\\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\\n    });\\n    return {\\n      properties: response.data.properties\\n    };\\n  }\\n  async namespaceExists(id) {\\n    try {\\n      await this.client.request({\\n        method: \\\"HEAD\\\",\\n        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\\n      });\\n      return true;\\n    } catch (error) {\\n      if (error instanceof IcebergError && error.status === 404) {\\n        return false;\\n      }\\n      throw error;\\n    }\\n  }\\n  async createNamespaceIfNotExists(id, metadata) {\\n    try {\\n      return await this.createNamespace(id, metadata);\\n    } catch (error) {\\n      if (error instanceof IcebergError && error.status === 409) {\\n        return;\\n      }\\n      throw error;\\n    }\\n  }\\n};\\n\\n// src/catalog/tables.ts\\nfunction namespaceToPath2(namespace) {\\n  return namespace.join(\\\"\\u001f\\\");\\n}\\nvar TableOperations = class {\\n  constructor(client, prefix = \\\"\\\", accessDelegation) {\\n    this.client = client;\\n    this.prefix = prefix;\\n    this.accessDelegation = accessDelegation;\\n  }\\n  async listTables(namespace) {\\n    const response = await this.client.request({\\n      method: \\\"GET\\\",\\n      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`\\n    });\\n    return response.data.identifiers;\\n  }\\n  async createTable(namespace, request) {\\n    const headers = {};\\n    if (this.accessDelegation) {\\n      headers[\\\"X-Iceberg-Access-Delegation\\\"] = this.accessDelegation;\\n    }\\n    const response = await this.client.request({\\n      method: \\\"POST\\\",\\n      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,\\n      body: request,\\n      headers\\n    });\\n    return response.data.metadata;\\n  }\\n  async updateTable(id, request) {\\n    const response = await this.client.request({\\n      method: \\\"POST\\\",\\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\\n      body: request\\n    });\\n    return {\\n      \\\"metadata-location\\\": response.data[\\\"metadata-location\\\"],\\n      metadata: response.data.metadata\\n    };\\n  }\\n  async dropTable(id, options) {\\n    await this.client.request({\\n      method: \\\"DELETE\\\",\\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\\n      query: { purgeRequested: String(options?.purge ?? false) }\\n    });\\n  }\\n  async loadTable(id) {\\n    const headers = {};\\n    if (this.accessDelegation) {\\n      headers[\\\"X-Iceberg-Access-Delegation\\\"] = this.accessDelegation;\\n    }\\n    const response = await this.client.request({\\n      method: \\\"GET\\\",\\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\\n      headers\\n    });\\n    return response.data.metadata;\\n  }\\n  async tableExists(id) {\\n    const headers = {};\\n    if (this.accessDelegation) {\\n      headers[\\\"X-Iceberg-Access-Delegation\\\"] = this.accessDelegation;\\n    }\\n    try {\\n      await this.client.request({\\n        method: \\\"HEAD\\\",\\n        path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\\n        headers\\n      });\\n      return true;\\n    } catch (error) {\\n      if (error instanceof IcebergError && error.status === 404) {\\n        return false;\\n      }\\n      throw error;\\n    }\\n  }\\n  async createTableIfNotExists(namespace, request) {\\n    try {\\n      return await this.createTable(namespace, request);\\n    } catch (error) {\\n      if (error instanceof IcebergError && error.status === 409) {\\n        return await this.loadTable({ namespace: namespace.namespace, name: request.name });\\n      }\\n      throw error;\\n    }\\n  }\\n};\\n\\n// src/catalog/IcebergRestCatalog.ts\\nvar IcebergRestCatalog = class {\\n  /**\\n   * Creates a new Iceberg REST Catalog client.\\n   *\\n   * @param options - Configuration options for the catalog client\\n   */\\n  constructor(options) {\\n    let prefix = \\\"v1\\\";\\n    if (options.catalogName) {\\n      prefix += `/${options.catalogName}`;\\n    }\\n    const baseUrl = options.baseUrl.endsWith(\\\"/\\\") ? options.baseUrl : `${options.baseUrl}/`;\\n    this.client = createFetchClient({\\n      baseUrl,\\n      auth: options.auth,\\n      fetchImpl: options.fetch\\n    });\\n    this.accessDelegation = options.accessDelegation?.join(\\\",\\\");\\n    this.namespaceOps = new NamespaceOperations(this.client, prefix);\\n    this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\\n  }\\n  /**\\n   * Lists all namespaces in the catalog.\\n   *\\n   * @param parent - Optional parent namespace to list children under\\n   * @returns Array of namespace identifiers\\n   *\\n   * @example\\n   * ```typescript\\n   * // List all top-level namespaces\\n   * const namespaces = await catalog.listNamespaces();\\n   *\\n   * // List namespaces under a parent\\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\\n   * ```\\n   */\\n  async listNamespaces(parent) {\\n    return this.namespaceOps.listNamespaces(parent);\\n  }\\n  /**\\n   * Creates a new namespace in the catalog.\\n   *\\n   * @param id - Namespace identifier to create\\n   * @param metadata - Optional metadata properties for the namespace\\n   * @returns Response containing the created namespace and its properties\\n   *\\n   * @example\\n   * ```typescript\\n   * const response = await catalog.createNamespace(\\n   *   { namespace: ['analytics'] },\\n   *   { properties: { owner: 'data-team' } }\\n   * );\\n   * console.log(response.namespace); // ['analytics']\\n   * console.log(response.properties); // { owner: 'data-team', ... }\\n   * ```\\n   */\\n  async createNamespace(id, metadata) {\\n    return this.namespaceOps.createNamespace(id, metadata);\\n  }\\n  /**\\n   * Drops a namespace from the catalog.\\n   *\\n   * The namespace must be empty (contain no tables) before it can be dropped.\\n   *\\n   * @param id - Namespace identifier to drop\\n   *\\n   * @example\\n   * ```typescript\\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\\n   * ```\\n   */\\n  async dropNamespace(id) {\\n    await this.namespaceOps.dropNamespace(id);\\n  }\\n  /**\\n   * Loads metadata for a namespace.\\n   *\\n   * @param id - Namespace identifier to load\\n   * @returns Namespace metadata including properties\\n   *\\n   * @example\\n   * ```typescript\\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\\n   * console.log(metadata.properties);\\n   * ```\\n   */\\n  async loadNamespaceMetadata(id) {\\n    return this.namespaceOps.loadNamespaceMetadata(id);\\n  }\\n  /**\\n   * Lists all tables in a namespace.\\n   *\\n   * @param namespace - Namespace identifier to list tables from\\n   * @returns Array of table identifiers\\n   *\\n   * @example\\n   * ```typescript\\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\\n   * ```\\n   */\\n  async listTables(namespace) {\\n    return this.tableOps.listTables(namespace);\\n  }\\n  /**\\n   * Creates a new table in the catalog.\\n   *\\n   * @param namespace - Namespace to create the table in\\n   * @param request - Table creation request including name, schema, partition spec, etc.\\n   * @returns Table metadata for the created table\\n   *\\n   * @example\\n   * ```typescript\\n   * const metadata = await catalog.createTable(\\n   *   { namespace: ['analytics'] },\\n   *   {\\n   *     name: 'events',\\n   *     schema: {\\n   *       type: 'struct',\\n   *       fields: [\\n   *         { id: 1, name: 'id', type: 'long', required: true },\\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\\n   *       ],\\n   *       'schema-id': 0\\n   *     },\\n   *     'partition-spec': {\\n   *       'spec-id': 0,\\n   *       fields: [\\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\\n   *       ]\\n   *     }\\n   *   }\\n   * );\\n   * ```\\n   */\\n  async createTable(namespace, request) {\\n    return this.tableOps.createTable(namespace, request);\\n  }\\n  /**\\n   * Updates an existing table's metadata.\\n   *\\n   * Can update the schema, partition spec, or properties of a table.\\n   *\\n   * @param id - Table identifier to update\\n   * @param request - Update request with fields to modify\\n   * @returns Response containing the metadata location and updated table metadata\\n   *\\n   * @example\\n   * ```typescript\\n   * const response = await catalog.updateTable(\\n   *   { namespace: ['analytics'], name: 'events' },\\n   *   {\\n   *     properties: { 'read.split.target-size': '134217728' }\\n   *   }\\n   * );\\n   * console.log(response['metadata-location']); // s3://...\\n   * console.log(response.metadata); // TableMetadata object\\n   * ```\\n   */\\n  async updateTable(id, request) {\\n    return this.tableOps.updateTable(id, request);\\n  }\\n  /**\\n   * Drops a table from the catalog.\\n   *\\n   * @param id - Table identifier to drop\\n   *\\n   * @example\\n   * ```typescript\\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\\n   * ```\\n   */\\n  async dropTable(id, options) {\\n    await this.tableOps.dropTable(id, options);\\n  }\\n  /**\\n   * Loads metadata for a table.\\n   *\\n   * @param id - Table identifier to load\\n   * @returns Table metadata including schema, partition spec, location, etc.\\n   *\\n   * @example\\n   * ```typescript\\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\\n   * console.log(metadata.schema);\\n   * console.log(metadata.location);\\n   * ```\\n   */\\n  async loadTable(id) {\\n    return this.tableOps.loadTable(id);\\n  }\\n  /**\\n   * Checks if a namespace exists in the catalog.\\n   *\\n   * @param id - Namespace identifier to check\\n   * @returns True if the namespace exists, false otherwise\\n   *\\n   * @example\\n   * ```typescript\\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\\n   * console.log(exists); // true or false\\n   * ```\\n   */\\n  async namespaceExists(id) {\\n    return this.namespaceOps.namespaceExists(id);\\n  }\\n  /**\\n   * Checks if a table exists in the catalog.\\n   *\\n   * @param id - Table identifier to check\\n   * @returns True if the table exists, false otherwise\\n   *\\n   * @example\\n   * ```typescript\\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\\n   * console.log(exists); // true or false\\n   * ```\\n   */\\n  async tableExists(id) {\\n    return this.tableOps.tableExists(id);\\n  }\\n  /**\\n   * Creates a namespace if it does not exist.\\n   *\\n   * If the namespace already exists, returns void. If created, returns the response.\\n   *\\n   * @param id - Namespace identifier to create\\n   * @param metadata - Optional metadata properties for the namespace\\n   * @returns Response containing the created namespace and its properties, or void if it already exists\\n   *\\n   * @example\\n   * ```typescript\\n   * const response = await catalog.createNamespaceIfNotExists(\\n   *   { namespace: ['analytics'] },\\n   *   { properties: { owner: 'data-team' } }\\n   * );\\n   * if (response) {\\n   *   console.log('Created:', response.namespace);\\n   * } else {\\n   *   console.log('Already exists');\\n   * }\\n   * ```\\n   */\\n  async createNamespaceIfNotExists(id, metadata) {\\n    return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\\n  }\\n  /**\\n   * Creates a table if it does not exist.\\n   *\\n   * If the table already exists, returns its metadata instead.\\n   *\\n   * @param namespace - Namespace to create the table in\\n   * @param request - Table creation request including name, schema, partition spec, etc.\\n   * @returns Table metadata for the created or existing table\\n   *\\n   * @example\\n   * ```typescript\\n   * const metadata = await catalog.createTableIfNotExists(\\n   *   { namespace: ['analytics'] },\\n   *   {\\n   *     name: 'events',\\n   *     schema: {\\n   *       type: 'struct',\\n   *       fields: [\\n   *         { id: 1, name: 'id', type: 'long', required: true },\\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\\n   *       ],\\n   *       'schema-id': 0\\n   *     }\\n   *   }\\n   * );\\n   * ```\\n   */\\n  async createTableIfNotExists(namespace, request) {\\n    return this.tableOps.createTableIfNotExists(namespace, request);\\n  }\\n};\\n\\n// src/catalog/types.ts\\nvar DECIMAL_REGEX = /^decimal\\\\s*\\\\(\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*\\\\)$/;\\nvar FIXED_REGEX = /^fixed\\\\s*\\\\[\\\\s*(\\\\d+)\\\\s*\\\\]$/;\\nfunction parseDecimalType(type) {\\n  const match = type.match(DECIMAL_REGEX);\\n  if (!match) return null;\\n  return {\\n    precision: parseInt(match[1], 10),\\n    scale: parseInt(match[2], 10)\\n  };\\n}\\nfunction parseFixedType(type) {\\n  const match = type.match(FIXED_REGEX);\\n  if (!match) return null;\\n  return {\\n    length: parseInt(match[1], 10)\\n  };\\n}\\nfunction isDecimalType(type) {\\n  return DECIMAL_REGEX.test(type);\\n}\\nfunction isFixedType(type) {\\n  return FIXED_REGEX.test(type);\\n}\\nfunction typesEqual(a, b) {\\n  const decimalA = parseDecimalType(a);\\n  const decimalB = parseDecimalType(b);\\n  if (decimalA && decimalB) {\\n    return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\\n  }\\n  const fixedA = parseFixedType(a);\\n  const fixedB = parseFixedType(b);\\n  if (fixedA && fixedB) {\\n    return fixedA.length === fixedB.length;\\n  }\\n  return a === b;\\n}\\nfunction getCurrentSchema(metadata) {\\n  return metadata.schemas.find((s) => s[\\\"schema-id\\\"] === metadata[\\\"current-schema-id\\\"]);\\n}\\n\\nexports.IcebergError = IcebergError;\\nexports.IcebergRestCatalog = IcebergRestCatalog;\\nexports.getCurrentSchema = getCurrentSchema;\\nexports.isDecimalType = isDecimalType;\\nexports.isFixedType = isFixedType;\\nexports.parseDecimalType = parseDecimalType;\\nexports.parseFixedType = parseFixedType;\\nexports.typesEqual = typesEqual;\\n//# sourceMappingURL=index.cjs.map\\n//# sourceMappingURL=index.cjs.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"buildAuthHeaders\",\"auth\",\"type\",\"Authorization\",\"token\",\"name\",\"value\",\"getHeaders\",\"createFetchClient\",\"options\",\"fetchFn\",\"fetchImpl\",\"globalThis\",\"fetch\",\"request\",\"method\",\"path\",\"query\",\"body\",\"headers\",\"url\",\"URL\",\"baseUrl\",\"key\",\"Object\",\"entries\",\"searchParams\",\"set\",\"toString\",\"authHeaders\",\"res\",\"JSON\",\"stringify\",\"text\",\"data\",\"isJson\",\"includes\",\"get\",\"parse\",\"ok\",\"errBody\",\"errorDetail\",\"error\",\"IcebergError\",\"message\",\"status\",\"icebergType\",\"icebergCode\",\"code\",\"details\",\"namespaceToPath2\",\"namespace\",\"join\",\"parseDecimalType\",\"match\",\"DECIMAL_REGEX\",\"precision\",\"parseInt\",\"scale\",\"parseFixedType\",\"FIXED_REGEX\",\"length\",\"Error\",\"constructor\",\"opts\",\"isCommitStateUnknown\",\"isNotFound\",\"isConflict\",\"isAuthenticationTimeout\",\"NamespaceOperations\",\"client\",\"prefix\",\"listNamespaces\",\"parent\",\"response\",\"namespaces\",\"map\",\"ns\",\"createNamespace\",\"id\",\"metadata\",\"properties\",\"dropNamespace\",\"loadNamespaceMetadata\",\"namespaceExists\",\"createNamespaceIfNotExists\",\"TableOperations\",\"accessDelegation\",\"listTables\",\"identifiers\",\"createTable\",\"updateTable\",\"dropTable\",\"purgeRequested\",\"String\",\"purge\",\"loadTable\",\"tableExists\",\"createTableIfNotExists\",\"IcebergRestCatalog\",\"catalogName\",\"endsWith\",\"namespaceOps\",\"tableOps\",\"getCurrentSchema\",\"schemas\",\"find\",\"s\",\"isDecimalType\",\"test\",\"isFixedType\",\"typesEqual\",\"a\",\"b\",\"decimalA\",\"decimalB\",\"fixedA\",\"fixedB\"]\n}\n"]