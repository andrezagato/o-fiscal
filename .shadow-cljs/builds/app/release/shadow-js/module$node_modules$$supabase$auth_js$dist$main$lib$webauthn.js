["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/auth-js/dist/main/lib/webauthn.js"],"~:js","shadow$provide[49]=function(S,ka,a){function I(){var z,J;return!!((0,p.isBrowser)()&&\"PublicKeyCredential\"in window&&window.PublicKeyCredential&&\"credentials\"in navigator&&typeof((z=navigator===null||navigator===void 0?void 0:navigator.credentials)===null||z===void 0?void 0:z.create)===\"function\"&&typeof((J=navigator===null||navigator===void 0?void 0:navigator.credentials)===null||J===void 0?void 0:J.get)===\"function\")}async function q(z){try{const J=await navigator.credentials.create(z);return J?\nJ instanceof PublicKeyCredential?{data:J,error:null}:{data:null,error:new k.WebAuthnUnknownError(\"Browser returned unexpected credential type\",J)}:{data:null,error:new k.WebAuthnUnknownError(\"Empty credential response\",J)}}catch(J){return{data:null,error:(0,k.identifyRegistrationError)({error:J,options:z})}}}async function D(z){try{const J=await navigator.credentials.get(z);return J?J instanceof PublicKeyCredential?{data:J,error:null}:{data:null,error:new k.WebAuthnUnknownError(\"Browser returned unexpected credential type\",\nJ)}:{data:null,error:new k.WebAuthnUnknownError(\"Empty credential response\",J)}}catch(J){return{data:null,error:(0,k.identifyAuthenticationError)({error:J,options:z})}}}function C(...z){const J={};for(const l of z)if(l)for(const t in l)if(z=l[t],z!==void 0)if(Array.isArray(z))J[t]=z;else if(z instanceof ArrayBuffer||ArrayBuffer.isView(z))J[t]=z;else if(z===null||typeof z!==\"object\"||Array.isArray(z))J[t]=z;else{const x=J[t];x===null||typeof x!==\"object\"||Array.isArray(x)?J[t]=C(z):J[t]=C(x,z)}return J}\nfunction G(z,J){return C(a.DEFAULT_CREATION_OPTIONS,z,J||{})}function E(z,J){return C(a.DEFAULT_REQUEST_OPTIONS,z,J||{})}Object.defineProperty(a,\"__esModule\",{value:!0});a.WebAuthnApi=a.DEFAULT_REQUEST_OPTIONS=a.DEFAULT_CREATION_OPTIONS=a.webAuthnAbortService=a.WebAuthnAbortService=a.identifyAuthenticationError=a.identifyRegistrationError=a.isWebAuthnError=a.WebAuthnError=void 0;a.deserializeCredentialCreationOptions=function(z){if(!z)throw Error(\"Credential creation options are required\");if(typeof PublicKeyCredential!==\n\"undefined\"&&\"parseCreationOptionsFromJSON\"in PublicKeyCredential&&typeof PublicKeyCredential.parseCreationOptionsFromJSON===\"function\")return PublicKeyCredential.parseCreationOptionsFromJSON(z);const {challenge:J,user:l,excludeCredentials:t}=z;z=M.__rest(z,[\"challenge\",\"user\",\"excludeCredentials\"]);var x=(0,d.base64UrlToUint8Array)(J).buffer,w=Object.assign(Object.assign({},l),{id:(0,d.base64UrlToUint8Array)(l.id).buffer});z=Object.assign(Object.assign({},z),{challenge:x,user:w});if(t&&t.length>\n0)for(z.excludeCredentials=Array(t.length),x=0;x<t.length;x++)w=t[x],z.excludeCredentials[x]=Object.assign(Object.assign({},w),{id:(0,d.base64UrlToUint8Array)(w.id).buffer,type:w.type||\"public-key\",transports:w.transports});return z};a.deserializeCredentialRequestOptions=function(z){if(!z)throw Error(\"Credential request options are required\");if(typeof PublicKeyCredential!==\"undefined\"&&\"parseRequestOptionsFromJSON\"in PublicKeyCredential&&typeof PublicKeyCredential.parseRequestOptionsFromJSON===\"function\")return PublicKeyCredential.parseRequestOptionsFromJSON(z);\nconst {challenge:J,allowCredentials:l}=z;z=M.__rest(z,[\"challenge\",\"allowCredentials\"]);var t=(0,d.base64UrlToUint8Array)(J).buffer;z=Object.assign(Object.assign({},z),{challenge:t});if(l&&l.length>0)for(z.allowCredentials=Array(l.length),t=0;t<l.length;t++){const x=l[t];z.allowCredentials[t]=Object.assign(Object.assign({},x),{id:(0,d.base64UrlToUint8Array)(x.id).buffer,type:x.type||\"public-key\",transports:x.transports})}return z};a.serializeCredentialCreationResponse=function(z){var J;return\"toJSON\"in\nz&&typeof z.toJSON===\"function\"?z.toJSON():{id:z.id,rawId:z.id,response:{attestationObject:(0,d.bytesToBase64URL)(new Uint8Array(z.response.attestationObject)),clientDataJSON:(0,d.bytesToBase64URL)(new Uint8Array(z.response.clientDataJSON))},type:\"public-key\",clientExtensionResults:z.getClientExtensionResults(),authenticatorAttachment:(J=z.authenticatorAttachment)!==null&&J!==void 0?J:void 0}};a.serializeCredentialRequestResponse=function(z){var J;if(\"toJSON\"in z&&typeof z.toJSON===\"function\")return z.toJSON();\nconst l=z.getClientExtensionResults(),t=z.response;return{id:z.id,rawId:z.id,response:{authenticatorData:(0,d.bytesToBase64URL)(new Uint8Array(t.authenticatorData)),clientDataJSON:(0,d.bytesToBase64URL)(new Uint8Array(t.clientDataJSON)),signature:(0,d.bytesToBase64URL)(new Uint8Array(t.signature)),userHandle:t.userHandle?(0,d.bytesToBase64URL)(new Uint8Array(t.userHandle)):void 0},type:\"public-key\",clientExtensionResults:l,authenticatorAttachment:(J=z.authenticatorAttachment)!==null&&J!==void 0?J:\nvoid 0}};a.isValidDomain=function(z){return z===\"localhost\"||/^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(z)};a.createCredential=q;a.getCredential=D;a.mergeCredentialCreationOptions=G;a.mergeCredentialRequestOptions=E;const M=S(14),d=S(39),K=S(38),p=S(40),k=S(48);Object.defineProperty(a,\"identifyAuthenticationError\",{enumerable:!0,get:function(){return k.identifyAuthenticationError}});Object.defineProperty(a,\"identifyRegistrationError\",{enumerable:!0,get:function(){return k.identifyRegistrationError}});\nObject.defineProperty(a,\"isWebAuthnError\",{enumerable:!0,get:function(){return k.isWebAuthnError}});Object.defineProperty(a,\"WebAuthnError\",{enumerable:!0,get:function(){return k.WebAuthnError}});class y{createNewAbortSignal(){if(this.controller){var z=Error(\"Cancelling existing WebAuthn API call for new one\");z.name=\"AbortError\";this.controller.abort(z)}this.controller=z=new AbortController;return z.signal}cancelCeremony(){if(this.controller){const z=Error(\"Manually cancelling existing WebAuthn API call\");\nz.name=\"AbortError\";this.controller.abort(z);this.controller=void 0}}}a.WebAuthnAbortService=y;a.webAuthnAbortService=new y;a.DEFAULT_CREATION_OPTIONS={hints:[\"security-key\"],authenticatorSelection:{authenticatorAttachment:\"cross-platform\",requireResidentKey:!1,userVerification:\"preferred\",residentKey:\"discouraged\"},attestation:\"direct\"};a.DEFAULT_REQUEST_OPTIONS={userVerification:\"preferred\",hints:[\"security-key\"],attestation:\"direct\"};class v{constructor(z){this.client=z;this.enroll=this._enroll.bind(this);\nthis.challenge=this._challenge.bind(this);this.verify=this._verify.bind(this);this.authenticate=this._authenticate.bind(this);this.register=this._register.bind(this)}async _enroll(z){return this.client.mfa.enroll(Object.assign(Object.assign({},z),{factorType:\"webauthn\"}))}async _challenge({factorId:z,webauthn:J,friendlyName:l,signal:t},x){var w;try{const {data:A,error:L}=await this.client.mfa.challenge({factorId:z,webauthn:J});if(!A)return{data:null,error:L};const P=t!==null&&t!==void 0?t:a.webAuthnAbortService.createNewAbortSignal();\nif(A.webauthn.type===\"create\"){const {user:T}=A.webauthn.credential_options.publicKey;if(!T.name)if(l)T.name=`${T.id}:${l}`;else{const Y=(await this.client.getUser()).data.user,ha=((w=Y===null||Y===void 0?void 0:Y.user_metadata)===null||w===void 0?void 0:w.name)||(Y===null||Y===void 0?void 0:Y.email)||(Y===null||Y===void 0?void 0:Y.id)||\"User\";T.name=`${T.id}:${ha}`}T.displayName||(T.displayName=T.name)}switch(A.webauthn.type){case \"create\":const T=G(A.webauthn.credential_options.publicKey,x===null||\nx===void 0?void 0:x.create),{data:Y,error:ha}=await q({publicKey:T,signal:P});return Y?{data:{factorId:z,challengeId:A.id,webauthn:{type:A.webauthn.type,credential_response:Y}},error:null}:{data:null,error:ha};case \"request\":const da=E(A.webauthn.credential_options.publicKey,x===null||x===void 0?void 0:x.request),{data:fa,error:ja}=await D(Object.assign(Object.assign({},A.webauthn.credential_options),{publicKey:da,signal:P}));return fa?{data:{factorId:z,challengeId:A.id,webauthn:{type:A.webauthn.type,\ncredential_response:fa}},error:null}:{data:null,error:ja}}}catch(A){return(0,K.isAuthError)(A)?{data:null,error:A}:{data:null,error:new K.AuthUnknownError(\"Unexpected error in challenge\",A)}}}async _verify({challengeId:z,factorId:J,webauthn:l}){return this.client.mfa.verify({factorId:J,challengeId:z,webauthn:l})}async _authenticate({factorId:z,webauthn:{rpId:J=typeof window!==\"undefined\"?window.location.hostname:void 0,rpOrigins:l=typeof window!==\"undefined\"?[window.location.origin]:void 0,signal:t}=\n{}},x){if(!J)return{data:null,error:new K.AuthError(\"rpId is required for WebAuthn authentication\")};try{if(!I())return{data:null,error:new K.AuthUnknownError(\"Browser does not support WebAuthn\",null)};const {data:w,error:A}=await this.challenge({factorId:z,webauthn:{rpId:J,rpOrigins:l},signal:t},{request:x});if(!w)return{data:null,error:A};({webauthn:t}=w);return this._verify({factorId:z,challengeId:w.challengeId,webauthn:{type:t.type,rpId:J,rpOrigins:l,credential_response:t.credential_response}})}catch(w){return(0,K.isAuthError)(w)?\n{data:null,error:w}:{data:null,error:new K.AuthUnknownError(\"Unexpected error in authenticate\",w)}}}async _register({friendlyName:z,webauthn:{rpId:J=typeof window!==\"undefined\"?window.location.hostname:void 0,rpOrigins:l=typeof window!==\"undefined\"?[window.location.origin]:void 0,signal:t}={}},x){if(!J)return{data:null,error:new K.AuthError(\"rpId is required for WebAuthn registration\")};try{if(!I())return{data:null,error:new K.AuthUnknownError(\"Browser does not support WebAuthn\",null)};const {data:w,\nerror:A}=await this._enroll({friendlyName:z});if(!w)return await this.client.mfa.listFactors().then(T=>{var Y;return(Y=T.data)===null||Y===void 0?void 0:Y.all.find(ha=>ha.factor_type===\"webauthn\"&&ha.friendly_name===z&&ha.status!==\"unverified\")}).then(T=>T?this.client.mfa.unenroll({factorId:T===null||T===void 0?void 0:T.id}):void 0),{data:null,error:A};const {data:L,error:P}=await this._challenge({factorId:w.id,friendlyName:w.friendly_name,webauthn:{rpId:J,rpOrigins:l},signal:t},{create:x});return L?\nthis._verify({factorId:w.id,challengeId:L.challengeId,webauthn:{rpId:J,rpOrigins:l,type:L.webauthn.type,credential_response:L.webauthn.credential_response}}):{data:null,error:P}}catch(w){return(0,K.isAuthError)(w)?{data:null,error:w}:{data:null,error:new K.AuthUnknownError(\"Unexpected error in register\",w)}}}}a.WebAuthnApi=v}","~:source","shadow$provide[49] = function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebAuthnApi = exports.DEFAULT_REQUEST_OPTIONS = exports.DEFAULT_CREATION_OPTIONS = exports.webAuthnAbortService = exports.WebAuthnAbortService = exports.identifyAuthenticationError = exports.identifyRegistrationError = exports.isWebAuthnError = exports.WebAuthnError = void 0;\nexports.deserializeCredentialCreationOptions = deserializeCredentialCreationOptions;\nexports.deserializeCredentialRequestOptions = deserializeCredentialRequestOptions;\nexports.serializeCredentialCreationResponse = serializeCredentialCreationResponse;\nexports.serializeCredentialRequestResponse = serializeCredentialRequestResponse;\nexports.isValidDomain = isValidDomain;\nexports.createCredential = createCredential;\nexports.getCredential = getCredential;\nexports.mergeCredentialCreationOptions = mergeCredentialCreationOptions;\nexports.mergeCredentialRequestOptions = mergeCredentialRequestOptions;\nconst tslib_1 = require(\"tslib\");\nconst base64url_1 = require(\"./base64url\");\nconst errors_1 = require(\"./errors\");\nconst helpers_1 = require(\"./helpers\");\nconst webauthn_errors_1 = require(\"./webauthn.errors\");\nObject.defineProperty(exports, \"identifyAuthenticationError\", { enumerable: true, get: function () { return webauthn_errors_1.identifyAuthenticationError; } });\nObject.defineProperty(exports, \"identifyRegistrationError\", { enumerable: true, get: function () { return webauthn_errors_1.identifyRegistrationError; } });\nObject.defineProperty(exports, \"isWebAuthnError\", { enumerable: true, get: function () { return webauthn_errors_1.isWebAuthnError; } });\nObject.defineProperty(exports, \"WebAuthnError\", { enumerable: true, get: function () { return webauthn_errors_1.WebAuthnError; } });\n/**\n * WebAuthn abort service to manage ceremony cancellation.\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\n *\n * @experimental This class is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\n */\nclass WebAuthnAbortService {\n    /**\n     * Create an abort signal for a new WebAuthn operation.\n     * Automatically cancels any existing operation.\n     *\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\n     */\n    createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    /**\n     * Manually cancel the current WebAuthn operation.\n     * Useful for cleaning up when user cancels or navigates away.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\n     */\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nexports.WebAuthnAbortService = WebAuthnAbortService;\n/**\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\n *\n * @experimental This instance is experimental and may change in future releases\n */\nexports.webAuthnAbortService = new WebAuthnAbortService();\n/**\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\n */\nfunction deserializeCredentialCreationOptions(options) {\n    if (!options) {\n        throw new Error('Credential creation options are required');\n    }\n    // Check if the native parseCreationOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== 'undefined' &&\n        'parseCreationOptionsFromJSON' in PublicKeyCredential &&\n        typeof PublicKeyCredential\n            .parseCreationOptionsFromJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseCreationOptionsFromJSON(\n        /** we assert the options here as typescript still doesn't know about future webauthn types */\n        options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = tslib_1.__rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"user\", \"excludeCredentials\"]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\n    // Convert user.id from base64url to ArrayBuffer\n    const user = Object.assign(Object.assign({}, userOpts), { id: (0, base64url_1.base64UrlToUint8Array)(userOpts.id).buffer });\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), { challenge,\n        user });\n    // Only add excludeCredentials if it exists\n    if (excludeCredentials && excludeCredentials.length > 0) {\n        result.excludeCredentials = new Array(excludeCredentials.length);\n        for (let i = 0; i < excludeCredentials.length; i++) {\n            const cred = excludeCredentials[i];\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports });\n        }\n    }\n    return result;\n}\n/**\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\n */\nfunction deserializeCredentialRequestOptions(options) {\n    if (!options) {\n        throw new Error('Credential request options are required');\n    }\n    // Check if the native parseRequestOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== 'undefined' &&\n        'parseRequestOptionsFromJSON' in PublicKeyCredential &&\n        typeof PublicKeyCredential\n            .parseRequestOptionsFromJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = tslib_1.__rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"allowCredentials\"]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), { challenge });\n    // Only add allowCredentials if it exists\n    if (allowCredentials && allowCredentials.length > 0) {\n        result.allowCredentials = new Array(allowCredentials.length);\n        for (let i = 0; i < allowCredentials.length; i++) {\n            const cred = allowCredentials[i];\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports });\n        }\n    }\n    return result;\n}\n/**\n * Convert a registration/enrollment credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */\nfunction serializeCredentialCreationResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    const credentialWithAttachment = credential;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            attestationObject: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON)),\n        },\n        type: 'public-key',\n        clientExtensionResults: credential.getClientExtensionResults(),\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\n    };\n}\n/**\n * Convert an authentication/verification credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */\nfunction serializeCredentialRequestResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    // Fallback to manual conversion for browsers that don't support toJSON\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n    const credentialWithAttachment = credential;\n    const clientExtensionResults = credential.getClientExtensionResults();\n    const assertionResponse = credential.response;\n    return {\n        id: credential.id,\n        rawId: credential.id, // W3C spec expects rawId to match id for JSON format\n        response: {\n            authenticatorData: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\n            signature: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\n            userHandle: assertionResponse.userHandle\n                ? (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle))\n                : undefined,\n        },\n        type: 'public-key',\n        clientExtensionResults,\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\n    };\n}\n/**\n * A simple test to determine if a hostname is a properly-formatted domain name.\n * Considers localhost valid for development environments.\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n *\n * @param {string} hostname - The hostname to validate\n * @returns {boolean} True if valid domain or localhost\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\n */\nfunction isValidDomain(hostname) {\n    return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n/**\n * Determine if the browser is capable of WebAuthn.\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\n *\n * @returns {boolean} True if browser supports WebAuthn\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\n */\nfunction browserSupportsWebAuthn() {\n    var _a, _b;\n    return !!((0, helpers_1.isBrowser)() &&\n        'PublicKeyCredential' in window &&\n        window.PublicKeyCredential &&\n        'credentials' in navigator &&\n        typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' &&\n        typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');\n}\n/**\n * Create a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.create() with error handling.\n *\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\n */\nasync function createCredential(options) {\n    try {\n        const response = await navigator.credentials.create(\n        /** we assert the type here until typescript types are updated */\n        options);\n        if (!response) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\n            };\n        }\n        return { data: response, error: null };\n    }\n    catch (err) {\n        return {\n            data: null,\n            error: (0, webauthn_errors_1.identifyRegistrationError)({\n                error: err,\n                options,\n            }),\n        };\n    }\n}\n/**\n * Get a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.get() with error handling.\n *\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\n */\nasync function getCredential(options) {\n    try {\n        const response = await navigator.credentials.get(\n        /** we assert the type here until typescript types are updated */\n        options);\n        if (!response) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\n            };\n        }\n        return { data: response, error: null };\n    }\n    catch (err) {\n        return {\n            data: null,\n            error: (0, webauthn_errors_1.identifyAuthenticationError)({\n                error: err,\n                options,\n            }),\n        };\n    }\n}\nexports.DEFAULT_CREATION_OPTIONS = {\n    hints: ['security-key'],\n    authenticatorSelection: {\n        authenticatorAttachment: 'cross-platform',\n        requireResidentKey: false,\n        /** set to preferred because older yubikeys don't have PIN/Biometric */\n        userVerification: 'preferred',\n        residentKey: 'discouraged',\n    },\n    attestation: 'direct',\n};\nexports.DEFAULT_REQUEST_OPTIONS = {\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\n    userVerification: 'preferred',\n    hints: ['security-key'],\n    attestation: 'direct',\n};\nfunction deepMerge(...sources) {\n    const isObject = (val) => val !== null && typeof val === 'object' && !Array.isArray(val);\n    const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n    const result = {};\n    for (const source of sources) {\n        if (!source)\n            continue;\n        for (const key in source) {\n            const value = source[key];\n            if (value === undefined)\n                continue;\n            if (Array.isArray(value)) {\n                // preserve array reference, including unions like AuthenticatorTransport[]\n                result[key] = value;\n            }\n            else if (isArrayBufferLike(value)) {\n                result[key] = value;\n            }\n            else if (isObject(value)) {\n                const existing = result[key];\n                if (isObject(existing)) {\n                    result[key] = deepMerge(existing, value);\n                }\n                else {\n                    result[key] = deepMerge(value);\n                }\n            }\n            else {\n                result[key] = value;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Merges WebAuthn credential creation options with overrides.\n * Sets sensible defaults for authenticator selection and extensions.\n *\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\n * @param {string} friendlyName - Optional friendly name for the credential\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\n */\nfunction mergeCredentialCreationOptions(baseOptions, overrides) {\n    return deepMerge(exports.DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * Merges WebAuthn credential request options with overrides.\n * Sets sensible defaults for user verification and hints.\n *\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\n */\nfunction mergeCredentialRequestOptions(baseOptions, overrides) {\n    return deepMerge(exports.DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * WebAuthn API wrapper for Supabase Auth.\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\n *\n * @experimental This API is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\n */\nclass WebAuthnApi {\n    constructor(client) {\n        this.client = client;\n        // Bind all methods so they can be destructured\n        this.enroll = this._enroll.bind(this);\n        this.challenge = this._challenge.bind(this);\n        this.verify = this._verify.bind(this);\n        this.authenticate = this._authenticate.bind(this);\n        this.register = this._register.bind(this);\n    }\n    /**\n     * Enroll a new WebAuthn factor.\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\n     */\n    async _enroll(params) {\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: 'webauthn' }));\n    }\n    /**\n     * Challenge for WebAuthn credential creation or authentication.\n     * Combines server challenge with browser credential operations.\n     * Handles both registration (create) and authentication (request) flows.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\n     */\n    async _challenge({ factorId, webauthn, friendlyName, signal, }, overrides) {\n        var _a;\n        try {\n            // Get challenge from server using the client's MFA methods\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\n                factorId,\n                webauthn,\n            });\n            if (!challengeResponse) {\n                return { data: null, error: challengeError };\n            }\n            const abortSignal = signal !== null && signal !== void 0 ? signal : exports.webAuthnAbortService.createNewAbortSignal();\n            /** webauthn will fail if either of the name/displayname are blank */\n            if (challengeResponse.webauthn.type === 'create') {\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\n                if (!user.name) {\n                    // Preserve original format: use friendlyName if provided, otherwise fetch fallback\n                    // This maintains backward compatibility with the ${user.id}:${name} format\n                    const nameToUse = friendlyName;\n                    if (!nameToUse) {\n                        // Only fetch user data if friendlyName is not provided (bug fix for null friendlyName)\n                        const currentUser = await this.client.getUser();\n                        const userData = currentUser.data.user;\n                        const fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || 'User';\n                        user.name = `${user.id}:${fallbackName}`;\n                    }\n                    else {\n                        user.name = `${user.id}:${nameToUse}`;\n                    }\n                }\n                if (!user.displayName) {\n                    user.displayName = user.name;\n                }\n            }\n            switch (challengeResponse.webauthn.type) {\n                case 'create': {\n                    const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n                    const { data, error } = await createCredential({\n                        publicKey: options,\n                        signal: abortSignal,\n                    });\n                    if (data) {\n                        return {\n                            data: {\n                                factorId,\n                                challengeId: challengeResponse.id,\n                                webauthn: {\n                                    type: challengeResponse.webauthn.type,\n                                    credential_response: data,\n                                },\n                            },\n                            error: null,\n                        };\n                    }\n                    return { data: null, error };\n                }\n                case 'request': {\n                    const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n                    const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));\n                    if (data) {\n                        return {\n                            data: {\n                                factorId,\n                                challengeId: challengeResponse.id,\n                                webauthn: {\n                                    type: challengeResponse.webauthn.type,\n                                    credential_response: data,\n                                },\n                            },\n                            error: null,\n                        };\n                    }\n                    return { data: null, error };\n                }\n            }\n        }\n        catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            return {\n                data: null,\n                error: new errors_1.AuthUnknownError('Unexpected error in challenge', error),\n            };\n        }\n    }\n    /**\n     * Verify a WebAuthn credential with the server.\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Verification parameters\n     * @param {string} params.challengeId - ID of the challenge being verified\n     * @param {string} params.factorId - ID of the WebAuthn factor\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\n     * */\n    async _verify({ challengeId, factorId, webauthn, }) {\n        return this.client.mfa.verify({\n            factorId,\n            challengeId,\n            webauthn: webauthn,\n        });\n    }\n    /**\n     * Complete WebAuthn authentication flow.\n     * Performs challenge and verification in a single operation for existing credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Authentication parameters\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\n     * @param {Object} params.webauthn - WebAuthn configuration\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\n     */\n    async _authenticate({ factorId, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new errors_1.AuthError('rpId is required for WebAuthn authentication'),\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\n                };\n            }\n            // Get challenge and credential\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\n                factorId,\n                webauthn: { rpId, rpOrigins },\n                signal,\n            }, { request: overrides });\n            if (!challengeResponse) {\n                return { data: null, error: challengeError };\n            }\n            const { webauthn } = challengeResponse;\n            // Verify credential\n            return this._verify({\n                factorId,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    type: webauthn.type,\n                    rpId,\n                    rpOrigins,\n                    credential_response: webauthn.credential_response,\n                },\n            });\n        }\n        catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            return {\n                data: null,\n                error: new errors_1.AuthUnknownError('Unexpected error in authenticate', error),\n            };\n        }\n    }\n    /**\n     * Complete WebAuthn registration flow.\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Registration parameters\n     * @param {string} params.friendlyName - User-friendly name for the credential\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.signal - Optional abort signal\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\n     */\n    async _register({ friendlyName, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new errors_1.AuthError('rpId is required for WebAuthn registration'),\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\n                };\n            }\n            // Enroll factor\n            const { data: factor, error: enrollError } = await this._enroll({\n                friendlyName,\n            });\n            if (!factor) {\n                await this.client.mfa\n                    .listFactors()\n                    .then((factors) => {\n                    var _a;\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v) => v.factor_type === 'webauthn' &&\n                        v.friendly_name === friendlyName &&\n                        v.status !== 'unverified');\n                })\n                    .then((factor) => (factor ? this.client.mfa.unenroll({ factorId: factor === null || factor === void 0 ? void 0 : factor.id }) : void 0));\n                return { data: null, error: enrollError };\n            }\n            // Get challenge and create credential\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\n                factorId: factor.id,\n                friendlyName: factor.friendly_name,\n                webauthn: { rpId, rpOrigins },\n                signal,\n            }, {\n                create: overrides,\n            });\n            if (!challengeResponse) {\n                return { data: null, error: challengeError };\n            }\n            return this._verify({\n                factorId: factor.id,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    rpId,\n                    rpOrigins,\n                    type: challengeResponse.webauthn.type,\n                    credential_response: challengeResponse.webauthn.credential_response,\n                },\n            });\n        }\n        catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            return {\n                data: null,\n                error: new errors_1.AuthUnknownError('Unexpected error in register', error),\n            };\n        }\n    }\n}\nexports.WebAuthnApi = WebAuthnApi;\n//# sourceMappingURL=webauthn.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$tslib$tslib","~$shadow.js","~$module$node_modules$$supabase$auth_js$dist$main$lib$base64url","~$module$node_modules$$supabase$auth_js$dist$main$lib$errors","~$module$node_modules$$supabase$auth_js$dist$main$lib$helpers","~$module$node_modules$$supabase$auth_js$dist$main$lib$webauthn_errors"]],"~:properties",["^5",["clientDataJSON","rawId","allowCredentials","authenticate","webAuthnAbortService","attestation","deserializeCredentialCreationOptions","deserializeCredentialRequestOptions","userVerification","userHandle","displayName","clientExtensionResults","user","__esModule","excludeCredentials","challengeId","serializeCredentialCreationResponse","error","rpId","createCredential","id","publicKey","getCredential","signal","factorType","name","challenge","WebAuthnAbortService","transports","value","verify","hints","authenticatorAttachment","enumerable","friendlyName","attestationObject","request","rpOrigins","identifyRegistrationError","authenticatorSelection","authenticatorData","signature","requireResidentKey","register","DEFAULT_REQUEST_OPTIONS","type","isWebAuthnError","serializeCredentialRequestResponse","enroll","mergeCredentialRequestOptions","credential_response","identifyAuthenticationError","create","factorId","response","mergeCredentialCreationOptions","webauthn","WebAuthnError","DEFAULT_CREATION_OPTIONS","client","options","data","get","WebAuthnApi","residentKey","controller","isValidDomain"]],"~:compiled-at",1771991938852,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$auth_js$dist$main$lib$webauthn.js\",\n\"lineCount\":20,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/auth-js/dist/main/lib/webauthn.js\"],\n\"sourcesContent\":[\"shadow$provide[49] = function(require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.WebAuthnApi = exports.DEFAULT_REQUEST_OPTIONS = exports.DEFAULT_CREATION_OPTIONS = exports.webAuthnAbortService = exports.WebAuthnAbortService = exports.identifyAuthenticationError = exports.identifyRegistrationError = exports.isWebAuthnError = exports.WebAuthnError = void 0;\\nexports.deserializeCredentialCreationOptions = deserializeCredentialCreationOptions;\\nexports.deserializeCredentialRequestOptions = deserializeCredentialRequestOptions;\\nexports.serializeCredentialCreationResponse = serializeCredentialCreationResponse;\\nexports.serializeCredentialRequestResponse = serializeCredentialRequestResponse;\\nexports.isValidDomain = isValidDomain;\\nexports.createCredential = createCredential;\\nexports.getCredential = getCredential;\\nexports.mergeCredentialCreationOptions = mergeCredentialCreationOptions;\\nexports.mergeCredentialRequestOptions = mergeCredentialRequestOptions;\\nconst tslib_1 = require(\\\"tslib\\\");\\nconst base64url_1 = require(\\\"./base64url\\\");\\nconst errors_1 = require(\\\"./errors\\\");\\nconst helpers_1 = require(\\\"./helpers\\\");\\nconst webauthn_errors_1 = require(\\\"./webauthn.errors\\\");\\nObject.defineProperty(exports, \\\"identifyAuthenticationError\\\", { enumerable: true, get: function () { return webauthn_errors_1.identifyAuthenticationError; } });\\nObject.defineProperty(exports, \\\"identifyRegistrationError\\\", { enumerable: true, get: function () { return webauthn_errors_1.identifyRegistrationError; } });\\nObject.defineProperty(exports, \\\"isWebAuthnError\\\", { enumerable: true, get: function () { return webauthn_errors_1.isWebAuthnError; } });\\nObject.defineProperty(exports, \\\"WebAuthnError\\\", { enumerable: true, get: function () { return webauthn_errors_1.WebAuthnError; } });\\n/**\\n * WebAuthn abort service to manage ceremony cancellation.\\n * Ensures only one WebAuthn ceremony is active at a time to prevent \\\"operation already in progress\\\" errors.\\n *\\n * @experimental This class is experimental and may change in future releases\\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\\n */\\nclass WebAuthnAbortService {\\n    /**\\n     * Create an abort signal for a new WebAuthn operation.\\n     * Automatically cancels any existing operation.\\n     *\\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\\n     */\\n    createNewAbortSignal() {\\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\\n        if (this.controller) {\\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\\n            abortError.name = 'AbortError';\\n            this.controller.abort(abortError);\\n        }\\n        const newController = new AbortController();\\n        this.controller = newController;\\n        return newController.signal;\\n    }\\n    /**\\n     * Manually cancel the current WebAuthn operation.\\n     * Useful for cleaning up when user cancels or navigates away.\\n     *\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\\n     */\\n    cancelCeremony() {\\n        if (this.controller) {\\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\\n            abortError.name = 'AbortError';\\n            this.controller.abort(abortError);\\n            this.controller = undefined;\\n        }\\n    }\\n}\\nexports.WebAuthnAbortService = WebAuthnAbortService;\\n/**\\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\\n * This prevents \\\"operation already in progress\\\" errors when retrying WebAuthn operations.\\n *\\n * @experimental This instance is experimental and may change in future releases\\n */\\nexports.webAuthnAbortService = new WebAuthnAbortService();\\n/**\\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\\n * as required by the WebAuthn browser API.\\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\\n *\\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\\n */\\nfunction deserializeCredentialCreationOptions(options) {\\n    if (!options) {\\n        throw new Error('Credential creation options are required');\\n    }\\n    // Check if the native parseCreationOptionsFromJSON method is available\\n    if (typeof PublicKeyCredential !== 'undefined' &&\\n        'parseCreationOptionsFromJSON' in PublicKeyCredential &&\\n        typeof PublicKeyCredential\\n            .parseCreationOptionsFromJSON === 'function') {\\n        // Use the native WebAuthn Level 3 method\\n        return PublicKeyCredential.parseCreationOptionsFromJSON(\\n        /** we assert the options here as typescript still doesn't know about future webauthn types */\\n        options);\\n    }\\n    // Fallback to manual parsing for browsers that don't support the native method\\n    // Destructure to separate fields that need transformation\\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = tslib_1.__rest(options\\n    // Convert challenge from base64url to ArrayBuffer\\n    , [\\\"challenge\\\", \\\"user\\\", \\\"excludeCredentials\\\"]);\\n    // Convert challenge from base64url to ArrayBuffer\\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\\n    // Convert user.id from base64url to ArrayBuffer\\n    const user = Object.assign(Object.assign({}, userOpts), { id: (0, base64url_1.base64UrlToUint8Array)(userOpts.id).buffer });\\n    // Build the result object\\n    const result = Object.assign(Object.assign({}, restOptions), { challenge,\\n        user });\\n    // Only add excludeCredentials if it exists\\n    if (excludeCredentials && excludeCredentials.length > 0) {\\n        result.excludeCredentials = new Array(excludeCredentials.length);\\n        for (let i = 0; i < excludeCredentials.length; i++) {\\n            const cred = excludeCredentials[i];\\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \\n                // Cast transports to handle future transport types like \\\"cable\\\"\\n                transports: cred.transports });\\n        }\\n    }\\n    return result;\\n}\\n/**\\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\\n * as required by the WebAuthn browser API.\\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\\n *\\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\\n */\\nfunction deserializeCredentialRequestOptions(options) {\\n    if (!options) {\\n        throw new Error('Credential request options are required');\\n    }\\n    // Check if the native parseRequestOptionsFromJSON method is available\\n    if (typeof PublicKeyCredential !== 'undefined' &&\\n        'parseRequestOptionsFromJSON' in PublicKeyCredential &&\\n        typeof PublicKeyCredential\\n            .parseRequestOptionsFromJSON === 'function') {\\n        // Use the native WebAuthn Level 3 method\\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\\n    }\\n    // Fallback to manual parsing for browsers that don't support the native method\\n    // Destructure to separate fields that need transformation\\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = tslib_1.__rest(options\\n    // Convert challenge from base64url to ArrayBuffer\\n    , [\\\"challenge\\\", \\\"allowCredentials\\\"]);\\n    // Convert challenge from base64url to ArrayBuffer\\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\\n    // Build the result object\\n    const result = Object.assign(Object.assign({}, restOptions), { challenge });\\n    // Only add allowCredentials if it exists\\n    if (allowCredentials && allowCredentials.length > 0) {\\n        result.allowCredentials = new Array(allowCredentials.length);\\n        for (let i = 0; i < allowCredentials.length; i++) {\\n            const cred = allowCredentials[i];\\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \\n                // Cast transports to handle future transport types like \\\"cable\\\"\\n                transports: cred.transports });\\n        }\\n    }\\n    return result;\\n}\\n/**\\n * Convert a registration/enrollment credential response to server format.\\n * Serializes binary fields to base64url for JSON transmission.\\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\\n *\\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\\n */\\nfunction serializeCredentialCreationResponse(credential) {\\n    var _a;\\n    // Check if the credential instance has the toJSON method\\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\\n        // Use the native WebAuthn Level 3 method\\n        return credential.toJSON();\\n    }\\n    const credentialWithAttachment = credential;\\n    return {\\n        id: credential.id,\\n        rawId: credential.id,\\n        response: {\\n            attestationObject: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON)),\\n        },\\n        type: 'public-key',\\n        clientExtensionResults: credential.getClientExtensionResults(),\\n        // Convert null to undefined and cast to AuthenticatorAttachment type\\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\\n    };\\n}\\n/**\\n * Convert an authentication/verification credential response to server format.\\n * Serializes binary fields to base64url for JSON transmission.\\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\\n *\\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\\n */\\nfunction serializeCredentialRequestResponse(credential) {\\n    var _a;\\n    // Check if the credential instance has the toJSON method\\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\\n        // Use the native WebAuthn Level 3 method\\n        return credential.toJSON();\\n    }\\n    // Fallback to manual conversion for browsers that don't support toJSON\\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\\n    const credentialWithAttachment = credential;\\n    const clientExtensionResults = credential.getClientExtensionResults();\\n    const assertionResponse = credential.response;\\n    return {\\n        id: credential.id,\\n        rawId: credential.id, // W3C spec expects rawId to match id for JSON format\\n        response: {\\n            authenticatorData: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\\n            signature: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\\n            userHandle: assertionResponse.userHandle\\n                ? (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle))\\n                : undefined,\\n        },\\n        type: 'public-key',\\n        clientExtensionResults,\\n        // Convert null to undefined and cast to AuthenticatorAttachment type\\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\\n    };\\n}\\n/**\\n * A simple test to determine if a hostname is a properly-formatted domain name.\\n * Considers localhost valid for development environments.\\n *\\n * A \\\"valid domain\\\" is defined here: https://url.spec.whatwg.org/#valid-domain\\n *\\n * Regex sourced from here:\\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\\n *\\n * @param {string} hostname - The hostname to validate\\n * @returns {boolean} True if valid domain or localhost\\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\\n */\\nfunction isValidDomain(hostname) {\\n    return (\\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\\\.)+[a-z]{2,}$/i.test(hostname));\\n}\\n/**\\n * Determine if the browser is capable of WebAuthn.\\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\\n *\\n * @returns {boolean} True if browser supports WebAuthn\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\\n */\\nfunction browserSupportsWebAuthn() {\\n    var _a, _b;\\n    return !!((0, helpers_1.isBrowser)() &&\\n        'PublicKeyCredential' in window &&\\n        window.PublicKeyCredential &&\\n        'credentials' in navigator &&\\n        typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' &&\\n        typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');\\n}\\n/**\\n * Create a WebAuthn credential using the browser's credentials API.\\n * Wraps navigator.credentials.create() with error handling.\\n *\\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\\n */\\nasync function createCredential(options) {\\n    try {\\n        const response = await navigator.credentials.create(\\n        /** we assert the type here until typescript types are updated */\\n        options);\\n        if (!response) {\\n            return {\\n                data: null,\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\\n            };\\n        }\\n        if (!(response instanceof PublicKeyCredential)) {\\n            return {\\n                data: null,\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\\n            };\\n        }\\n        return { data: response, error: null };\\n    }\\n    catch (err) {\\n        return {\\n            data: null,\\n            error: (0, webauthn_errors_1.identifyRegistrationError)({\\n                error: err,\\n                options,\\n            }),\\n        };\\n    }\\n}\\n/**\\n * Get a WebAuthn credential using the browser's credentials API.\\n * Wraps navigator.credentials.get() with error handling.\\n *\\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\\n */\\nasync function getCredential(options) {\\n    try {\\n        const response = await navigator.credentials.get(\\n        /** we assert the type here until typescript types are updated */\\n        options);\\n        if (!response) {\\n            return {\\n                data: null,\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\\n            };\\n        }\\n        if (!(response instanceof PublicKeyCredential)) {\\n            return {\\n                data: null,\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\\n            };\\n        }\\n        return { data: response, error: null };\\n    }\\n    catch (err) {\\n        return {\\n            data: null,\\n            error: (0, webauthn_errors_1.identifyAuthenticationError)({\\n                error: err,\\n                options,\\n            }),\\n        };\\n    }\\n}\\nexports.DEFAULT_CREATION_OPTIONS = {\\n    hints: ['security-key'],\\n    authenticatorSelection: {\\n        authenticatorAttachment: 'cross-platform',\\n        requireResidentKey: false,\\n        /** set to preferred because older yubikeys don't have PIN/Biometric */\\n        userVerification: 'preferred',\\n        residentKey: 'discouraged',\\n    },\\n    attestation: 'direct',\\n};\\nexports.DEFAULT_REQUEST_OPTIONS = {\\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\\n    userVerification: 'preferred',\\n    hints: ['security-key'],\\n    attestation: 'direct',\\n};\\nfunction deepMerge(...sources) {\\n    const isObject = (val) => val !== null && typeof val === 'object' && !Array.isArray(val);\\n    const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);\\n    const result = {};\\n    for (const source of sources) {\\n        if (!source)\\n            continue;\\n        for (const key in source) {\\n            const value = source[key];\\n            if (value === undefined)\\n                continue;\\n            if (Array.isArray(value)) {\\n                // preserve array reference, including unions like AuthenticatorTransport[]\\n                result[key] = value;\\n            }\\n            else if (isArrayBufferLike(value)) {\\n                result[key] = value;\\n            }\\n            else if (isObject(value)) {\\n                const existing = result[key];\\n                if (isObject(existing)) {\\n                    result[key] = deepMerge(existing, value);\\n                }\\n                else {\\n                    result[key] = deepMerge(value);\\n                }\\n            }\\n            else {\\n                result[key] = value;\\n            }\\n        }\\n    }\\n    return result;\\n}\\n/**\\n * Merges WebAuthn credential creation options with overrides.\\n * Sets sensible defaults for authenticator selection and extensions.\\n *\\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\\n * @param {string} friendlyName - Optional friendly name for the credential\\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\\n */\\nfunction mergeCredentialCreationOptions(baseOptions, overrides) {\\n    return deepMerge(exports.DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\\n}\\n/**\\n * Merges WebAuthn credential request options with overrides.\\n * Sets sensible defaults for user verification and hints.\\n *\\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\\n */\\nfunction mergeCredentialRequestOptions(baseOptions, overrides) {\\n    return deepMerge(exports.DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\\n}\\n/**\\n * WebAuthn API wrapper for Supabase Auth.\\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\\n *\\n * @experimental This API is experimental and may change in future releases\\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\\n */\\nclass WebAuthnApi {\\n    constructor(client) {\\n        this.client = client;\\n        // Bind all methods so they can be destructured\\n        this.enroll = this._enroll.bind(this);\\n        this.challenge = this._challenge.bind(this);\\n        this.verify = this._verify.bind(this);\\n        this.authenticate = this._authenticate.bind(this);\\n        this.register = this._register.bind(this);\\n    }\\n    /**\\n     * Enroll a new WebAuthn factor.\\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\\n     *\\n     * @experimental This method is experimental and may change in future releases\\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\\n     */\\n    async _enroll(params) {\\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: 'webauthn' }));\\n    }\\n    /**\\n     * Challenge for WebAuthn credential creation or authentication.\\n     * Combines server challenge with browser credential operations.\\n     * Handles both registration (create) and authentication (request) flows.\\n     *\\n     * @experimental This method is experimental and may change in future releases\\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\\n     */\\n    async _challenge({ factorId, webauthn, friendlyName, signal, }, overrides) {\\n        var _a;\\n        try {\\n            // Get challenge from server using the client's MFA methods\\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\\n                factorId,\\n                webauthn,\\n            });\\n            if (!challengeResponse) {\\n                return { data: null, error: challengeError };\\n            }\\n            const abortSignal = signal !== null && signal !== void 0 ? signal : exports.webAuthnAbortService.createNewAbortSignal();\\n            /** webauthn will fail if either of the name/displayname are blank */\\n            if (challengeResponse.webauthn.type === 'create') {\\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\\n                if (!user.name) {\\n                    // Preserve original format: use friendlyName if provided, otherwise fetch fallback\\n                    // This maintains backward compatibility with the ${user.id}:${name} format\\n                    const nameToUse = friendlyName;\\n                    if (!nameToUse) {\\n                        // Only fetch user data if friendlyName is not provided (bug fix for null friendlyName)\\n                        const currentUser = await this.client.getUser();\\n                        const userData = currentUser.data.user;\\n                        const fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || 'User';\\n                        user.name = `${user.id}:${fallbackName}`;\\n                    }\\n                    else {\\n                        user.name = `${user.id}:${nameToUse}`;\\n                    }\\n                }\\n                if (!user.displayName) {\\n                    user.displayName = user.name;\\n                }\\n            }\\n            switch (challengeResponse.webauthn.type) {\\n                case 'create': {\\n                    const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\\n                    const { data, error } = await createCredential({\\n                        publicKey: options,\\n                        signal: abortSignal,\\n                    });\\n                    if (data) {\\n                        return {\\n                            data: {\\n                                factorId,\\n                                challengeId: challengeResponse.id,\\n                                webauthn: {\\n                                    type: challengeResponse.webauthn.type,\\n                                    credential_response: data,\\n                                },\\n                            },\\n                            error: null,\\n                        };\\n                    }\\n                    return { data: null, error };\\n                }\\n                case 'request': {\\n                    const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\\n                    const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));\\n                    if (data) {\\n                        return {\\n                            data: {\\n                                factorId,\\n                                challengeId: challengeResponse.id,\\n                                webauthn: {\\n                                    type: challengeResponse.webauthn.type,\\n                                    credential_response: data,\\n                                },\\n                            },\\n                            error: null,\\n                        };\\n                    }\\n                    return { data: null, error };\\n                }\\n            }\\n        }\\n        catch (error) {\\n            if ((0, errors_1.isAuthError)(error)) {\\n                return { data: null, error };\\n            }\\n            return {\\n                data: null,\\n                error: new errors_1.AuthUnknownError('Unexpected error in challenge', error),\\n            };\\n        }\\n    }\\n    /**\\n     * Verify a WebAuthn credential with the server.\\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\\n     *\\n     * @experimental This method is experimental and may change in future releases\\n     * @param {Object} params - Verification parameters\\n     * @param {string} params.challengeId - ID of the challenge being verified\\n     * @param {string} params.factorId - ID of the WebAuthn factor\\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\\n     * */\\n    async _verify({ challengeId, factorId, webauthn, }) {\\n        return this.client.mfa.verify({\\n            factorId,\\n            challengeId,\\n            webauthn: webauthn,\\n        });\\n    }\\n    /**\\n     * Complete WebAuthn authentication flow.\\n     * Performs challenge and verification in a single operation for existing credentials.\\n     *\\n     * @experimental This method is experimental and may change in future releases\\n     * @param {Object} params - Authentication parameters\\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\\n     * @param {Object} params.webauthn - WebAuthn configuration\\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\\n     */\\n    async _authenticate({ factorId, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\\n        if (!rpId) {\\n            return {\\n                data: null,\\n                error: new errors_1.AuthError('rpId is required for WebAuthn authentication'),\\n            };\\n        }\\n        try {\\n            if (!browserSupportsWebAuthn()) {\\n                return {\\n                    data: null,\\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\\n                };\\n            }\\n            // Get challenge and credential\\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\\n                factorId,\\n                webauthn: { rpId, rpOrigins },\\n                signal,\\n            }, { request: overrides });\\n            if (!challengeResponse) {\\n                return { data: null, error: challengeError };\\n            }\\n            const { webauthn } = challengeResponse;\\n            // Verify credential\\n            return this._verify({\\n                factorId,\\n                challengeId: challengeResponse.challengeId,\\n                webauthn: {\\n                    type: webauthn.type,\\n                    rpId,\\n                    rpOrigins,\\n                    credential_response: webauthn.credential_response,\\n                },\\n            });\\n        }\\n        catch (error) {\\n            if ((0, errors_1.isAuthError)(error)) {\\n                return { data: null, error };\\n            }\\n            return {\\n                data: null,\\n                error: new errors_1.AuthUnknownError('Unexpected error in authenticate', error),\\n            };\\n        }\\n    }\\n    /**\\n     * Complete WebAuthn registration flow.\\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\\n     *\\n     * @experimental This method is experimental and may change in future releases\\n     * @param {Object} params - Registration parameters\\n     * @param {string} params.friendlyName - User-friendly name for the credential\\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\\n     * @param {AbortSignal} params.signal - Optional abort signal\\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\\n     */\\n    async _register({ friendlyName, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\\n        if (!rpId) {\\n            return {\\n                data: null,\\n                error: new errors_1.AuthError('rpId is required for WebAuthn registration'),\\n            };\\n        }\\n        try {\\n            if (!browserSupportsWebAuthn()) {\\n                return {\\n                    data: null,\\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\\n                };\\n            }\\n            // Enroll factor\\n            const { data: factor, error: enrollError } = await this._enroll({\\n                friendlyName,\\n            });\\n            if (!factor) {\\n                await this.client.mfa\\n                    .listFactors()\\n                    .then((factors) => {\\n                    var _a;\\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v) => v.factor_type === 'webauthn' &&\\n                        v.friendly_name === friendlyName &&\\n                        v.status !== 'unverified');\\n                })\\n                    .then((factor) => (factor ? this.client.mfa.unenroll({ factorId: factor === null || factor === void 0 ? void 0 : factor.id }) : void 0));\\n                return { data: null, error: enrollError };\\n            }\\n            // Get challenge and create credential\\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\\n                factorId: factor.id,\\n                friendlyName: factor.friendly_name,\\n                webauthn: { rpId, rpOrigins },\\n                signal,\\n            }, {\\n                create: overrides,\\n            });\\n            if (!challengeResponse) {\\n                return { data: null, error: challengeError };\\n            }\\n            return this._verify({\\n                factorId: factor.id,\\n                challengeId: challengeResponse.challengeId,\\n                webauthn: {\\n                    rpId,\\n                    rpOrigins,\\n                    type: challengeResponse.webauthn.type,\\n                    credential_response: challengeResponse.webauthn.credential_response,\\n                },\\n            });\\n        }\\n        catch (error) {\\n            if ((0, errors_1.isAuthError)(error)) {\\n                return { data: null, error };\\n            }\\n            return {\\n                data: null,\\n                error: new errors_1.AuthUnknownError('Unexpected error in register', error),\\n            };\\n        }\\n    }\\n}\\nexports.WebAuthnApi = WebAuthnApi;\\n//# sourceMappingURL=webauthn.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"browserSupportsWebAuthn\",\"_a\",\"_b\",\"helpers_1\",\"isBrowser\",\"window\",\"PublicKeyCredential\",\"navigator\",\"credentials\",\"create\",\"get\",\"createCredential\",\"options\",\"response\",\"data\",\"error\",\"webauthn_errors_1\",\"WebAuthnUnknownError\",\"err\",\"identifyRegistrationError\",\"getCredential\",\"identifyAuthenticationError\",\"deepMerge\",\"sources\",\"result\",\"source\",\"key\",\"value\",\"undefined\",\"Array\",\"isArray\",\"ArrayBuffer\",\"isView\",\"existing\",\"mergeCredentialCreationOptions\",\"baseOptions\",\"overrides\",\"DEFAULT_CREATION_OPTIONS\",\"mergeCredentialRequestOptions\",\"DEFAULT_REQUEST_OPTIONS\",\"Object\",\"defineProperty\",\"WebAuthnApi\",\"webAuthnAbortService\",\"WebAuthnAbortService\",\"isWebAuthnError\",\"WebAuthnError\",\"deserializeCredentialCreationOptions\",\"Error\",\"parseCreationOptionsFromJSON\",\"challengeStr\",\"userOpts\",\"excludeCredentials\",\"restOptions\",\"tslib_1\",\"__rest\",\"challenge\",\"base64url_1\",\"base64UrlToUint8Array\",\"buffer\",\"user\",\"assign\",\"id\",\"length\",\"i\",\"cred\",\"type\",\"transports\",\"deserializeCredentialRequestOptions\",\"parseRequestOptionsFromJSON\",\"allowCredentials\",\"serializeCredentialCreationResponse\",\"credential\",\"toJSON\",\"rawId\",\"attestationObject\",\"bytesToBase64URL\",\"Uint8Array\",\"clientDataJSON\",\"clientExtensionResults\",\"getClientExtensionResults\",\"authenticatorAttachment\",\"serializeCredentialRequestResponse\",\"assertionResponse\",\"authenticatorData\",\"signature\",\"userHandle\",\"isValidDomain\",\"hostname\",\"test\",\"errors_1\",\"enumerable\",\"createNewAbortSignal\",\"controller\",\"abortError\",\"name\",\"abort\",\"newController\",\"AbortController\",\"signal\",\"cancelCeremony\",\"hints\",\"authenticatorSelection\",\"requireResidentKey\",\"userVerification\",\"residentKey\",\"attestation\",\"constructor\",\"client\",\"enroll\",\"_enroll\",\"bind\",\"_challenge\",\"verify\",\"_verify\",\"authenticate\",\"_authenticate\",\"register\",\"_register\",\"params\",\"mfa\",\"factorType\",\"factorId\",\"webauthn\",\"friendlyName\",\"challengeResponse\",\"challengeError\",\"abortSignal\",\"credential_options\",\"publicKey\",\"userData\",\"currentUser\",\"getUser\",\"fallbackName\",\"user_metadata\",\"email\",\"displayName\",\"challengeId\",\"credential_response\",\"request\",\"isAuthError\",\"AuthUnknownError\",\"rpId\",\"location\",\"rpOrigins\",\"origin\",\"AuthError\",\"factor\",\"enrollError\",\"listFactors\",\"then\",\"factors\",\"all\",\"find\",\"v\",\"factor_type\",\"friendly_name\",\"status\",\"unenroll\"]\n}\n"]