["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/auth-js/dist/main/lib/webauthn.js"],"~:js","shadow$provide[49]=function(S,ka,a){function I(){var z,J;return!!((0,p.isBrowser)()&&\"PublicKeyCredential\"in window&&window.PublicKeyCredential&&\"credentials\"in navigator&&typeof((z=navigator===null||navigator===void 0?void 0:navigator.credentials)===null||z===void 0?void 0:z.create)===\"function\"&&typeof((J=navigator===null||navigator===void 0?void 0:navigator.credentials)===null||J===void 0?void 0:J.get)===\"function\")}async function q(z){try{const J=await navigator.credentials.create(z);return J?\nJ instanceof PublicKeyCredential?{data:J,error:null}:{data:null,error:new k.WebAuthnUnknownError(\"Browser returned unexpected credential type\",J)}:{data:null,error:new k.WebAuthnUnknownError(\"Empty credential response\",J)}}catch(J){return{data:null,error:(0,k.identifyRegistrationError)({error:J,options:z})}}}async function D(z){try{const J=await navigator.credentials.get(z);return J?J instanceof PublicKeyCredential?{data:J,error:null}:{data:null,error:new k.WebAuthnUnknownError(\"Browser returned unexpected credential type\",\nJ)}:{data:null,error:new k.WebAuthnUnknownError(\"Empty credential response\",J)}}catch(J){return{data:null,error:(0,k.identifyAuthenticationError)({error:J,options:z})}}}function C(...z){const J={};for(const l of z)if(l)for(const t in l)if(z=l[t],z!==void 0)if(Array.isArray(z))J[t]=z;else if(z instanceof ArrayBuffer||ArrayBuffer.isView(z))J[t]=z;else if(z===null||typeof z!==\"object\"||Array.isArray(z))J[t]=z;else{const x=J[t];x===null||typeof x!==\"object\"||Array.isArray(x)?J[t]=C(z):J[t]=C(x,z)}return J}\nfunction G(z,J){return C(a.DEFAULT_CREATION_OPTIONS,z,J||{})}function E(z,J){return C(a.DEFAULT_REQUEST_OPTIONS,z,J||{})}Object.defineProperty(a,\"__esModule\",{value:!0});a.WebAuthnApi=a.DEFAULT_REQUEST_OPTIONS=a.DEFAULT_CREATION_OPTIONS=a.webAuthnAbortService=a.WebAuthnAbortService=a.identifyAuthenticationError=a.identifyRegistrationError=a.isWebAuthnError=a.WebAuthnError=void 0;a.deserializeCredentialCreationOptions=function(z){if(!z)throw Error(\"Credential creation options are required\");if(typeof PublicKeyCredential!==\n\"undefined\"&&\"parseCreationOptionsFromJSON\"in PublicKeyCredential&&typeof PublicKeyCredential.parseCreationOptionsFromJSON===\"function\")return PublicKeyCredential.parseCreationOptionsFromJSON(z);const {challenge:J,user:l,excludeCredentials:t}=z;z=M.__rest(z,[\"challenge\",\"user\",\"excludeCredentials\"]);var x=(0,d.base64UrlToUint8Array)(J).buffer,w=Object.assign(Object.assign({},l),{id:(0,d.base64UrlToUint8Array)(l.id).buffer});z=Object.assign(Object.assign({},z),{challenge:x,user:w});if(t&&t.length>\n0)for(z.excludeCredentials=Array(t.length),x=0;x<t.length;x++)w=t[x],z.excludeCredentials[x]=Object.assign(Object.assign({},w),{id:(0,d.base64UrlToUint8Array)(w.id).buffer,type:w.type||\"public-key\",transports:w.transports});return z};a.deserializeCredentialRequestOptions=function(z){if(!z)throw Error(\"Credential request options are required\");if(typeof PublicKeyCredential!==\"undefined\"&&\"parseRequestOptionsFromJSON\"in PublicKeyCredential&&typeof PublicKeyCredential.parseRequestOptionsFromJSON===\"function\")return PublicKeyCredential.parseRequestOptionsFromJSON(z);\nconst {challenge:J,allowCredentials:l}=z;z=M.__rest(z,[\"challenge\",\"allowCredentials\"]);var t=(0,d.base64UrlToUint8Array)(J).buffer;z=Object.assign(Object.assign({},z),{challenge:t});if(l&&l.length>0)for(z.allowCredentials=Array(l.length),t=0;t<l.length;t++){const x=l[t];z.allowCredentials[t]=Object.assign(Object.assign({},x),{id:(0,d.base64UrlToUint8Array)(x.id).buffer,type:x.type||\"public-key\",transports:x.transports})}return z};a.serializeCredentialCreationResponse=function(z){var J;return\"toJSON\"in\nz&&typeof z.toJSON===\"function\"?z.toJSON():{id:z.id,rawId:z.id,response:{attestationObject:(0,d.bytesToBase64URL)(new Uint8Array(z.response.attestationObject)),clientDataJSON:(0,d.bytesToBase64URL)(new Uint8Array(z.response.clientDataJSON))},type:\"public-key\",clientExtensionResults:z.getClientExtensionResults(),authenticatorAttachment:(J=z.authenticatorAttachment)!==null&&J!==void 0?J:void 0}};a.serializeCredentialRequestResponse=function(z){var J;if(\"toJSON\"in z&&typeof z.toJSON===\"function\")return z.toJSON();\nconst l=z.getClientExtensionResults(),t=z.response;return{id:z.id,rawId:z.id,response:{authenticatorData:(0,d.bytesToBase64URL)(new Uint8Array(t.authenticatorData)),clientDataJSON:(0,d.bytesToBase64URL)(new Uint8Array(t.clientDataJSON)),signature:(0,d.bytesToBase64URL)(new Uint8Array(t.signature)),userHandle:t.userHandle?(0,d.bytesToBase64URL)(new Uint8Array(t.userHandle)):void 0},type:\"public-key\",clientExtensionResults:l,authenticatorAttachment:(J=z.authenticatorAttachment)!==null&&J!==void 0?J:\nvoid 0}};a.isValidDomain=function(z){return z===\"localhost\"||/^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(z)};a.createCredential=q;a.getCredential=D;a.mergeCredentialCreationOptions=G;a.mergeCredentialRequestOptions=E;const M=S(14),d=S(39),K=S(38),p=S(40),k=S(48);Object.defineProperty(a,\"identifyAuthenticationError\",{enumerable:!0,get:function(){return k.identifyAuthenticationError}});Object.defineProperty(a,\"identifyRegistrationError\",{enumerable:!0,get:function(){return k.identifyRegistrationError}});\nObject.defineProperty(a,\"isWebAuthnError\",{enumerable:!0,get:function(){return k.isWebAuthnError}});Object.defineProperty(a,\"WebAuthnError\",{enumerable:!0,get:function(){return k.WebAuthnError}});class y{createNewAbortSignal(){if(this.controller){var z=Error(\"Cancelling existing WebAuthn API call for new one\");z.name=\"AbortError\";this.controller.abort(z)}this.controller=z=new AbortController;return z.signal}cancelCeremony(){if(this.controller){const z=Error(\"Manually cancelling existing WebAuthn API call\");\nz.name=\"AbortError\";this.controller.abort(z);this.controller=void 0}}}a.WebAuthnAbortService=y;a.webAuthnAbortService=new y;a.DEFAULT_CREATION_OPTIONS={hints:[\"security-key\"],authenticatorSelection:{authenticatorAttachment:\"cross-platform\",requireResidentKey:!1,userVerification:\"preferred\",residentKey:\"discouraged\"},attestation:\"direct\"};a.DEFAULT_REQUEST_OPTIONS={userVerification:\"preferred\",hints:[\"security-key\"],attestation:\"direct\"};class v{constructor(z){this.client=z;this.enroll=this._enroll.bind(this);\nthis.challenge=this._challenge.bind(this);this.verify=this._verify.bind(this);this.authenticate=this._authenticate.bind(this);this.register=this._register.bind(this)}async _enroll(z){return this.client.mfa.enroll(Object.assign(Object.assign({},z),{factorType:\"webauthn\"}))}async _challenge({factorId:z,webauthn:J,friendlyName:l,signal:t},x){var w;try{const {data:A,error:L}=await this.client.mfa.challenge({factorId:z,webauthn:J});if(!A)return{data:null,error:L};const P=t!==null&&t!==void 0?t:a.webAuthnAbortService.createNewAbortSignal();\nif(A.webauthn.type===\"create\"){const {user:T}=A.webauthn.credential_options.publicKey;if(!T.name)if(l)T.name=`${T.id}:${l}`;else{const Y=(await this.client.getUser()).data.user,ha=((w=Y===null||Y===void 0?void 0:Y.user_metadata)===null||w===void 0?void 0:w.name)||(Y===null||Y===void 0?void 0:Y.email)||(Y===null||Y===void 0?void 0:Y.id)||\"User\";T.name=`${T.id}:${ha}`}T.displayName||(T.displayName=T.name)}switch(A.webauthn.type){case \"create\":const T=G(A.webauthn.credential_options.publicKey,x===null||\nx===void 0?void 0:x.create),{data:Y,error:ha}=await q({publicKey:T,signal:P});return Y?{data:{factorId:z,challengeId:A.id,webauthn:{type:A.webauthn.type,credential_response:Y}},error:null}:{data:null,error:ha};case \"request\":const da=E(A.webauthn.credential_options.publicKey,x===null||x===void 0?void 0:x.request),{data:fa,error:ja}=await D(Object.assign(Object.assign({},A.webauthn.credential_options),{publicKey:da,signal:P}));return fa?{data:{factorId:z,challengeId:A.id,webauthn:{type:A.webauthn.type,\ncredential_response:fa}},error:null}:{data:null,error:ja}}}catch(A){return(0,K.isAuthError)(A)?{data:null,error:A}:{data:null,error:new K.AuthUnknownError(\"Unexpected error in challenge\",A)}}}async _verify({challengeId:z,factorId:J,webauthn:l}){return this.client.mfa.verify({factorId:J,challengeId:z,webauthn:l})}async _authenticate({factorId:z,webauthn:{rpId:J=typeof window!==\"undefined\"?window.location.hostname:void 0,rpOrigins:l=typeof window!==\"undefined\"?[window.location.origin]:void 0,signal:t}=\n{}},x){if(!J)return{data:null,error:new K.AuthError(\"rpId is required for WebAuthn authentication\")};try{if(!I())return{data:null,error:new K.AuthUnknownError(\"Browser does not support WebAuthn\",null)};const {data:w,error:A}=await this.challenge({factorId:z,webauthn:{rpId:J,rpOrigins:l},signal:t},{request:x});if(!w)return{data:null,error:A};({webauthn:t}=w);return this._verify({factorId:z,challengeId:w.challengeId,webauthn:{type:t.type,rpId:J,rpOrigins:l,credential_response:t.credential_response}})}catch(w){return(0,K.isAuthError)(w)?\n{data:null,error:w}:{data:null,error:new K.AuthUnknownError(\"Unexpected error in authenticate\",w)}}}async _register({friendlyName:z,webauthn:{rpId:J=typeof window!==\"undefined\"?window.location.hostname:void 0,rpOrigins:l=typeof window!==\"undefined\"?[window.location.origin]:void 0,signal:t}={}},x){if(!J)return{data:null,error:new K.AuthError(\"rpId is required for WebAuthn registration\")};try{if(!I())return{data:null,error:new K.AuthUnknownError(\"Browser does not support WebAuthn\",null)};const {data:w,\nerror:A}=await this._enroll({friendlyName:z});if(!w)return await this.client.mfa.listFactors().then(T=>{var Y;return(Y=T.data)===null||Y===void 0?void 0:Y.all.find(ha=>ha.factor_type===\"webauthn\"&&ha.friendly_name===z&&ha.status!==\"unverified\")}).then(T=>T?this.client.mfa.unenroll({factorId:T===null||T===void 0?void 0:T.id}):void 0),{data:null,error:A};const {data:L,error:P}=await this._challenge({factorId:w.id,friendlyName:w.friendly_name,webauthn:{rpId:J,rpOrigins:l},signal:t},{create:x});return L?\nthis._verify({factorId:w.id,challengeId:L.challengeId,webauthn:{rpId:J,rpOrigins:l,type:L.webauthn.type,credential_response:L.webauthn.credential_response}}):{data:null,error:P}}catch(w){return(0,K.isAuthError)(w)?{data:null,error:w}:{data:null,error:new K.AuthUnknownError(\"Unexpected error in register\",w)}}}}a.WebAuthnApi=v}","~:source","shadow$provide[49] = function(require,module,exports) {\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WebAuthnApi = exports.DEFAULT_REQUEST_OPTIONS = exports.DEFAULT_CREATION_OPTIONS = exports.webAuthnAbortService = exports.WebAuthnAbortService = exports.identifyAuthenticationError = exports.identifyRegistrationError = exports.isWebAuthnError = exports.WebAuthnError = void 0;\r\nexports.deserializeCredentialCreationOptions = deserializeCredentialCreationOptions;\r\nexports.deserializeCredentialRequestOptions = deserializeCredentialRequestOptions;\r\nexports.serializeCredentialCreationResponse = serializeCredentialCreationResponse;\r\nexports.serializeCredentialRequestResponse = serializeCredentialRequestResponse;\r\nexports.isValidDomain = isValidDomain;\r\nexports.createCredential = createCredential;\r\nexports.getCredential = getCredential;\r\nexports.mergeCredentialCreationOptions = mergeCredentialCreationOptions;\r\nexports.mergeCredentialRequestOptions = mergeCredentialRequestOptions;\r\nconst tslib_1 = require(\"tslib\");\r\nconst base64url_1 = require(\"./base64url\");\r\nconst errors_1 = require(\"./errors\");\r\nconst helpers_1 = require(\"./helpers\");\r\nconst webauthn_errors_1 = require(\"./webauthn.errors\");\r\nObject.defineProperty(exports, \"identifyAuthenticationError\", { enumerable: true, get: function () { return webauthn_errors_1.identifyAuthenticationError; } });\r\nObject.defineProperty(exports, \"identifyRegistrationError\", { enumerable: true, get: function () { return webauthn_errors_1.identifyRegistrationError; } });\r\nObject.defineProperty(exports, \"isWebAuthnError\", { enumerable: true, get: function () { return webauthn_errors_1.isWebAuthnError; } });\r\nObject.defineProperty(exports, \"WebAuthnError\", { enumerable: true, get: function () { return webauthn_errors_1.WebAuthnError; } });\r\n/**\r\n * WebAuthn abort service to manage ceremony cancellation.\r\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\r\n *\r\n * @experimental This class is experimental and may change in future releases\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\r\n */\r\nclass WebAuthnAbortService {\r\n    /**\r\n     * Create an abort signal for a new WebAuthn operation.\r\n     * Automatically cancels any existing operation.\r\n     *\r\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\r\n     */\r\n    createNewAbortSignal() {\r\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\r\n        if (this.controller) {\r\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\r\n            abortError.name = 'AbortError';\r\n            this.controller.abort(abortError);\r\n        }\r\n        const newController = new AbortController();\r\n        this.controller = newController;\r\n        return newController.signal;\r\n    }\r\n    /**\r\n     * Manually cancel the current WebAuthn operation.\r\n     * Useful for cleaning up when user cancels or navigates away.\r\n     *\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\r\n     */\r\n    cancelCeremony() {\r\n        if (this.controller) {\r\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\r\n            abortError.name = 'AbortError';\r\n            this.controller.abort(abortError);\r\n            this.controller = undefined;\r\n        }\r\n    }\r\n}\r\nexports.WebAuthnAbortService = WebAuthnAbortService;\r\n/**\r\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\r\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\r\n *\r\n * @experimental This instance is experimental and may change in future releases\r\n */\r\nexports.webAuthnAbortService = new WebAuthnAbortService();\r\n/**\r\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\r\n * as required by the WebAuthn browser API.\r\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\r\n *\r\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\r\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\r\n */\r\nfunction deserializeCredentialCreationOptions(options) {\r\n    if (!options) {\r\n        throw new Error('Credential creation options are required');\r\n    }\r\n    // Check if the native parseCreationOptionsFromJSON method is available\r\n    if (typeof PublicKeyCredential !== 'undefined' &&\r\n        'parseCreationOptionsFromJSON' in PublicKeyCredential &&\r\n        typeof PublicKeyCredential\r\n            .parseCreationOptionsFromJSON === 'function') {\r\n        // Use the native WebAuthn Level 3 method\r\n        return PublicKeyCredential.parseCreationOptionsFromJSON(\r\n        /** we assert the options here as typescript still doesn't know about future webauthn types */\r\n        options);\r\n    }\r\n    // Fallback to manual parsing for browsers that don't support the native method\r\n    // Destructure to separate fields that need transformation\r\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = tslib_1.__rest(options\r\n    // Convert challenge from base64url to ArrayBuffer\r\n    , [\"challenge\", \"user\", \"excludeCredentials\"]);\r\n    // Convert challenge from base64url to ArrayBuffer\r\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\r\n    // Convert user.id from base64url to ArrayBuffer\r\n    const user = Object.assign(Object.assign({}, userOpts), { id: (0, base64url_1.base64UrlToUint8Array)(userOpts.id).buffer });\r\n    // Build the result object\r\n    const result = Object.assign(Object.assign({}, restOptions), { challenge,\r\n        user });\r\n    // Only add excludeCredentials if it exists\r\n    if (excludeCredentials && excludeCredentials.length > 0) {\r\n        result.excludeCredentials = new Array(excludeCredentials.length);\r\n        for (let i = 0; i < excludeCredentials.length; i++) {\r\n            const cred = excludeCredentials[i];\r\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \r\n                // Cast transports to handle future transport types like \"cable\"\r\n                transports: cred.transports });\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\r\n * as required by the WebAuthn browser API.\r\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\r\n *\r\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\r\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\r\n */\r\nfunction deserializeCredentialRequestOptions(options) {\r\n    if (!options) {\r\n        throw new Error('Credential request options are required');\r\n    }\r\n    // Check if the native parseRequestOptionsFromJSON method is available\r\n    if (typeof PublicKeyCredential !== 'undefined' &&\r\n        'parseRequestOptionsFromJSON' in PublicKeyCredential &&\r\n        typeof PublicKeyCredential\r\n            .parseRequestOptionsFromJSON === 'function') {\r\n        // Use the native WebAuthn Level 3 method\r\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\r\n    }\r\n    // Fallback to manual parsing for browsers that don't support the native method\r\n    // Destructure to separate fields that need transformation\r\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = tslib_1.__rest(options\r\n    // Convert challenge from base64url to ArrayBuffer\r\n    , [\"challenge\", \"allowCredentials\"]);\r\n    // Convert challenge from base64url to ArrayBuffer\r\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\r\n    // Build the result object\r\n    const result = Object.assign(Object.assign({}, restOptions), { challenge });\r\n    // Only add allowCredentials if it exists\r\n    if (allowCredentials && allowCredentials.length > 0) {\r\n        result.allowCredentials = new Array(allowCredentials.length);\r\n        for (let i = 0; i < allowCredentials.length; i++) {\r\n            const cred = allowCredentials[i];\r\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \r\n                // Cast transports to handle future transport types like \"cable\"\r\n                transports: cred.transports });\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Convert a registration/enrollment credential response to server format.\r\n * Serializes binary fields to base64url for JSON transmission.\r\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\r\n *\r\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\r\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\r\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\r\n */\r\nfunction serializeCredentialCreationResponse(credential) {\r\n    var _a;\r\n    // Check if the credential instance has the toJSON method\r\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\r\n        // Use the native WebAuthn Level 3 method\r\n        return credential.toJSON();\r\n    }\r\n    const credentialWithAttachment = credential;\r\n    return {\r\n        id: credential.id,\r\n        rawId: credential.id,\r\n        response: {\r\n            attestationObject: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\r\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON)),\r\n        },\r\n        type: 'public-key',\r\n        clientExtensionResults: credential.getClientExtensionResults(),\r\n        // Convert null to undefined and cast to AuthenticatorAttachment type\r\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\r\n    };\r\n}\r\n/**\r\n * Convert an authentication/verification credential response to server format.\r\n * Serializes binary fields to base64url for JSON transmission.\r\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\r\n *\r\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\r\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\r\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\r\n */\r\nfunction serializeCredentialRequestResponse(credential) {\r\n    var _a;\r\n    // Check if the credential instance has the toJSON method\r\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\r\n        // Use the native WebAuthn Level 3 method\r\n        return credential.toJSON();\r\n    }\r\n    // Fallback to manual conversion for browsers that don't support toJSON\r\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\r\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\r\n    const credentialWithAttachment = credential;\r\n    const clientExtensionResults = credential.getClientExtensionResults();\r\n    const assertionResponse = credential.response;\r\n    return {\r\n        id: credential.id,\r\n        rawId: credential.id, // W3C spec expects rawId to match id for JSON format\r\n        response: {\r\n            authenticatorData: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\r\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\r\n            signature: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\r\n            userHandle: assertionResponse.userHandle\r\n                ? (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle))\r\n                : undefined,\r\n        },\r\n        type: 'public-key',\r\n        clientExtensionResults,\r\n        // Convert null to undefined and cast to AuthenticatorAttachment type\r\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\r\n    };\r\n}\r\n/**\r\n * A simple test to determine if a hostname is a properly-formatted domain name.\r\n * Considers localhost valid for development environments.\r\n *\r\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\r\n *\r\n * Regex sourced from here:\r\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\r\n *\r\n * @param {string} hostname - The hostname to validate\r\n * @returns {boolean} True if valid domain or localhost\r\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\r\n */\r\nfunction isValidDomain(hostname) {\r\n    return (\r\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\r\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\r\n}\r\n/**\r\n * Determine if the browser is capable of WebAuthn.\r\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\r\n *\r\n * @returns {boolean} True if browser supports WebAuthn\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\r\n */\r\nfunction browserSupportsWebAuthn() {\r\n    var _a, _b;\r\n    return !!((0, helpers_1.isBrowser)() &&\r\n        'PublicKeyCredential' in window &&\r\n        window.PublicKeyCredential &&\r\n        'credentials' in navigator &&\r\n        typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' &&\r\n        typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');\r\n}\r\n/**\r\n * Create a WebAuthn credential using the browser's credentials API.\r\n * Wraps navigator.credentials.create() with error handling.\r\n *\r\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\r\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\r\n */\r\nasync function createCredential(options) {\r\n    try {\r\n        const response = await navigator.credentials.create(\r\n        /** we assert the type here until typescript types are updated */\r\n        options);\r\n        if (!response) {\r\n            return {\r\n                data: null,\r\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\r\n            };\r\n        }\r\n        if (!(response instanceof PublicKeyCredential)) {\r\n            return {\r\n                data: null,\r\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\r\n            };\r\n        }\r\n        return { data: response, error: null };\r\n    }\r\n    catch (err) {\r\n        return {\r\n            data: null,\r\n            error: (0, webauthn_errors_1.identifyRegistrationError)({\r\n                error: err,\r\n                options,\r\n            }),\r\n        };\r\n    }\r\n}\r\n/**\r\n * Get a WebAuthn credential using the browser's credentials API.\r\n * Wraps navigator.credentials.get() with error handling.\r\n *\r\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\r\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\r\n */\r\nasync function getCredential(options) {\r\n    try {\r\n        const response = await navigator.credentials.get(\r\n        /** we assert the type here until typescript types are updated */\r\n        options);\r\n        if (!response) {\r\n            return {\r\n                data: null,\r\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\r\n            };\r\n        }\r\n        if (!(response instanceof PublicKeyCredential)) {\r\n            return {\r\n                data: null,\r\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\r\n            };\r\n        }\r\n        return { data: response, error: null };\r\n    }\r\n    catch (err) {\r\n        return {\r\n            data: null,\r\n            error: (0, webauthn_errors_1.identifyAuthenticationError)({\r\n                error: err,\r\n                options,\r\n            }),\r\n        };\r\n    }\r\n}\r\nexports.DEFAULT_CREATION_OPTIONS = {\r\n    hints: ['security-key'],\r\n    authenticatorSelection: {\r\n        authenticatorAttachment: 'cross-platform',\r\n        requireResidentKey: false,\r\n        /** set to preferred because older yubikeys don't have PIN/Biometric */\r\n        userVerification: 'preferred',\r\n        residentKey: 'discouraged',\r\n    },\r\n    attestation: 'direct',\r\n};\r\nexports.DEFAULT_REQUEST_OPTIONS = {\r\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\r\n    userVerification: 'preferred',\r\n    hints: ['security-key'],\r\n    attestation: 'direct',\r\n};\r\nfunction deepMerge(...sources) {\r\n    const isObject = (val) => val !== null && typeof val === 'object' && !Array.isArray(val);\r\n    const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);\r\n    const result = {};\r\n    for (const source of sources) {\r\n        if (!source)\r\n            continue;\r\n        for (const key in source) {\r\n            const value = source[key];\r\n            if (value === undefined)\r\n                continue;\r\n            if (Array.isArray(value)) {\r\n                // preserve array reference, including unions like AuthenticatorTransport[]\r\n                result[key] = value;\r\n            }\r\n            else if (isArrayBufferLike(value)) {\r\n                result[key] = value;\r\n            }\r\n            else if (isObject(value)) {\r\n                const existing = result[key];\r\n                if (isObject(existing)) {\r\n                    result[key] = deepMerge(existing, value);\r\n                }\r\n                else {\r\n                    result[key] = deepMerge(value);\r\n                }\r\n            }\r\n            else {\r\n                result[key] = value;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Merges WebAuthn credential creation options with overrides.\r\n * Sets sensible defaults for authenticator selection and extensions.\r\n *\r\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\r\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\r\n * @param {string} friendlyName - Optional friendly name for the credential\r\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\r\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\r\n */\r\nfunction mergeCredentialCreationOptions(baseOptions, overrides) {\r\n    return deepMerge(exports.DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\r\n}\r\n/**\r\n * Merges WebAuthn credential request options with overrides.\r\n * Sets sensible defaults for user verification and hints.\r\n *\r\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\r\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\r\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\r\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\r\n */\r\nfunction mergeCredentialRequestOptions(baseOptions, overrides) {\r\n    return deepMerge(exports.DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\r\n}\r\n/**\r\n * WebAuthn API wrapper for Supabase Auth.\r\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\r\n *\r\n * @experimental This API is experimental and may change in future releases\r\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\r\n */\r\nclass WebAuthnApi {\r\n    constructor(client) {\r\n        this.client = client;\r\n        // Bind all methods so they can be destructured\r\n        this.enroll = this._enroll.bind(this);\r\n        this.challenge = this._challenge.bind(this);\r\n        this.verify = this._verify.bind(this);\r\n        this.authenticate = this._authenticate.bind(this);\r\n        this.register = this._register.bind(this);\r\n    }\r\n    /**\r\n     * Enroll a new WebAuthn factor.\r\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\r\n     *\r\n     * @experimental This method is experimental and may change in future releases\r\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\r\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\r\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\r\n     */\r\n    async _enroll(params) {\r\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: 'webauthn' }));\r\n    }\r\n    /**\r\n     * Challenge for WebAuthn credential creation or authentication.\r\n     * Combines server challenge with browser credential operations.\r\n     * Handles both registration (create) and authentication (request) flows.\r\n     *\r\n     * @experimental This method is experimental and may change in future releases\r\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\r\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\r\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\r\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\r\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\r\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\r\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\r\n     */\r\n    async _challenge({ factorId, webauthn, friendlyName, signal, }, overrides) {\r\n        var _a;\r\n        try {\r\n            // Get challenge from server using the client's MFA methods\r\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\r\n                factorId,\r\n                webauthn,\r\n            });\r\n            if (!challengeResponse) {\r\n                return { data: null, error: challengeError };\r\n            }\r\n            const abortSignal = signal !== null && signal !== void 0 ? signal : exports.webAuthnAbortService.createNewAbortSignal();\r\n            /** webauthn will fail if either of the name/displayname are blank */\r\n            if (challengeResponse.webauthn.type === 'create') {\r\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\r\n                if (!user.name) {\r\n                    // Preserve original format: use friendlyName if provided, otherwise fetch fallback\r\n                    // This maintains backward compatibility with the ${user.id}:${name} format\r\n                    const nameToUse = friendlyName;\r\n                    if (!nameToUse) {\r\n                        // Only fetch user data if friendlyName is not provided (bug fix for null friendlyName)\r\n                        const currentUser = await this.client.getUser();\r\n                        const userData = currentUser.data.user;\r\n                        const fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || 'User';\r\n                        user.name = `${user.id}:${fallbackName}`;\r\n                    }\r\n                    else {\r\n                        user.name = `${user.id}:${nameToUse}`;\r\n                    }\r\n                }\r\n                if (!user.displayName) {\r\n                    user.displayName = user.name;\r\n                }\r\n            }\r\n            switch (challengeResponse.webauthn.type) {\r\n                case 'create': {\r\n                    const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\r\n                    const { data, error } = await createCredential({\r\n                        publicKey: options,\r\n                        signal: abortSignal,\r\n                    });\r\n                    if (data) {\r\n                        return {\r\n                            data: {\r\n                                factorId,\r\n                                challengeId: challengeResponse.id,\r\n                                webauthn: {\r\n                                    type: challengeResponse.webauthn.type,\r\n                                    credential_response: data,\r\n                                },\r\n                            },\r\n                            error: null,\r\n                        };\r\n                    }\r\n                    return { data: null, error };\r\n                }\r\n                case 'request': {\r\n                    const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\r\n                    const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));\r\n                    if (data) {\r\n                        return {\r\n                            data: {\r\n                                factorId,\r\n                                challengeId: challengeResponse.id,\r\n                                webauthn: {\r\n                                    type: challengeResponse.webauthn.type,\r\n                                    credential_response: data,\r\n                                },\r\n                            },\r\n                            error: null,\r\n                        };\r\n                    }\r\n                    return { data: null, error };\r\n                }\r\n            }\r\n        }\r\n        catch (error) {\r\n            if ((0, errors_1.isAuthError)(error)) {\r\n                return { data: null, error };\r\n            }\r\n            return {\r\n                data: null,\r\n                error: new errors_1.AuthUnknownError('Unexpected error in challenge', error),\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * Verify a WebAuthn credential with the server.\r\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\r\n     *\r\n     * @experimental This method is experimental and may change in future releases\r\n     * @param {Object} params - Verification parameters\r\n     * @param {string} params.challengeId - ID of the challenge being verified\r\n     * @param {string} params.factorId - ID of the WebAuthn factor\r\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\r\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\r\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\r\n     * */\r\n    async _verify({ challengeId, factorId, webauthn, }) {\r\n        return this.client.mfa.verify({\r\n            factorId,\r\n            challengeId,\r\n            webauthn: webauthn,\r\n        });\r\n    }\r\n    /**\r\n     * Complete WebAuthn authentication flow.\r\n     * Performs challenge and verification in a single operation for existing credentials.\r\n     *\r\n     * @experimental This method is experimental and may change in future releases\r\n     * @param {Object} params - Authentication parameters\r\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\r\n     * @param {Object} params.webauthn - WebAuthn configuration\r\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\r\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\r\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\r\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\r\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\r\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\r\n     */\r\n    async _authenticate({ factorId, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\r\n        if (!rpId) {\r\n            return {\r\n                data: null,\r\n                error: new errors_1.AuthError('rpId is required for WebAuthn authentication'),\r\n            };\r\n        }\r\n        try {\r\n            if (!browserSupportsWebAuthn()) {\r\n                return {\r\n                    data: null,\r\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\r\n                };\r\n            }\r\n            // Get challenge and credential\r\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\r\n                factorId,\r\n                webauthn: { rpId, rpOrigins },\r\n                signal,\r\n            }, { request: overrides });\r\n            if (!challengeResponse) {\r\n                return { data: null, error: challengeError };\r\n            }\r\n            const { webauthn } = challengeResponse;\r\n            // Verify credential\r\n            return this._verify({\r\n                factorId,\r\n                challengeId: challengeResponse.challengeId,\r\n                webauthn: {\r\n                    type: webauthn.type,\r\n                    rpId,\r\n                    rpOrigins,\r\n                    credential_response: webauthn.credential_response,\r\n                },\r\n            });\r\n        }\r\n        catch (error) {\r\n            if ((0, errors_1.isAuthError)(error)) {\r\n                return { data: null, error };\r\n            }\r\n            return {\r\n                data: null,\r\n                error: new errors_1.AuthUnknownError('Unexpected error in authenticate', error),\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * Complete WebAuthn registration flow.\r\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\r\n     *\r\n     * @experimental This method is experimental and may change in future releases\r\n     * @param {Object} params - Registration parameters\r\n     * @param {string} params.friendlyName - User-friendly name for the credential\r\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\r\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\r\n     * @param {AbortSignal} params.signal - Optional abort signal\r\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\r\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\r\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\r\n     */\r\n    async _register({ friendlyName, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\r\n        if (!rpId) {\r\n            return {\r\n                data: null,\r\n                error: new errors_1.AuthError('rpId is required for WebAuthn registration'),\r\n            };\r\n        }\r\n        try {\r\n            if (!browserSupportsWebAuthn()) {\r\n                return {\r\n                    data: null,\r\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\r\n                };\r\n            }\r\n            // Enroll factor\r\n            const { data: factor, error: enrollError } = await this._enroll({\r\n                friendlyName,\r\n            });\r\n            if (!factor) {\r\n                await this.client.mfa\r\n                    .listFactors()\r\n                    .then((factors) => {\r\n                    var _a;\r\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v) => v.factor_type === 'webauthn' &&\r\n                        v.friendly_name === friendlyName &&\r\n                        v.status !== 'unverified');\r\n                })\r\n                    .then((factor) => (factor ? this.client.mfa.unenroll({ factorId: factor === null || factor === void 0 ? void 0 : factor.id }) : void 0));\r\n                return { data: null, error: enrollError };\r\n            }\r\n            // Get challenge and create credential\r\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\r\n                factorId: factor.id,\r\n                friendlyName: factor.friendly_name,\r\n                webauthn: { rpId, rpOrigins },\r\n                signal,\r\n            }, {\r\n                create: overrides,\r\n            });\r\n            if (!challengeResponse) {\r\n                return { data: null, error: challengeError };\r\n            }\r\n            return this._verify({\r\n                factorId: factor.id,\r\n                challengeId: challengeResponse.challengeId,\r\n                webauthn: {\r\n                    rpId,\r\n                    rpOrigins,\r\n                    type: challengeResponse.webauthn.type,\r\n                    credential_response: challengeResponse.webauthn.credential_response,\r\n                },\r\n            });\r\n        }\r\n        catch (error) {\r\n            if ((0, errors_1.isAuthError)(error)) {\r\n                return { data: null, error };\r\n            }\r\n            return {\r\n                data: null,\r\n                error: new errors_1.AuthUnknownError('Unexpected error in register', error),\r\n            };\r\n        }\r\n    }\r\n}\r\nexports.WebAuthnApi = WebAuthnApi;\r\n//# sourceMappingURL=webauthn.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$tslib$tslib","~$shadow.js","~$module$node_modules$$supabase$auth_js$dist$main$lib$base64url","~$module$node_modules$$supabase$auth_js$dist$main$lib$errors","~$module$node_modules$$supabase$auth_js$dist$main$lib$helpers","~$module$node_modules$$supabase$auth_js$dist$main$lib$webauthn_errors"]],"~:properties",["^5",["clientDataJSON","rawId","allowCredentials","authenticate","webAuthnAbortService","attestation","deserializeCredentialCreationOptions","deserializeCredentialRequestOptions","userVerification","userHandle","displayName","clientExtensionResults","user","__esModule","excludeCredentials","challengeId","serializeCredentialCreationResponse","error","rpId","createCredential","id","publicKey","getCredential","signal","factorType","name","challenge","WebAuthnAbortService","transports","value","verify","hints","authenticatorAttachment","enumerable","friendlyName","attestationObject","request","rpOrigins","identifyRegistrationError","authenticatorSelection","authenticatorData","signature","requireResidentKey","register","DEFAULT_REQUEST_OPTIONS","type","isWebAuthnError","serializeCredentialRequestResponse","enroll","mergeCredentialRequestOptions","credential_response","identifyAuthenticationError","create","factorId","response","mergeCredentialCreationOptions","webauthn","WebAuthnError","DEFAULT_CREATION_OPTIONS","client","options","data","get","WebAuthnApi","residentKey","controller","isValidDomain"]],"~:compiled-at",1771869280916,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$auth_js$dist$main$lib$webauthn.js\",\n\"lineCount\":20,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/auth-js/dist/main/lib/webauthn.js\"],\n\"sourcesContent\":[\"shadow$provide[49] = function(require,module,exports) {\\n\\\"use strict\\\";\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.WebAuthnApi = exports.DEFAULT_REQUEST_OPTIONS = exports.DEFAULT_CREATION_OPTIONS = exports.webAuthnAbortService = exports.WebAuthnAbortService = exports.identifyAuthenticationError = exports.identifyRegistrationError = exports.isWebAuthnError = exports.WebAuthnError = void 0;\\r\\nexports.deserializeCredentialCreationOptions = deserializeCredentialCreationOptions;\\r\\nexports.deserializeCredentialRequestOptions = deserializeCredentialRequestOptions;\\r\\nexports.serializeCredentialCreationResponse = serializeCredentialCreationResponse;\\r\\nexports.serializeCredentialRequestResponse = serializeCredentialRequestResponse;\\r\\nexports.isValidDomain = isValidDomain;\\r\\nexports.createCredential = createCredential;\\r\\nexports.getCredential = getCredential;\\r\\nexports.mergeCredentialCreationOptions = mergeCredentialCreationOptions;\\r\\nexports.mergeCredentialRequestOptions = mergeCredentialRequestOptions;\\r\\nconst tslib_1 = require(\\\"tslib\\\");\\r\\nconst base64url_1 = require(\\\"./base64url\\\");\\r\\nconst errors_1 = require(\\\"./errors\\\");\\r\\nconst helpers_1 = require(\\\"./helpers\\\");\\r\\nconst webauthn_errors_1 = require(\\\"./webauthn.errors\\\");\\r\\nObject.defineProperty(exports, \\\"identifyAuthenticationError\\\", { enumerable: true, get: function () { return webauthn_errors_1.identifyAuthenticationError; } });\\r\\nObject.defineProperty(exports, \\\"identifyRegistrationError\\\", { enumerable: true, get: function () { return webauthn_errors_1.identifyRegistrationError; } });\\r\\nObject.defineProperty(exports, \\\"isWebAuthnError\\\", { enumerable: true, get: function () { return webauthn_errors_1.isWebAuthnError; } });\\r\\nObject.defineProperty(exports, \\\"WebAuthnError\\\", { enumerable: true, get: function () { return webauthn_errors_1.WebAuthnError; } });\\r\\n/**\\r\\n * WebAuthn abort service to manage ceremony cancellation.\\r\\n * Ensures only one WebAuthn ceremony is active at a time to prevent \\\"operation already in progress\\\" errors.\\r\\n *\\r\\n * @experimental This class is experimental and may change in future releases\\r\\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\\r\\n */\\r\\nclass WebAuthnAbortService {\\r\\n    /**\\r\\n     * Create an abort signal for a new WebAuthn operation.\\r\\n     * Automatically cancels any existing operation.\\r\\n     *\\r\\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\\r\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\\r\\n     */\\r\\n    createNewAbortSignal() {\\r\\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\\r\\n        if (this.controller) {\\r\\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\\r\\n            abortError.name = 'AbortError';\\r\\n            this.controller.abort(abortError);\\r\\n        }\\r\\n        const newController = new AbortController();\\r\\n        this.controller = newController;\\r\\n        return newController.signal;\\r\\n    }\\r\\n    /**\\r\\n     * Manually cancel the current WebAuthn operation.\\r\\n     * Useful for cleaning up when user cancels or navigates away.\\r\\n     *\\r\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\\r\\n     */\\r\\n    cancelCeremony() {\\r\\n        if (this.controller) {\\r\\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\\r\\n            abortError.name = 'AbortError';\\r\\n            this.controller.abort(abortError);\\r\\n            this.controller = undefined;\\r\\n        }\\r\\n    }\\r\\n}\\r\\nexports.WebAuthnAbortService = WebAuthnAbortService;\\r\\n/**\\r\\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\\r\\n * This prevents \\\"operation already in progress\\\" errors when retrying WebAuthn operations.\\r\\n *\\r\\n * @experimental This instance is experimental and may change in future releases\\r\\n */\\r\\nexports.webAuthnAbortService = new WebAuthnAbortService();\\r\\n/**\\r\\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\\r\\n * as required by the WebAuthn browser API.\\r\\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\\r\\n *\\r\\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\\r\\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\\r\\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\\r\\n */\\r\\nfunction deserializeCredentialCreationOptions(options) {\\r\\n    if (!options) {\\r\\n        throw new Error('Credential creation options are required');\\r\\n    }\\r\\n    // Check if the native parseCreationOptionsFromJSON method is available\\r\\n    if (typeof PublicKeyCredential !== 'undefined' &&\\r\\n        'parseCreationOptionsFromJSON' in PublicKeyCredential &&\\r\\n        typeof PublicKeyCredential\\r\\n            .parseCreationOptionsFromJSON === 'function') {\\r\\n        // Use the native WebAuthn Level 3 method\\r\\n        return PublicKeyCredential.parseCreationOptionsFromJSON(\\r\\n        /** we assert the options here as typescript still doesn't know about future webauthn types */\\r\\n        options);\\r\\n    }\\r\\n    // Fallback to manual parsing for browsers that don't support the native method\\r\\n    // Destructure to separate fields that need transformation\\r\\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = tslib_1.__rest(options\\r\\n    // Convert challenge from base64url to ArrayBuffer\\r\\n    , [\\\"challenge\\\", \\\"user\\\", \\\"excludeCredentials\\\"]);\\r\\n    // Convert challenge from base64url to ArrayBuffer\\r\\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\\r\\n    // Convert user.id from base64url to ArrayBuffer\\r\\n    const user = Object.assign(Object.assign({}, userOpts), { id: (0, base64url_1.base64UrlToUint8Array)(userOpts.id).buffer });\\r\\n    // Build the result object\\r\\n    const result = Object.assign(Object.assign({}, restOptions), { challenge,\\r\\n        user });\\r\\n    // Only add excludeCredentials if it exists\\r\\n    if (excludeCredentials && excludeCredentials.length > 0) {\\r\\n        result.excludeCredentials = new Array(excludeCredentials.length);\\r\\n        for (let i = 0; i < excludeCredentials.length; i++) {\\r\\n            const cred = excludeCredentials[i];\\r\\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \\r\\n                // Cast transports to handle future transport types like \\\"cable\\\"\\r\\n                transports: cred.transports });\\r\\n        }\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n/**\\r\\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\\r\\n * as required by the WebAuthn browser API.\\r\\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\\r\\n *\\r\\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\\r\\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\\r\\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\\r\\n */\\r\\nfunction deserializeCredentialRequestOptions(options) {\\r\\n    if (!options) {\\r\\n        throw new Error('Credential request options are required');\\r\\n    }\\r\\n    // Check if the native parseRequestOptionsFromJSON method is available\\r\\n    if (typeof PublicKeyCredential !== 'undefined' &&\\r\\n        'parseRequestOptionsFromJSON' in PublicKeyCredential &&\\r\\n        typeof PublicKeyCredential\\r\\n            .parseRequestOptionsFromJSON === 'function') {\\r\\n        // Use the native WebAuthn Level 3 method\\r\\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\\r\\n    }\\r\\n    // Fallback to manual parsing for browsers that don't support the native method\\r\\n    // Destructure to separate fields that need transformation\\r\\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = tslib_1.__rest(options\\r\\n    // Convert challenge from base64url to ArrayBuffer\\r\\n    , [\\\"challenge\\\", \\\"allowCredentials\\\"]);\\r\\n    // Convert challenge from base64url to ArrayBuffer\\r\\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\\r\\n    // Build the result object\\r\\n    const result = Object.assign(Object.assign({}, restOptions), { challenge });\\r\\n    // Only add allowCredentials if it exists\\r\\n    if (allowCredentials && allowCredentials.length > 0) {\\r\\n        result.allowCredentials = new Array(allowCredentials.length);\\r\\n        for (let i = 0; i < allowCredentials.length; i++) {\\r\\n            const cred = allowCredentials[i];\\r\\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \\r\\n                // Cast transports to handle future transport types like \\\"cable\\\"\\r\\n                transports: cred.transports });\\r\\n        }\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n/**\\r\\n * Convert a registration/enrollment credential response to server format.\\r\\n * Serializes binary fields to base64url for JSON transmission.\\r\\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\\r\\n *\\r\\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\\r\\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\\r\\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\\r\\n */\\r\\nfunction serializeCredentialCreationResponse(credential) {\\r\\n    var _a;\\r\\n    // Check if the credential instance has the toJSON method\\r\\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\\r\\n        // Use the native WebAuthn Level 3 method\\r\\n        return credential.toJSON();\\r\\n    }\\r\\n    const credentialWithAttachment = credential;\\r\\n    return {\\r\\n        id: credential.id,\\r\\n        rawId: credential.id,\\r\\n        response: {\\r\\n            attestationObject: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\\r\\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON)),\\r\\n        },\\r\\n        type: 'public-key',\\r\\n        clientExtensionResults: credential.getClientExtensionResults(),\\r\\n        // Convert null to undefined and cast to AuthenticatorAttachment type\\r\\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\\r\\n    };\\r\\n}\\r\\n/**\\r\\n * Convert an authentication/verification credential response to server format.\\r\\n * Serializes binary fields to base64url for JSON transmission.\\r\\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\\r\\n *\\r\\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\\r\\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\\r\\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\\r\\n */\\r\\nfunction serializeCredentialRequestResponse(credential) {\\r\\n    var _a;\\r\\n    // Check if the credential instance has the toJSON method\\r\\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\\r\\n        // Use the native WebAuthn Level 3 method\\r\\n        return credential.toJSON();\\r\\n    }\\r\\n    // Fallback to manual conversion for browsers that don't support toJSON\\r\\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\\r\\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\\r\\n    const credentialWithAttachment = credential;\\r\\n    const clientExtensionResults = credential.getClientExtensionResults();\\r\\n    const assertionResponse = credential.response;\\r\\n    return {\\r\\n        id: credential.id,\\r\\n        rawId: credential.id, // W3C spec expects rawId to match id for JSON format\\r\\n        response: {\\r\\n            authenticatorData: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\\r\\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\\r\\n            signature: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\\r\\n            userHandle: assertionResponse.userHandle\\r\\n                ? (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle))\\r\\n                : undefined,\\r\\n        },\\r\\n        type: 'public-key',\\r\\n        clientExtensionResults,\\r\\n        // Convert null to undefined and cast to AuthenticatorAttachment type\\r\\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\\r\\n    };\\r\\n}\\r\\n/**\\r\\n * A simple test to determine if a hostname is a properly-formatted domain name.\\r\\n * Considers localhost valid for development environments.\\r\\n *\\r\\n * A \\\"valid domain\\\" is defined here: https://url.spec.whatwg.org/#valid-domain\\r\\n *\\r\\n * Regex sourced from here:\\r\\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\\r\\n *\\r\\n * @param {string} hostname - The hostname to validate\\r\\n * @returns {boolean} True if valid domain or localhost\\r\\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\\r\\n */\\r\\nfunction isValidDomain(hostname) {\\r\\n    return (\\r\\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\\r\\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\\\.)+[a-z]{2,}$/i.test(hostname));\\r\\n}\\r\\n/**\\r\\n * Determine if the browser is capable of WebAuthn.\\r\\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\\r\\n *\\r\\n * @returns {boolean} True if browser supports WebAuthn\\r\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\\r\\n */\\r\\nfunction browserSupportsWebAuthn() {\\r\\n    var _a, _b;\\r\\n    return !!((0, helpers_1.isBrowser)() &&\\r\\n        'PublicKeyCredential' in window &&\\r\\n        window.PublicKeyCredential &&\\r\\n        'credentials' in navigator &&\\r\\n        typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' &&\\r\\n        typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');\\r\\n}\\r\\n/**\\r\\n * Create a WebAuthn credential using the browser's credentials API.\\r\\n * Wraps navigator.credentials.create() with error handling.\\r\\n *\\r\\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\\r\\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\\r\\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\\r\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\\r\\n */\\r\\nasync function createCredential(options) {\\r\\n    try {\\r\\n        const response = await navigator.credentials.create(\\r\\n        /** we assert the type here until typescript types are updated */\\r\\n        options);\\r\\n        if (!response) {\\r\\n            return {\\r\\n                data: null,\\r\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\\r\\n            };\\r\\n        }\\r\\n        if (!(response instanceof PublicKeyCredential)) {\\r\\n            return {\\r\\n                data: null,\\r\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\\r\\n            };\\r\\n        }\\r\\n        return { data: response, error: null };\\r\\n    }\\r\\n    catch (err) {\\r\\n        return {\\r\\n            data: null,\\r\\n            error: (0, webauthn_errors_1.identifyRegistrationError)({\\r\\n                error: err,\\r\\n                options,\\r\\n            }),\\r\\n        };\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Get a WebAuthn credential using the browser's credentials API.\\r\\n * Wraps navigator.credentials.get() with error handling.\\r\\n *\\r\\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\\r\\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\\r\\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\\r\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\\r\\n */\\r\\nasync function getCredential(options) {\\r\\n    try {\\r\\n        const response = await navigator.credentials.get(\\r\\n        /** we assert the type here until typescript types are updated */\\r\\n        options);\\r\\n        if (!response) {\\r\\n            return {\\r\\n                data: null,\\r\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\\r\\n            };\\r\\n        }\\r\\n        if (!(response instanceof PublicKeyCredential)) {\\r\\n            return {\\r\\n                data: null,\\r\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\\r\\n            };\\r\\n        }\\r\\n        return { data: response, error: null };\\r\\n    }\\r\\n    catch (err) {\\r\\n        return {\\r\\n            data: null,\\r\\n            error: (0, webauthn_errors_1.identifyAuthenticationError)({\\r\\n                error: err,\\r\\n                options,\\r\\n            }),\\r\\n        };\\r\\n    }\\r\\n}\\r\\nexports.DEFAULT_CREATION_OPTIONS = {\\r\\n    hints: ['security-key'],\\r\\n    authenticatorSelection: {\\r\\n        authenticatorAttachment: 'cross-platform',\\r\\n        requireResidentKey: false,\\r\\n        /** set to preferred because older yubikeys don't have PIN/Biometric */\\r\\n        userVerification: 'preferred',\\r\\n        residentKey: 'discouraged',\\r\\n    },\\r\\n    attestation: 'direct',\\r\\n};\\r\\nexports.DEFAULT_REQUEST_OPTIONS = {\\r\\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\\r\\n    userVerification: 'preferred',\\r\\n    hints: ['security-key'],\\r\\n    attestation: 'direct',\\r\\n};\\r\\nfunction deepMerge(...sources) {\\r\\n    const isObject = (val) => val !== null && typeof val === 'object' && !Array.isArray(val);\\r\\n    const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);\\r\\n    const result = {};\\r\\n    for (const source of sources) {\\r\\n        if (!source)\\r\\n            continue;\\r\\n        for (const key in source) {\\r\\n            const value = source[key];\\r\\n            if (value === undefined)\\r\\n                continue;\\r\\n            if (Array.isArray(value)) {\\r\\n                // preserve array reference, including unions like AuthenticatorTransport[]\\r\\n                result[key] = value;\\r\\n            }\\r\\n            else if (isArrayBufferLike(value)) {\\r\\n                result[key] = value;\\r\\n            }\\r\\n            else if (isObject(value)) {\\r\\n                const existing = result[key];\\r\\n                if (isObject(existing)) {\\r\\n                    result[key] = deepMerge(existing, value);\\r\\n                }\\r\\n                else {\\r\\n                    result[key] = deepMerge(value);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                result[key] = value;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n/**\\r\\n * Merges WebAuthn credential creation options with overrides.\\r\\n * Sets sensible defaults for authenticator selection and extensions.\\r\\n *\\r\\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\\r\\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\\r\\n * @param {string} friendlyName - Optional friendly name for the credential\\r\\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\\r\\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\\r\\n */\\r\\nfunction mergeCredentialCreationOptions(baseOptions, overrides) {\\r\\n    return deepMerge(exports.DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\\r\\n}\\r\\n/**\\r\\n * Merges WebAuthn credential request options with overrides.\\r\\n * Sets sensible defaults for user verification and hints.\\r\\n *\\r\\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\\r\\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\\r\\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\\r\\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\\r\\n */\\r\\nfunction mergeCredentialRequestOptions(baseOptions, overrides) {\\r\\n    return deepMerge(exports.DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\\r\\n}\\r\\n/**\\r\\n * WebAuthn API wrapper for Supabase Auth.\\r\\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\\r\\n *\\r\\n * @experimental This API is experimental and may change in future releases\\r\\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\\r\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\\r\\n */\\r\\nclass WebAuthnApi {\\r\\n    constructor(client) {\\r\\n        this.client = client;\\r\\n        // Bind all methods so they can be destructured\\r\\n        this.enroll = this._enroll.bind(this);\\r\\n        this.challenge = this._challenge.bind(this);\\r\\n        this.verify = this._verify.bind(this);\\r\\n        this.authenticate = this._authenticate.bind(this);\\r\\n        this.register = this._register.bind(this);\\r\\n    }\\r\\n    /**\\r\\n     * Enroll a new WebAuthn factor.\\r\\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\\r\\n     *\\r\\n     * @experimental This method is experimental and may change in future releases\\r\\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\\r\\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\\r\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\\r\\n     */\\r\\n    async _enroll(params) {\\r\\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: 'webauthn' }));\\r\\n    }\\r\\n    /**\\r\\n     * Challenge for WebAuthn credential creation or authentication.\\r\\n     * Combines server challenge with browser credential operations.\\r\\n     * Handles both registration (create) and authentication (request) flows.\\r\\n     *\\r\\n     * @experimental This method is experimental and may change in future releases\\r\\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\\r\\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\\r\\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\\r\\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\\r\\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\\r\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\\r\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\\r\\n     */\\r\\n    async _challenge({ factorId, webauthn, friendlyName, signal, }, overrides) {\\r\\n        var _a;\\r\\n        try {\\r\\n            // Get challenge from server using the client's MFA methods\\r\\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\\r\\n                factorId,\\r\\n                webauthn,\\r\\n            });\\r\\n            if (!challengeResponse) {\\r\\n                return { data: null, error: challengeError };\\r\\n            }\\r\\n            const abortSignal = signal !== null && signal !== void 0 ? signal : exports.webAuthnAbortService.createNewAbortSignal();\\r\\n            /** webauthn will fail if either of the name/displayname are blank */\\r\\n            if (challengeResponse.webauthn.type === 'create') {\\r\\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\\r\\n                if (!user.name) {\\r\\n                    // Preserve original format: use friendlyName if provided, otherwise fetch fallback\\r\\n                    // This maintains backward compatibility with the ${user.id}:${name} format\\r\\n                    const nameToUse = friendlyName;\\r\\n                    if (!nameToUse) {\\r\\n                        // Only fetch user data if friendlyName is not provided (bug fix for null friendlyName)\\r\\n                        const currentUser = await this.client.getUser();\\r\\n                        const userData = currentUser.data.user;\\r\\n                        const fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || 'User';\\r\\n                        user.name = `${user.id}:${fallbackName}`;\\r\\n                    }\\r\\n                    else {\\r\\n                        user.name = `${user.id}:${nameToUse}`;\\r\\n                    }\\r\\n                }\\r\\n                if (!user.displayName) {\\r\\n                    user.displayName = user.name;\\r\\n                }\\r\\n            }\\r\\n            switch (challengeResponse.webauthn.type) {\\r\\n                case 'create': {\\r\\n                    const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\\r\\n                    const { data, error } = await createCredential({\\r\\n                        publicKey: options,\\r\\n                        signal: abortSignal,\\r\\n                    });\\r\\n                    if (data) {\\r\\n                        return {\\r\\n                            data: {\\r\\n                                factorId,\\r\\n                                challengeId: challengeResponse.id,\\r\\n                                webauthn: {\\r\\n                                    type: challengeResponse.webauthn.type,\\r\\n                                    credential_response: data,\\r\\n                                },\\r\\n                            },\\r\\n                            error: null,\\r\\n                        };\\r\\n                    }\\r\\n                    return { data: null, error };\\r\\n                }\\r\\n                case 'request': {\\r\\n                    const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\\r\\n                    const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));\\r\\n                    if (data) {\\r\\n                        return {\\r\\n                            data: {\\r\\n                                factorId,\\r\\n                                challengeId: challengeResponse.id,\\r\\n                                webauthn: {\\r\\n                                    type: challengeResponse.webauthn.type,\\r\\n                                    credential_response: data,\\r\\n                                },\\r\\n                            },\\r\\n                            error: null,\\r\\n                        };\\r\\n                    }\\r\\n                    return { data: null, error };\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        catch (error) {\\r\\n            if ((0, errors_1.isAuthError)(error)) {\\r\\n                return { data: null, error };\\r\\n            }\\r\\n            return {\\r\\n                data: null,\\r\\n                error: new errors_1.AuthUnknownError('Unexpected error in challenge', error),\\r\\n            };\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Verify a WebAuthn credential with the server.\\r\\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\\r\\n     *\\r\\n     * @experimental This method is experimental and may change in future releases\\r\\n     * @param {Object} params - Verification parameters\\r\\n     * @param {string} params.challengeId - ID of the challenge being verified\\r\\n     * @param {string} params.factorId - ID of the WebAuthn factor\\r\\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\\r\\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\\r\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\\r\\n     * */\\r\\n    async _verify({ challengeId, factorId, webauthn, }) {\\r\\n        return this.client.mfa.verify({\\r\\n            factorId,\\r\\n            challengeId,\\r\\n            webauthn: webauthn,\\r\\n        });\\r\\n    }\\r\\n    /**\\r\\n     * Complete WebAuthn authentication flow.\\r\\n     * Performs challenge and verification in a single operation for existing credentials.\\r\\n     *\\r\\n     * @experimental This method is experimental and may change in future releases\\r\\n     * @param {Object} params - Authentication parameters\\r\\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\\r\\n     * @param {Object} params.webauthn - WebAuthn configuration\\r\\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\\r\\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\\r\\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\\r\\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\\r\\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\\r\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\\r\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\\r\\n     */\\r\\n    async _authenticate({ factorId, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\\r\\n        if (!rpId) {\\r\\n            return {\\r\\n                data: null,\\r\\n                error: new errors_1.AuthError('rpId is required for WebAuthn authentication'),\\r\\n            };\\r\\n        }\\r\\n        try {\\r\\n            if (!browserSupportsWebAuthn()) {\\r\\n                return {\\r\\n                    data: null,\\r\\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\\r\\n                };\\r\\n            }\\r\\n            // Get challenge and credential\\r\\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\\r\\n                factorId,\\r\\n                webauthn: { rpId, rpOrigins },\\r\\n                signal,\\r\\n            }, { request: overrides });\\r\\n            if (!challengeResponse) {\\r\\n                return { data: null, error: challengeError };\\r\\n            }\\r\\n            const { webauthn } = challengeResponse;\\r\\n            // Verify credential\\r\\n            return this._verify({\\r\\n                factorId,\\r\\n                challengeId: challengeResponse.challengeId,\\r\\n                webauthn: {\\r\\n                    type: webauthn.type,\\r\\n                    rpId,\\r\\n                    rpOrigins,\\r\\n                    credential_response: webauthn.credential_response,\\r\\n                },\\r\\n            });\\r\\n        }\\r\\n        catch (error) {\\r\\n            if ((0, errors_1.isAuthError)(error)) {\\r\\n                return { data: null, error };\\r\\n            }\\r\\n            return {\\r\\n                data: null,\\r\\n                error: new errors_1.AuthUnknownError('Unexpected error in authenticate', error),\\r\\n            };\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Complete WebAuthn registration flow.\\r\\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\\r\\n     *\\r\\n     * @experimental This method is experimental and may change in future releases\\r\\n     * @param {Object} params - Registration parameters\\r\\n     * @param {string} params.friendlyName - User-friendly name for the credential\\r\\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\\r\\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\\r\\n     * @param {AbortSignal} params.signal - Optional abort signal\\r\\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\\r\\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\\r\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\\r\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\\r\\n     */\\r\\n    async _register({ friendlyName, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\\r\\n        if (!rpId) {\\r\\n            return {\\r\\n                data: null,\\r\\n                error: new errors_1.AuthError('rpId is required for WebAuthn registration'),\\r\\n            };\\r\\n        }\\r\\n        try {\\r\\n            if (!browserSupportsWebAuthn()) {\\r\\n                return {\\r\\n                    data: null,\\r\\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\\r\\n                };\\r\\n            }\\r\\n            // Enroll factor\\r\\n            const { data: factor, error: enrollError } = await this._enroll({\\r\\n                friendlyName,\\r\\n            });\\r\\n            if (!factor) {\\r\\n                await this.client.mfa\\r\\n                    .listFactors()\\r\\n                    .then((factors) => {\\r\\n                    var _a;\\r\\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v) => v.factor_type === 'webauthn' &&\\r\\n                        v.friendly_name === friendlyName &&\\r\\n                        v.status !== 'unverified');\\r\\n                })\\r\\n                    .then((factor) => (factor ? this.client.mfa.unenroll({ factorId: factor === null || factor === void 0 ? void 0 : factor.id }) : void 0));\\r\\n                return { data: null, error: enrollError };\\r\\n            }\\r\\n            // Get challenge and create credential\\r\\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\\r\\n                factorId: factor.id,\\r\\n                friendlyName: factor.friendly_name,\\r\\n                webauthn: { rpId, rpOrigins },\\r\\n                signal,\\r\\n            }, {\\r\\n                create: overrides,\\r\\n            });\\r\\n            if (!challengeResponse) {\\r\\n                return { data: null, error: challengeError };\\r\\n            }\\r\\n            return this._verify({\\r\\n                factorId: factor.id,\\r\\n                challengeId: challengeResponse.challengeId,\\r\\n                webauthn: {\\r\\n                    rpId,\\r\\n                    rpOrigins,\\r\\n                    type: challengeResponse.webauthn.type,\\r\\n                    credential_response: challengeResponse.webauthn.credential_response,\\r\\n                },\\r\\n            });\\r\\n        }\\r\\n        catch (error) {\\r\\n            if ((0, errors_1.isAuthError)(error)) {\\r\\n                return { data: null, error };\\r\\n            }\\r\\n            return {\\r\\n                data: null,\\r\\n                error: new errors_1.AuthUnknownError('Unexpected error in register', error),\\r\\n            };\\r\\n        }\\r\\n    }\\r\\n}\\r\\nexports.WebAuthnApi = WebAuthnApi;\\r\\n//# sourceMappingURL=webauthn.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"browserSupportsWebAuthn\",\"_a\",\"_b\",\"helpers_1\",\"isBrowser\",\"window\",\"PublicKeyCredential\",\"navigator\",\"credentials\",\"create\",\"get\",\"createCredential\",\"options\",\"response\",\"data\",\"error\",\"webauthn_errors_1\",\"WebAuthnUnknownError\",\"err\",\"identifyRegistrationError\",\"getCredential\",\"identifyAuthenticationError\",\"deepMerge\",\"sources\",\"result\",\"source\",\"key\",\"value\",\"undefined\",\"Array\",\"isArray\",\"ArrayBuffer\",\"isView\",\"existing\",\"mergeCredentialCreationOptions\",\"baseOptions\",\"overrides\",\"DEFAULT_CREATION_OPTIONS\",\"mergeCredentialRequestOptions\",\"DEFAULT_REQUEST_OPTIONS\",\"Object\",\"defineProperty\",\"WebAuthnApi\",\"webAuthnAbortService\",\"WebAuthnAbortService\",\"isWebAuthnError\",\"WebAuthnError\",\"deserializeCredentialCreationOptions\",\"Error\",\"parseCreationOptionsFromJSON\",\"challengeStr\",\"userOpts\",\"excludeCredentials\",\"restOptions\",\"tslib_1\",\"__rest\",\"challenge\",\"base64url_1\",\"base64UrlToUint8Array\",\"buffer\",\"user\",\"assign\",\"id\",\"length\",\"i\",\"cred\",\"type\",\"transports\",\"deserializeCredentialRequestOptions\",\"parseRequestOptionsFromJSON\",\"allowCredentials\",\"serializeCredentialCreationResponse\",\"credential\",\"toJSON\",\"rawId\",\"attestationObject\",\"bytesToBase64URL\",\"Uint8Array\",\"clientDataJSON\",\"clientExtensionResults\",\"getClientExtensionResults\",\"authenticatorAttachment\",\"serializeCredentialRequestResponse\",\"assertionResponse\",\"authenticatorData\",\"signature\",\"userHandle\",\"isValidDomain\",\"hostname\",\"test\",\"errors_1\",\"enumerable\",\"createNewAbortSignal\",\"controller\",\"abortError\",\"name\",\"abort\",\"newController\",\"AbortController\",\"signal\",\"cancelCeremony\",\"hints\",\"authenticatorSelection\",\"requireResidentKey\",\"userVerification\",\"residentKey\",\"attestation\",\"constructor\",\"client\",\"enroll\",\"_enroll\",\"bind\",\"_challenge\",\"verify\",\"_verify\",\"authenticate\",\"_authenticate\",\"register\",\"_register\",\"params\",\"mfa\",\"factorType\",\"factorId\",\"webauthn\",\"friendlyName\",\"challengeResponse\",\"challengeError\",\"abortSignal\",\"credential_options\",\"publicKey\",\"userData\",\"currentUser\",\"getUser\",\"fallbackName\",\"user_metadata\",\"email\",\"displayName\",\"challengeId\",\"credential_response\",\"request\",\"isAuthError\",\"AuthUnknownError\",\"rpId\",\"location\",\"rpOrigins\",\"origin\",\"AuthError\",\"factor\",\"enrollError\",\"listFactors\",\"then\",\"factors\",\"all\",\"find\",\"v\",\"factor_type\",\"friendly_name\",\"status\",\"unenroll\"]\n}\n"]