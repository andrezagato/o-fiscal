["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/auth-js/dist/main/lib/locks.js"],"~:js","shadow$provide[45]=function(I,R,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.ProcessLockAcquireTimeoutError=a.NavigatorLockAcquireTimeoutError=a.LockAcquireTimeoutError=a.internals=void 0;a.navigatorLock=async function(z,y,F){a.internals.debug&&console.log(\"@supabase/gotrue-js: navigatorLock: acquire lock\",z,y);const b=new globalThis.AbortController;y>0&&setTimeout(()=>{b.abort();a.internals.debug&&console.log(\"@supabase/gotrue-js: navigatorLock acquire timed out\",z)},y);await Promise.resolve();\ntry{return await globalThis.navigator.locks.request(z,y===0?{mode:\"exclusive\",ifAvailable:!0}:{mode:\"exclusive\",signal:b.signal},async D=>{if(D){a.internals.debug&&console.log(\"@supabase/gotrue-js: navigatorLock: acquired\",z,D.name);try{return await F()}finally{a.internals.debug&&console.log(\"@supabase/gotrue-js: navigatorLock: released\",z,D.name)}}else{if(y===0)throw a.internals.debug&&console.log(\"@supabase/gotrue-js: navigatorLock: not immediately available\",z),new l(`Acquiring an exclusive Navigator LockManager lock \"${z}\" immediately failed`);\nif(a.internals.debug)try{const k=await globalThis.navigator.locks.query();console.log(\"@supabase/gotrue-js: Navigator LockManager state\",JSON.stringify(k,null,\"  \"))}catch(k){console.warn(\"@supabase/gotrue-js: Error when querying Navigator LockManager state\",k)}console.warn(\"@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\");\nreturn await F()}})}catch(D){if((D===null||D===void 0?void 0:D.name)===\"AbortError\")throw new l(`Acquiring an exclusive Navigator LockManager lock \"${z}\" timed out waiting ${y}ms`);throw D;}};a.processLock=async function(z,y,F){var b;const D=(b=w[z])!==null&&b!==void 0?b:Promise.resolve(),k=(async()=>{try{return await D,null}catch(t){return null}})(),f=(async()=>{let t=null;try{const n=y>=0?new Promise((v,A)=>{t=setTimeout(()=>{console.warn(`@supabase/gotrue-js: Lock \"${z}\" acquisition timed out after ${y}ms. `+\n\"This may be caused by another operation holding the lock. Consider increasing lockAcquireTimeout or checking for stuck operations.\");A(new x(`Acquiring process lock with name \"${z}\" timed out`))},y)}):null;await Promise.race([k,n].filter(v=>v));t!==null&&clearTimeout(t)}catch(n){if(t!==null&&clearTimeout(t),n&&n.isAcquireTimeout)throw n;}return await F()})();w[z]=(async()=>{try{return await f}catch(t){if(t&&t.isAcquireTimeout){try{await D}catch(n){}return null}throw t;}})();return await f};I=I(40);\na.internals={debug:!!(globalThis&&(0,I.supportsLocalStorage)()&&globalThis.localStorage&&globalThis.localStorage.getItem(\"supabase.gotrue-js.locks.debug\")===\"true\")};class G extends Error{constructor(z){super(z);this.isAcquireTimeout=!0}}a.LockAcquireTimeoutError=G;class l extends G{}a.NavigatorLockAcquireTimeoutError=l;class x extends G{}a.ProcessLockAcquireTimeoutError=x;const w={}}","~:source","shadow$provide[45] = function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProcessLockAcquireTimeoutError = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = exports.internals = void 0;\nexports.navigatorLock = navigatorLock;\nexports.processLock = processLock;\nconst helpers_1 = require(\"./helpers\");\n/**\n * @experimental\n */\nexports.internals = {\n    /**\n     * @experimental\n     */\n    debug: !!(globalThis &&\n        (0, helpers_1.supportsLocalStorage)() &&\n        globalThis.localStorage &&\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n *\n * @example\n * ```ts\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * class CustomLockError extends LockAcquireTimeoutError {\n *   constructor() {\n *     super('Lock timed out')\n *   }\n * }\n * ```\n */\nclass LockAcquireTimeoutError extends Error {\n    constructor(message) {\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nexports.LockAcquireTimeoutError = LockAcquireTimeoutError;\n/**\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\n *\n * @example\n * ```ts\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\n * ```\n */\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nexports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;\n/**\n * Error thrown when the process-level lock helper cannot acquire a lock.\n *\n * @example\n * ```ts\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\n * ```\n */\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nexports.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await navigatorLock('sync-user', 1000, async () => {\n *   await refreshSession()\n * })\n * ```\n */\nasync function navigatorLock(name, acquireTimeout, fn) {\n    if (exports.internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n            if (exports.internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping with await Promise.resolve() is done as some libraries like zone.js\n    // patch the Promise object to track execution context. We use await instead of\n    // .then() to avoid Firefox content script security errors where accessing .then()\n    // on cross-context promises is forbidden.\n    await Promise.resolve();\n    try {\n        return await globalThis.navigator.locks.request(name, acquireTimeout === 0\n            ? {\n                mode: 'exclusive',\n                ifAvailable: true,\n            }\n            : {\n                mode: 'exclusive',\n                signal: abortController.signal,\n            }, async (lock) => {\n            if (lock) {\n                if (exports.internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n                }\n                try {\n                    return await fn();\n                }\n                finally {\n                    if (exports.internals.debug) {\n                        console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n                    }\n                }\n            }\n            else {\n                if (acquireTimeout === 0) {\n                    if (exports.internals.debug) {\n                        console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n                    }\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n                }\n                else {\n                    if (exports.internals.debug) {\n                        try {\n                            const result = await globalThis.navigator.locks.query();\n                            console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n                        }\n                        catch (e) {\n                            console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n                        }\n                    }\n                    // Browser is not following the Navigator LockManager spec, it\n                    // returned a null lock when we didn't use ifAvailable. So we can\n                    // pretend the lock is acquired in the name of backward compatibility\n                    // and user experience and just run the function.\n                    console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n                    return await fn();\n                }\n            }\n        });\n    }\n    catch (e) {\n        // When the AbortController times out, navigator.locks.request rejects with\n        // a DOMException named 'AbortError'. Convert this to NavigatorLockAcquireTimeoutError\n        // so callers can check error.isAcquireTimeout as documented.\n        if ((e === null || e === void 0 ? void 0 : e.name) === 'AbortError') {\n            throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" timed out waiting ${acquireTimeout}ms`);\n        }\n        throw e;\n    }\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await processLock('migrate', 5000, async () => {\n *   await runMigration()\n * })\n * ```\n */\nasync function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    // Wrap previousOperation to handle errors without using .catch()\n    // This avoids Firefox content script security errors\n    const previousOperationHandled = (async () => {\n        try {\n            await previousOperation;\n            return null;\n        }\n        catch (e) {\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }\n    })();\n    const currentOperation = (async () => {\n        let timeoutId = null;\n        try {\n            // Wait for either previous operation or timeout\n            const timeoutPromise = acquireTimeout >= 0\n                ? new Promise((_, reject) => {\n                    timeoutId = setTimeout(() => {\n                        console.warn(`@supabase/gotrue-js: Lock \"${name}\" acquisition timed out after ${acquireTimeout}ms. ` +\n                            'This may be caused by another operation holding the lock. ' +\n                            'Consider increasing lockAcquireTimeout or checking for stuck operations.');\n                        reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \"${name}\" timed out`));\n                    }, acquireTimeout);\n                })\n                : null;\n            await Promise.race([previousOperationHandled, timeoutPromise].filter((x) => x));\n            // If we reach here, previousOperationHandled won the race\n            // Clear the timeout to prevent false warnings\n            if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n            }\n        }\n        catch (e) {\n            // Clear the timeout on error path as well\n            if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n            }\n            // Re-throw timeout errors, ignore others\n            if (e && e.isAcquireTimeout) {\n                throw e;\n            }\n            // Fall through to run fn() - previous operation finished with error\n        }\n        // Previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    })();\n    PROCESS_LOCKS[name] = (async () => {\n        try {\n            return await currentOperation;\n        }\n        catch (e) {\n            if (e && e.isAcquireTimeout) {\n                // if the current operation timed out, it doesn't mean that the previous\n                // operation finished, so we need continue waiting for it to finish\n                try {\n                    await previousOperation;\n                }\n                catch (prevError) {\n                    // Ignore previous operation errors\n                }\n                return null;\n            }\n            throw e;\n        }\n    })();\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n}\n//# sourceMappingURL=locks.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$supabase$auth_js$dist$main$lib$helpers"]],"~:properties",["^5",["isAcquireTimeout","__esModule","navigatorLock","mode","signal","ProcessLockAcquireTimeoutError","value","NavigatorLockAcquireTimeoutError","debug","ifAvailable","processLock","internals","LockAcquireTimeoutError"]],"~:compiled-at",1771725993781,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$auth_js$dist$main$lib$locks.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/auth-js/dist/main/lib/locks.js\"],\n\"sourcesContent\":[\"shadow$provide[45] = function(require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.ProcessLockAcquireTimeoutError = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = exports.internals = void 0;\\nexports.navigatorLock = navigatorLock;\\nexports.processLock = processLock;\\nconst helpers_1 = require(\\\"./helpers\\\");\\n/**\\n * @experimental\\n */\\nexports.internals = {\\n    /**\\n     * @experimental\\n     */\\n    debug: !!(globalThis &&\\n        (0, helpers_1.supportsLocalStorage)() &&\\n        globalThis.localStorage &&\\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\\n};\\n/**\\n * An error thrown when a lock cannot be acquired after some amount of time.\\n *\\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\\n *\\n * @example\\n * ```ts\\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\\n *\\n * class CustomLockError extends LockAcquireTimeoutError {\\n *   constructor() {\\n *     super('Lock timed out')\\n *   }\\n * }\\n * ```\\n */\\nclass LockAcquireTimeoutError extends Error {\\n    constructor(message) {\\n        super(message);\\n        this.isAcquireTimeout = true;\\n    }\\n}\\nexports.LockAcquireTimeoutError = LockAcquireTimeoutError;\\n/**\\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\\n *\\n * @example\\n * ```ts\\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\\n *\\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\\n * ```\\n */\\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\\n}\\nexports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;\\n/**\\n * Error thrown when the process-level lock helper cannot acquire a lock.\\n *\\n * @example\\n * ```ts\\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\\n *\\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\\n * ```\\n */\\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\\n}\\nexports.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;\\n/**\\n * Implements a global exclusive lock using the Navigator LockManager API. It\\n * is available on all browsers released after 2022-03-15 with Safari being the\\n * last one to release support. If the API is not available, this function will\\n * throw. Make sure you check availablility before configuring {@link\\n * GoTrueClient}.\\n *\\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\\n * local storage item to `true`.\\n *\\n * Internals:\\n *\\n * Since the LockManager API does not preserve stack traces for the async\\n * function passed in the `request` method, a trick is used where acquiring the\\n * lock releases a previously started promise to run the operation in the `fn`\\n * function. The lock waits for that promise to finish (with or without error),\\n * while the function will finally wait for the result anyway.\\n *\\n * @param name Name of the lock to be acquired.\\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\\n *                       will time out after so many milliseconds. An error is\\n *                       a timeout if it has `isAcquireTimeout` set to true.\\n * @param fn The operation to run once the lock is acquired.\\n * @example\\n * ```ts\\n * await navigatorLock('sync-user', 1000, async () => {\\n *   await refreshSession()\\n * })\\n * ```\\n */\\nasync function navigatorLock(name, acquireTimeout, fn) {\\n    if (exports.internals.debug) {\\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\\n    }\\n    const abortController = new globalThis.AbortController();\\n    if (acquireTimeout > 0) {\\n        setTimeout(() => {\\n            abortController.abort();\\n            if (exports.internals.debug) {\\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\\n            }\\n        }, acquireTimeout);\\n    }\\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\\n    // Wrapping with await Promise.resolve() is done as some libraries like zone.js\\n    // patch the Promise object to track execution context. We use await instead of\\n    // .then() to avoid Firefox content script security errors where accessing .then()\\n    // on cross-context promises is forbidden.\\n    await Promise.resolve();\\n    try {\\n        return await globalThis.navigator.locks.request(name, acquireTimeout === 0\\n            ? {\\n                mode: 'exclusive',\\n                ifAvailable: true,\\n            }\\n            : {\\n                mode: 'exclusive',\\n                signal: abortController.signal,\\n            }, async (lock) => {\\n            if (lock) {\\n                if (exports.internals.debug) {\\n                    console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\\n                }\\n                try {\\n                    return await fn();\\n                }\\n                finally {\\n                    if (exports.internals.debug) {\\n                        console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\\n                    }\\n                }\\n            }\\n            else {\\n                if (acquireTimeout === 0) {\\n                    if (exports.internals.debug) {\\n                        console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\\n                    }\\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \\\"${name}\\\" immediately failed`);\\n                }\\n                else {\\n                    if (exports.internals.debug) {\\n                        try {\\n                            const result = await globalThis.navigator.locks.query();\\n                            console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\\n                        }\\n                        catch (e) {\\n                            console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\\n                        }\\n                    }\\n                    // Browser is not following the Navigator LockManager spec, it\\n                    // returned a null lock when we didn't use ifAvailable. So we can\\n                    // pretend the lock is acquired in the name of backward compatibility\\n                    // and user experience and just run the function.\\n                    console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\\n                    return await fn();\\n                }\\n            }\\n        });\\n    }\\n    catch (e) {\\n        // When the AbortController times out, navigator.locks.request rejects with\\n        // a DOMException named 'AbortError'. Convert this to NavigatorLockAcquireTimeoutError\\n        // so callers can check error.isAcquireTimeout as documented.\\n        if ((e === null || e === void 0 ? void 0 : e.name) === 'AbortError') {\\n            throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \\\"${name}\\\" timed out waiting ${acquireTimeout}ms`);\\n        }\\n        throw e;\\n    }\\n}\\nconst PROCESS_LOCKS = {};\\n/**\\n * Implements a global exclusive lock that works only in the current process.\\n * Useful for environments like React Native or other non-browser\\n * single-process (i.e. no concept of \\\"tabs\\\") environments.\\n *\\n * Use {@link #navigatorLock} in browser environments.\\n *\\n * @param name Name of the lock to be acquired.\\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\\n *                       will time out after so many milliseconds. An error is\\n *                       a timeout if it has `isAcquireTimeout` set to true.\\n * @param fn The operation to run once the lock is acquired.\\n * @example\\n * ```ts\\n * await processLock('migrate', 5000, async () => {\\n *   await runMigration()\\n * })\\n * ```\\n */\\nasync function processLock(name, acquireTimeout, fn) {\\n    var _a;\\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\\n    // Wrap previousOperation to handle errors without using .catch()\\n    // This avoids Firefox content script security errors\\n    const previousOperationHandled = (async () => {\\n        try {\\n            await previousOperation;\\n            return null;\\n        }\\n        catch (e) {\\n            // ignore error of previous operation that we're waiting to finish\\n            return null;\\n        }\\n    })();\\n    const currentOperation = (async () => {\\n        let timeoutId = null;\\n        try {\\n            // Wait for either previous operation or timeout\\n            const timeoutPromise = acquireTimeout >= 0\\n                ? new Promise((_, reject) => {\\n                    timeoutId = setTimeout(() => {\\n                        console.warn(`@supabase/gotrue-js: Lock \\\"${name}\\\" acquisition timed out after ${acquireTimeout}ms. ` +\\n                            'This may be caused by another operation holding the lock. ' +\\n                            'Consider increasing lockAcquireTimeout or checking for stuck operations.');\\n                        reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \\\"${name}\\\" timed out`));\\n                    }, acquireTimeout);\\n                })\\n                : null;\\n            await Promise.race([previousOperationHandled, timeoutPromise].filter((x) => x));\\n            // If we reach here, previousOperationHandled won the race\\n            // Clear the timeout to prevent false warnings\\n            if (timeoutId !== null) {\\n                clearTimeout(timeoutId);\\n            }\\n        }\\n        catch (e) {\\n            // Clear the timeout on error path as well\\n            if (timeoutId !== null) {\\n                clearTimeout(timeoutId);\\n            }\\n            // Re-throw timeout errors, ignore others\\n            if (e && e.isAcquireTimeout) {\\n                throw e;\\n            }\\n            // Fall through to run fn() - previous operation finished with error\\n        }\\n        // Previous operations finished and we didn't get a race on the acquire\\n        // timeout, so the current operation can finally start\\n        return await fn();\\n    })();\\n    PROCESS_LOCKS[name] = (async () => {\\n        try {\\n            return await currentOperation;\\n        }\\n        catch (e) {\\n            if (e && e.isAcquireTimeout) {\\n                // if the current operation timed out, it doesn't mean that the previous\\n                // operation finished, so we need continue waiting for it to finish\\n                try {\\n                    await previousOperation;\\n                }\\n                catch (prevError) {\\n                    // Ignore previous operation errors\\n                }\\n                return null;\\n            }\\n            throw e;\\n        }\\n    })();\\n    // finally wait for the current operation to finish successfully, with an\\n    // error or with an acquire timeout error\\n    return await currentOperation;\\n}\\n//# sourceMappingURL=locks.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"ProcessLockAcquireTimeoutError\",\"NavigatorLockAcquireTimeoutError\",\"LockAcquireTimeoutError\",\"internals\",\"navigatorLock\",\"name\",\"acquireTimeout\",\"fn\",\"debug\",\"console\",\"log\",\"abortController\",\"globalThis\",\"AbortController\",\"setTimeout\",\"abort\",\"Promise\",\"resolve\",\"navigator\",\"locks\",\"request\",\"mode\",\"ifAvailable\",\"signal\",\"lock\",\"result\",\"query\",\"JSON\",\"stringify\",\"e\",\"warn\",\"processLock\",\"_a\",\"previousOperation\",\"PROCESS_LOCKS\",\"previousOperationHandled\",\"currentOperation\",\"timeoutId\",\"timeoutPromise\",\"_\",\"reject\",\"race\",\"filter\",\"x\",\"clearTimeout\",\"isAcquireTimeout\",\"prevError\",\"helpers_1\",\"supportsLocalStorage\",\"localStorage\",\"getItem\",\"Error\",\"constructor\",\"message\"]\n}\n"]