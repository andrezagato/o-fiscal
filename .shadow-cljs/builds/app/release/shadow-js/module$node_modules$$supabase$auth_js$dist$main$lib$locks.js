["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/auth-js/dist/main/lib/locks.js"],"~:js","shadow$provide[45]=function(S,ka,a){Object.defineProperty(a,\"__esModule\",{value:!0});a.ProcessLockAcquireTimeoutError=a.NavigatorLockAcquireTimeoutError=a.LockAcquireTimeoutError=a.internals=void 0;a.navigatorLock=async function(G,E,M){a.internals.debug&&console.log(\"@supabase/gotrue-js: navigatorLock: acquire lock\",G,E);const d=new globalThis.AbortController;E>0&&setTimeout(()=>{d.abort();a.internals.debug&&console.log(\"@supabase/gotrue-js: navigatorLock acquire timed out\",G)},E);await Promise.resolve();\ntry{return await globalThis.navigator.locks.request(G,E===0?{mode:\"exclusive\",ifAvailable:!0}:{mode:\"exclusive\",signal:d.signal},async K=>{if(K){a.internals.debug&&console.log(\"@supabase/gotrue-js: navigatorLock: acquired\",G,K.name);try{return await M()}finally{a.internals.debug&&console.log(\"@supabase/gotrue-js: navigatorLock: released\",G,K.name)}}else{if(E===0)throw a.internals.debug&&console.log(\"@supabase/gotrue-js: navigatorLock: not immediately available\",G),new q(`Acquiring an exclusive Navigator LockManager lock \"${G}\" immediately failed`);\nif(a.internals.debug)try{const p=await globalThis.navigator.locks.query();console.log(\"@supabase/gotrue-js: Navigator LockManager state\",JSON.stringify(p,null,\"  \"))}catch(p){console.warn(\"@supabase/gotrue-js: Error when querying Navigator LockManager state\",p)}console.warn(\"@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\");\nreturn await M()}})}catch(K){if((K===null||K===void 0?void 0:K.name)===\"AbortError\")throw new q(`Acquiring an exclusive Navigator LockManager lock \"${G}\" timed out waiting ${E}ms`);throw K;}};a.processLock=async function(G,E,M){var d;const K=(d=C[G])!==null&&d!==void 0?d:Promise.resolve(),p=(async()=>{try{return await K,null}catch(y){return null}})(),k=(async()=>{let y=null;try{const v=E>=0?new Promise((z,J)=>{y=setTimeout(()=>{console.warn(`@supabase/gotrue-js: Lock \"${G}\" acquisition timed out after ${E}ms. `+\n\"This may be caused by another operation holding the lock. Consider increasing lockAcquireTimeout or checking for stuck operations.\");J(new D(`Acquiring process lock with name \"${G}\" timed out`))},E)}):null;await Promise.race([p,v].filter(z=>z));y!==null&&clearTimeout(y)}catch(v){if(y!==null&&clearTimeout(y),v&&v.isAcquireTimeout)throw v;}return await M()})();C[G]=(async()=>{try{return await k}catch(y){if(y&&y.isAcquireTimeout){try{await K}catch(v){}return null}throw y;}})();return await k};S=S(40);\na.internals={debug:!!(globalThis&&(0,S.supportsLocalStorage)()&&globalThis.localStorage&&globalThis.localStorage.getItem(\"supabase.gotrue-js.locks.debug\")===\"true\")};class I extends Error{constructor(G){super(G);this.isAcquireTimeout=!0}}a.LockAcquireTimeoutError=I;class q extends I{}a.NavigatorLockAcquireTimeoutError=q;class D extends I{}a.ProcessLockAcquireTimeoutError=D;const C={}}","~:source","shadow$provide[45] = function(require,module,exports) {\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ProcessLockAcquireTimeoutError = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = exports.internals = void 0;\r\nexports.navigatorLock = navigatorLock;\r\nexports.processLock = processLock;\r\nconst helpers_1 = require(\"./helpers\");\r\n/**\r\n * @experimental\r\n */\r\nexports.internals = {\r\n    /**\r\n     * @experimental\r\n     */\r\n    debug: !!(globalThis &&\r\n        (0, helpers_1.supportsLocalStorage)() &&\r\n        globalThis.localStorage &&\r\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\r\n};\r\n/**\r\n * An error thrown when a lock cannot be acquired after some amount of time.\r\n *\r\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\r\n *\r\n * @example\r\n * ```ts\r\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\r\n *\r\n * class CustomLockError extends LockAcquireTimeoutError {\r\n *   constructor() {\r\n *     super('Lock timed out')\r\n *   }\r\n * }\r\n * ```\r\n */\r\nclass LockAcquireTimeoutError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.isAcquireTimeout = true;\r\n    }\r\n}\r\nexports.LockAcquireTimeoutError = LockAcquireTimeoutError;\r\n/**\r\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\r\n *\r\n * @example\r\n * ```ts\r\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\r\n *\r\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\r\n * ```\r\n */\r\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\r\n}\r\nexports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;\r\n/**\r\n * Error thrown when the process-level lock helper cannot acquire a lock.\r\n *\r\n * @example\r\n * ```ts\r\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\r\n *\r\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\r\n * ```\r\n */\r\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\r\n}\r\nexports.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;\r\n/**\r\n * Implements a global exclusive lock using the Navigator LockManager API. It\r\n * is available on all browsers released after 2022-03-15 with Safari being the\r\n * last one to release support. If the API is not available, this function will\r\n * throw. Make sure you check availablility before configuring {@link\r\n * GoTrueClient}.\r\n *\r\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\r\n * local storage item to `true`.\r\n *\r\n * Internals:\r\n *\r\n * Since the LockManager API does not preserve stack traces for the async\r\n * function passed in the `request` method, a trick is used where acquiring the\r\n * lock releases a previously started promise to run the operation in the `fn`\r\n * function. The lock waits for that promise to finish (with or without error),\r\n * while the function will finally wait for the result anyway.\r\n *\r\n * @param name Name of the lock to be acquired.\r\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\r\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\r\n *                       will time out after so many milliseconds. An error is\r\n *                       a timeout if it has `isAcquireTimeout` set to true.\r\n * @param fn The operation to run once the lock is acquired.\r\n * @example\r\n * ```ts\r\n * await navigatorLock('sync-user', 1000, async () => {\r\n *   await refreshSession()\r\n * })\r\n * ```\r\n */\r\nasync function navigatorLock(name, acquireTimeout, fn) {\r\n    if (exports.internals.debug) {\r\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\r\n    }\r\n    const abortController = new globalThis.AbortController();\r\n    if (acquireTimeout > 0) {\r\n        setTimeout(() => {\r\n            abortController.abort();\r\n            if (exports.internals.debug) {\r\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\r\n            }\r\n        }, acquireTimeout);\r\n    }\r\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\r\n    // Wrapping with await Promise.resolve() is done as some libraries like zone.js\r\n    // patch the Promise object to track execution context. We use await instead of\r\n    // .then() to avoid Firefox content script security errors where accessing .then()\r\n    // on cross-context promises is forbidden.\r\n    await Promise.resolve();\r\n    try {\r\n        return await globalThis.navigator.locks.request(name, acquireTimeout === 0\r\n            ? {\r\n                mode: 'exclusive',\r\n                ifAvailable: true,\r\n            }\r\n            : {\r\n                mode: 'exclusive',\r\n                signal: abortController.signal,\r\n            }, async (lock) => {\r\n            if (lock) {\r\n                if (exports.internals.debug) {\r\n                    console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\r\n                }\r\n                try {\r\n                    return await fn();\r\n                }\r\n                finally {\r\n                    if (exports.internals.debug) {\r\n                        console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (acquireTimeout === 0) {\r\n                    if (exports.internals.debug) {\r\n                        console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\r\n                    }\r\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\r\n                }\r\n                else {\r\n                    if (exports.internals.debug) {\r\n                        try {\r\n                            const result = await globalThis.navigator.locks.query();\r\n                            console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\r\n                        }\r\n                        catch (e) {\r\n                            console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\r\n                        }\r\n                    }\r\n                    // Browser is not following the Navigator LockManager spec, it\r\n                    // returned a null lock when we didn't use ifAvailable. So we can\r\n                    // pretend the lock is acquired in the name of backward compatibility\r\n                    // and user experience and just run the function.\r\n                    console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\r\n                    return await fn();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        // When the AbortController times out, navigator.locks.request rejects with\r\n        // a DOMException named 'AbortError'. Convert this to NavigatorLockAcquireTimeoutError\r\n        // so callers can check error.isAcquireTimeout as documented.\r\n        if ((e === null || e === void 0 ? void 0 : e.name) === 'AbortError') {\r\n            throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" timed out waiting ${acquireTimeout}ms`);\r\n        }\r\n        throw e;\r\n    }\r\n}\r\nconst PROCESS_LOCKS = {};\r\n/**\r\n * Implements a global exclusive lock that works only in the current process.\r\n * Useful for environments like React Native or other non-browser\r\n * single-process (i.e. no concept of \"tabs\") environments.\r\n *\r\n * Use {@link #navigatorLock} in browser environments.\r\n *\r\n * @param name Name of the lock to be acquired.\r\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\r\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\r\n *                       will time out after so many milliseconds. An error is\r\n *                       a timeout if it has `isAcquireTimeout` set to true.\r\n * @param fn The operation to run once the lock is acquired.\r\n * @example\r\n * ```ts\r\n * await processLock('migrate', 5000, async () => {\r\n *   await runMigration()\r\n * })\r\n * ```\r\n */\r\nasync function processLock(name, acquireTimeout, fn) {\r\n    var _a;\r\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\r\n    // Wrap previousOperation to handle errors without using .catch()\r\n    // This avoids Firefox content script security errors\r\n    const previousOperationHandled = (async () => {\r\n        try {\r\n            await previousOperation;\r\n            return null;\r\n        }\r\n        catch (e) {\r\n            // ignore error of previous operation that we're waiting to finish\r\n            return null;\r\n        }\r\n    })();\r\n    const currentOperation = (async () => {\r\n        let timeoutId = null;\r\n        try {\r\n            // Wait for either previous operation or timeout\r\n            const timeoutPromise = acquireTimeout >= 0\r\n                ? new Promise((_, reject) => {\r\n                    timeoutId = setTimeout(() => {\r\n                        console.warn(`@supabase/gotrue-js: Lock \"${name}\" acquisition timed out after ${acquireTimeout}ms. ` +\r\n                            'This may be caused by another operation holding the lock. ' +\r\n                            'Consider increasing lockAcquireTimeout or checking for stuck operations.');\r\n                        reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \"${name}\" timed out`));\r\n                    }, acquireTimeout);\r\n                })\r\n                : null;\r\n            await Promise.race([previousOperationHandled, timeoutPromise].filter((x) => x));\r\n            // If we reach here, previousOperationHandled won the race\r\n            // Clear the timeout to prevent false warnings\r\n            if (timeoutId !== null) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Clear the timeout on error path as well\r\n            if (timeoutId !== null) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            // Re-throw timeout errors, ignore others\r\n            if (e && e.isAcquireTimeout) {\r\n                throw e;\r\n            }\r\n            // Fall through to run fn() - previous operation finished with error\r\n        }\r\n        // Previous operations finished and we didn't get a race on the acquire\r\n        // timeout, so the current operation can finally start\r\n        return await fn();\r\n    })();\r\n    PROCESS_LOCKS[name] = (async () => {\r\n        try {\r\n            return await currentOperation;\r\n        }\r\n        catch (e) {\r\n            if (e && e.isAcquireTimeout) {\r\n                // if the current operation timed out, it doesn't mean that the previous\r\n                // operation finished, so we need continue waiting for it to finish\r\n                try {\r\n                    await previousOperation;\r\n                }\r\n                catch (prevError) {\r\n                    // Ignore previous operation errors\r\n                }\r\n                return null;\r\n            }\r\n            throw e;\r\n        }\r\n    })();\r\n    // finally wait for the current operation to finish successfully, with an\r\n    // error or with an acquire timeout error\r\n    return await currentOperation;\r\n}\r\n//# sourceMappingURL=locks.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$supabase$auth_js$dist$main$lib$helpers"]],"~:properties",["^5",["isAcquireTimeout","__esModule","navigatorLock","mode","signal","ProcessLockAcquireTimeoutError","value","NavigatorLockAcquireTimeoutError","debug","ifAvailable","processLock","internals","LockAcquireTimeoutError"]],"~:compiled-at",1771869280910,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$auth_js$dist$main$lib$locks.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/auth-js/dist/main/lib/locks.js\"],\n\"sourcesContent\":[\"shadow$provide[45] = function(require,module,exports) {\\n\\\"use strict\\\";\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.ProcessLockAcquireTimeoutError = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = exports.internals = void 0;\\r\\nexports.navigatorLock = navigatorLock;\\r\\nexports.processLock = processLock;\\r\\nconst helpers_1 = require(\\\"./helpers\\\");\\r\\n/**\\r\\n * @experimental\\r\\n */\\r\\nexports.internals = {\\r\\n    /**\\r\\n     * @experimental\\r\\n     */\\r\\n    debug: !!(globalThis &&\\r\\n        (0, helpers_1.supportsLocalStorage)() &&\\r\\n        globalThis.localStorage &&\\r\\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\\r\\n};\\r\\n/**\\r\\n * An error thrown when a lock cannot be acquired after some amount of time.\\r\\n *\\r\\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\\r\\n *\\r\\n * @example\\r\\n * ```ts\\r\\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\\r\\n *\\r\\n * class CustomLockError extends LockAcquireTimeoutError {\\r\\n *   constructor() {\\r\\n *     super('Lock timed out')\\r\\n *   }\\r\\n * }\\r\\n * ```\\r\\n */\\r\\nclass LockAcquireTimeoutError extends Error {\\r\\n    constructor(message) {\\r\\n        super(message);\\r\\n        this.isAcquireTimeout = true;\\r\\n    }\\r\\n}\\r\\nexports.LockAcquireTimeoutError = LockAcquireTimeoutError;\\r\\n/**\\r\\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\\r\\n *\\r\\n * @example\\r\\n * ```ts\\r\\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\\r\\n *\\r\\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\\r\\n * ```\\r\\n */\\r\\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\\r\\n}\\r\\nexports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;\\r\\n/**\\r\\n * Error thrown when the process-level lock helper cannot acquire a lock.\\r\\n *\\r\\n * @example\\r\\n * ```ts\\r\\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\\r\\n *\\r\\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\\r\\n * ```\\r\\n */\\r\\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\\r\\n}\\r\\nexports.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;\\r\\n/**\\r\\n * Implements a global exclusive lock using the Navigator LockManager API. It\\r\\n * is available on all browsers released after 2022-03-15 with Safari being the\\r\\n * last one to release support. If the API is not available, this function will\\r\\n * throw. Make sure you check availablility before configuring {@link\\r\\n * GoTrueClient}.\\r\\n *\\r\\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\\r\\n * local storage item to `true`.\\r\\n *\\r\\n * Internals:\\r\\n *\\r\\n * Since the LockManager API does not preserve stack traces for the async\\r\\n * function passed in the `request` method, a trick is used where acquiring the\\r\\n * lock releases a previously started promise to run the operation in the `fn`\\r\\n * function. The lock waits for that promise to finish (with or without error),\\r\\n * while the function will finally wait for the result anyway.\\r\\n *\\r\\n * @param name Name of the lock to be acquired.\\r\\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\\r\\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\\r\\n *                       will time out after so many milliseconds. An error is\\r\\n *                       a timeout if it has `isAcquireTimeout` set to true.\\r\\n * @param fn The operation to run once the lock is acquired.\\r\\n * @example\\r\\n * ```ts\\r\\n * await navigatorLock('sync-user', 1000, async () => {\\r\\n *   await refreshSession()\\r\\n * })\\r\\n * ```\\r\\n */\\r\\nasync function navigatorLock(name, acquireTimeout, fn) {\\r\\n    if (exports.internals.debug) {\\r\\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\\r\\n    }\\r\\n    const abortController = new globalThis.AbortController();\\r\\n    if (acquireTimeout > 0) {\\r\\n        setTimeout(() => {\\r\\n            abortController.abort();\\r\\n            if (exports.internals.debug) {\\r\\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\\r\\n            }\\r\\n        }, acquireTimeout);\\r\\n    }\\r\\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\\r\\n    // Wrapping with await Promise.resolve() is done as some libraries like zone.js\\r\\n    // patch the Promise object to track execution context. We use await instead of\\r\\n    // .then() to avoid Firefox content script security errors where accessing .then()\\r\\n    // on cross-context promises is forbidden.\\r\\n    await Promise.resolve();\\r\\n    try {\\r\\n        return await globalThis.navigator.locks.request(name, acquireTimeout === 0\\r\\n            ? {\\r\\n                mode: 'exclusive',\\r\\n                ifAvailable: true,\\r\\n            }\\r\\n            : {\\r\\n                mode: 'exclusive',\\r\\n                signal: abortController.signal,\\r\\n            }, async (lock) => {\\r\\n            if (lock) {\\r\\n                if (exports.internals.debug) {\\r\\n                    console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\\r\\n                }\\r\\n                try {\\r\\n                    return await fn();\\r\\n                }\\r\\n                finally {\\r\\n                    if (exports.internals.debug) {\\r\\n                        console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                if (acquireTimeout === 0) {\\r\\n                    if (exports.internals.debug) {\\r\\n                        console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\\r\\n                    }\\r\\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \\\"${name}\\\" immediately failed`);\\r\\n                }\\r\\n                else {\\r\\n                    if (exports.internals.debug) {\\r\\n                        try {\\r\\n                            const result = await globalThis.navigator.locks.query();\\r\\n                            console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\\r\\n                        }\\r\\n                        catch (e) {\\r\\n                            console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\\r\\n                        }\\r\\n                    }\\r\\n                    // Browser is not following the Navigator LockManager spec, it\\r\\n                    // returned a null lock when we didn't use ifAvailable. So we can\\r\\n                    // pretend the lock is acquired in the name of backward compatibility\\r\\n                    // and user experience and just run the function.\\r\\n                    console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\\r\\n                    return await fn();\\r\\n                }\\r\\n            }\\r\\n        });\\r\\n    }\\r\\n    catch (e) {\\r\\n        // When the AbortController times out, navigator.locks.request rejects with\\r\\n        // a DOMException named 'AbortError'. Convert this to NavigatorLockAcquireTimeoutError\\r\\n        // so callers can check error.isAcquireTimeout as documented.\\r\\n        if ((e === null || e === void 0 ? void 0 : e.name) === 'AbortError') {\\r\\n            throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \\\"${name}\\\" timed out waiting ${acquireTimeout}ms`);\\r\\n        }\\r\\n        throw e;\\r\\n    }\\r\\n}\\r\\nconst PROCESS_LOCKS = {};\\r\\n/**\\r\\n * Implements a global exclusive lock that works only in the current process.\\r\\n * Useful for environments like React Native or other non-browser\\r\\n * single-process (i.e. no concept of \\\"tabs\\\") environments.\\r\\n *\\r\\n * Use {@link #navigatorLock} in browser environments.\\r\\n *\\r\\n * @param name Name of the lock to be acquired.\\r\\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\\r\\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\\r\\n *                       will time out after so many milliseconds. An error is\\r\\n *                       a timeout if it has `isAcquireTimeout` set to true.\\r\\n * @param fn The operation to run once the lock is acquired.\\r\\n * @example\\r\\n * ```ts\\r\\n * await processLock('migrate', 5000, async () => {\\r\\n *   await runMigration()\\r\\n * })\\r\\n * ```\\r\\n */\\r\\nasync function processLock(name, acquireTimeout, fn) {\\r\\n    var _a;\\r\\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\\r\\n    // Wrap previousOperation to handle errors without using .catch()\\r\\n    // This avoids Firefox content script security errors\\r\\n    const previousOperationHandled = (async () => {\\r\\n        try {\\r\\n            await previousOperation;\\r\\n            return null;\\r\\n        }\\r\\n        catch (e) {\\r\\n            // ignore error of previous operation that we're waiting to finish\\r\\n            return null;\\r\\n        }\\r\\n    })();\\r\\n    const currentOperation = (async () => {\\r\\n        let timeoutId = null;\\r\\n        try {\\r\\n            // Wait for either previous operation or timeout\\r\\n            const timeoutPromise = acquireTimeout >= 0\\r\\n                ? new Promise((_, reject) => {\\r\\n                    timeoutId = setTimeout(() => {\\r\\n                        console.warn(`@supabase/gotrue-js: Lock \\\"${name}\\\" acquisition timed out after ${acquireTimeout}ms. ` +\\r\\n                            'This may be caused by another operation holding the lock. ' +\\r\\n                            'Consider increasing lockAcquireTimeout or checking for stuck operations.');\\r\\n                        reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \\\"${name}\\\" timed out`));\\r\\n                    }, acquireTimeout);\\r\\n                })\\r\\n                : null;\\r\\n            await Promise.race([previousOperationHandled, timeoutPromise].filter((x) => x));\\r\\n            // If we reach here, previousOperationHandled won the race\\r\\n            // Clear the timeout to prevent false warnings\\r\\n            if (timeoutId !== null) {\\r\\n                clearTimeout(timeoutId);\\r\\n            }\\r\\n        }\\r\\n        catch (e) {\\r\\n            // Clear the timeout on error path as well\\r\\n            if (timeoutId !== null) {\\r\\n                clearTimeout(timeoutId);\\r\\n            }\\r\\n            // Re-throw timeout errors, ignore others\\r\\n            if (e && e.isAcquireTimeout) {\\r\\n                throw e;\\r\\n            }\\r\\n            // Fall through to run fn() - previous operation finished with error\\r\\n        }\\r\\n        // Previous operations finished and we didn't get a race on the acquire\\r\\n        // timeout, so the current operation can finally start\\r\\n        return await fn();\\r\\n    })();\\r\\n    PROCESS_LOCKS[name] = (async () => {\\r\\n        try {\\r\\n            return await currentOperation;\\r\\n        }\\r\\n        catch (e) {\\r\\n            if (e && e.isAcquireTimeout) {\\r\\n                // if the current operation timed out, it doesn't mean that the previous\\r\\n                // operation finished, so we need continue waiting for it to finish\\r\\n                try {\\r\\n                    await previousOperation;\\r\\n                }\\r\\n                catch (prevError) {\\r\\n                    // Ignore previous operation errors\\r\\n                }\\r\\n                return null;\\r\\n            }\\r\\n            throw e;\\r\\n        }\\r\\n    })();\\r\\n    // finally wait for the current operation to finish successfully, with an\\r\\n    // error or with an acquire timeout error\\r\\n    return await currentOperation;\\r\\n}\\r\\n//# sourceMappingURL=locks.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"ProcessLockAcquireTimeoutError\",\"NavigatorLockAcquireTimeoutError\",\"LockAcquireTimeoutError\",\"internals\",\"navigatorLock\",\"name\",\"acquireTimeout\",\"fn\",\"debug\",\"console\",\"log\",\"abortController\",\"globalThis\",\"AbortController\",\"setTimeout\",\"abort\",\"Promise\",\"resolve\",\"navigator\",\"locks\",\"request\",\"mode\",\"ifAvailable\",\"signal\",\"lock\",\"result\",\"query\",\"JSON\",\"stringify\",\"e\",\"warn\",\"processLock\",\"_a\",\"previousOperation\",\"PROCESS_LOCKS\",\"previousOperationHandled\",\"currentOperation\",\"timeoutId\",\"timeoutPromise\",\"_\",\"reject\",\"race\",\"filter\",\"x\",\"clearTimeout\",\"isAcquireTimeout\",\"prevError\",\"helpers_1\",\"supportsLocalStorage\",\"localStorage\",\"getItem\",\"Error\",\"constructor\",\"message\"]\n}\n"]