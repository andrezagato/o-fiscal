["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/auth-js/dist/main/lib/fetch.js"],"~:js","shadow$provide[41]=function(I,R,a){async function G(k){var f;if(!(0,y.looksLikeFetchResponse)(k))throw new F.AuthRetryableFetchError(b(k),0);if(D.includes(k.status))throw new F.AuthRetryableFetchError(b(k),k.status);let t;try{t=await k.json()}catch(A){throw new F.AuthUnknownError(b(A),A);}let n=void 0;const v=(0,y.parseResponseAPIVersion)(k);v&&v.getTime()>=z.API_VERSIONS[\"2024-01-01\"].timestamp&&typeof t===\"object\"&&t&&typeof t.code===\"string\"?n=t.code:typeof t===\"object\"&&t&&typeof t.error_code===\n\"string\"&&(n=t.error_code);if(n){if(n===\"weak_password\")throw new F.AuthWeakPasswordError(b(t),k.status,((f=t.weak_password)===null||f===void 0?void 0:f.reasons)||[]);if(n===\"session_not_found\")throw new F.AuthSessionMissingError;}else if(typeof t===\"object\"&&t&&typeof t.weak_password===\"object\"&&t.weak_password&&Array.isArray(t.weak_password.reasons)&&t.weak_password.reasons.length&&t.weak_password.reasons.reduce((A,h)=>A&&typeof h===\"string\",!0))throw new F.AuthWeakPasswordError(b(t),k.status,t.weak_password.reasons);\nthrow new F.AuthApiError(b(t),k.status||500,n);}async function l(k,f,t,n,v,A){{const m={method:f,headers:(n===null||n===void 0?void 0:n.headers)||{}};f===\"GET\"?f=m:(m.headers=Object.assign({\"Content-Type\":\"application/json;charset\\x3dUTF-8\"},n===null||n===void 0?void 0:n.headers),m.body=JSON.stringify(A),f=Object.assign(Object.assign({},m),v))}let h;try{h=await k(t,Object.assign({},f))}catch(m){throw console.error(m),new F.AuthRetryableFetchError(b(m),0);}h.ok||await G(h);if(n===null||n===void 0?\n0:n.noResolveJson)return h;try{return await h.json()}catch(m){await G(m)}}function x(k){var f;let t=null;k.access_token&&k.refresh_token&&k.expires_in&&(t=Object.assign({},k),k.expires_at||(t.expires_at=(0,y.expiresAt)(k.expires_in)));const n=(f=k.user)!==null&&f!==void 0?f:k;return{data:{session:t,user:n},error:null}}Object.defineProperty(a,\"__esModule\",{value:!0});a.handleError=G;a._request=async function(k,f,t,n){var v;const A=Object.assign({},n===null||n===void 0?void 0:n.headers);A[z.API_VERSION_HEADER_NAME]||\n(A[z.API_VERSION_HEADER_NAME]=z.API_VERSIONS[\"2024-01-01\"].name);if(n===null||n===void 0?0:n.jwt)A.Authorization=`Bearer ${n.jwt}`;const h=(v=n===null||n===void 0?void 0:n.query)!==null&&v!==void 0?v:{};if(n===null||n===void 0?0:n.redirectTo)h.redirect_to=n.redirectTo;v=Object.keys(h).length?\"?\"+(new URLSearchParams(h)).toString():\"\";k=await l(k,f,t+v,{headers:A,noResolveJson:n===null||n===void 0?void 0:n.noResolveJson},{},n===null||n===void 0?void 0:n.body);return(n===null||n===void 0?0:n.xform)?\nn===null||n===void 0?void 0:n.xform(k):{data:Object.assign({},k),error:null}};a._sessionResponse=x;a._sessionResponsePassword=function(k){const f=x(k);!f.error&&k.weak_password&&typeof k.weak_password===\"object\"&&Array.isArray(k.weak_password.reasons)&&k.weak_password.reasons.length&&k.weak_password.message&&typeof k.weak_password.message===\"string\"&&k.weak_password.reasons.reduce((t,n)=>t&&typeof n===\"string\",!0)&&(f.data.weak_password=k.weak_password);return f};a._userResponse=function(k){var f;\nreturn{data:{user:(f=k.user)!==null&&f!==void 0?f:k},error:null}};a._ssoResponse=function(k){return{data:k,error:null}};a._generateLinkResponse=function(k){const {action_link:f,email_otp:t,hashed_token:n,redirect_to:v,verification_type:A}=k;var h=w.__rest(k,[\"action_link\",\"email_otp\",\"hashed_token\",\"redirect_to\",\"verification_type\"]);k={action_link:f,email_otp:t,hashed_token:n,redirect_to:v,verification_type:A};h=Object.assign({},h);return{data:{properties:k,user:h},error:null}};a._noResolveJsonResponse=\nfunction(k){return k};const w=I(14),z=I(37),y=I(40),F=I(38),b=k=>k.msg||k.message||k.error_description||k.error||JSON.stringify(k),D=[502,503,504]}","~:source","shadow$provide[41] = function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.handleError = handleError;\nexports._request = _request;\nexports._sessionResponse = _sessionResponse;\nexports._sessionResponsePassword = _sessionResponsePassword;\nexports._userResponse = _userResponse;\nexports._ssoResponse = _ssoResponse;\nexports._generateLinkResponse = _generateLinkResponse;\nexports._noResolveJsonResponse = _noResolveJsonResponse;\nconst tslib_1 = require(\"tslib\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\nconst errors_1 = require(\"./errors\");\nconst _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [502, 503, 504];\nasync function handleError(error) {\n    var _a;\n    if (!(0, helpers_1.looksLikeFetchResponse)(error)) {\n        throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    }\n    catch (e) {\n        throw new errors_1.AuthUnknownError(_getErrorMessage(e), e);\n    }\n    let errorCode = undefined;\n    const responseAPIVersion = (0, helpers_1.parseResponseAPIVersion)(error);\n    if (responseAPIVersion &&\n        responseAPIVersion.getTime() >= constants_1.API_VERSIONS['2024-01-01'].timestamp &&\n        typeof data === 'object' &&\n        data &&\n        typeof data.code === 'string') {\n        errorCode = data.code;\n    }\n    else if (typeof data === 'object' && data && typeof data.error_code === 'string') {\n        errorCode = data.error_code;\n    }\n    if (!errorCode) {\n        // Legacy support for weak password errors, when there were no error codes\n        if (typeof data === 'object' &&\n            data &&\n            typeof data.weak_password === 'object' &&\n            data.weak_password &&\n            Array.isArray(data.weak_password.reasons) &&\n            data.weak_password.reasons.length &&\n            data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {\n            throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\n        }\n    }\n    else if (errorCode === 'weak_password') {\n        throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\n    }\n    else if (errorCode === 'session_not_found') {\n        // The `session_id` inside the JWT does not correspond to a row in the\n        // `sessions` table. This usually means the user has signed out, has been\n        // deleted, or their session has somehow been terminated.\n        throw new errors_1.AuthSessionMissingError();\n    }\n    throw new errors_1.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\n}\nconst _getRequestParams = (method, options, parameters, body) => {\n    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n    if (method === 'GET') {\n        return params;\n    }\n    params.headers = Object.assign({ 'Content-Type': 'application/json;charset=UTF-8' }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nasync function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (!headers[constants_1.API_VERSION_HEADER_NAME]) {\n        headers[constants_1.API_VERSION_HEADER_NAME] = constants_1.API_VERSIONS['2024-01-01'].name;\n    }\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers['Authorization'] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs['redirect_to'] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : '';\n    const data = await _handleRequest(fetcher, method, url + queryString, {\n        headers,\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson,\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, Object.assign({}, requestParams));\n    }\n    catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new errors_1.AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    }\n    catch (e) {\n        await handleError(e);\n    }\n}\nfunction _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return { data: { session, user }, error: null };\n}\nfunction _sessionResponsePassword(data) {\n    const response = _sessionResponse(data);\n    if (!response.error &&\n        data.weak_password &&\n        typeof data.weak_password === 'object' &&\n        Array.isArray(data.weak_password.reasons) &&\n        data.weak_password.reasons.length &&\n        data.weak_password.message &&\n        typeof data.weak_password.message === 'string' &&\n        data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {\n        response.data.weak_password = data.weak_password;\n    }\n    return response;\n}\nfunction _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return { data: { user }, error: null };\n}\nfunction _ssoResponse(data) {\n    return { data, error: null };\n}\nfunction _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = tslib_1.__rest(data, [\"action_link\", \"email_otp\", \"hashed_token\", \"redirect_to\", \"verification_type\"]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type,\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user,\n        },\n        error: null,\n    };\n}\nfunction _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */\nfunction hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n}\n//# sourceMappingURL=fetch.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$supabase$auth_js$dist$main$lib$constants","~$module$node_modules$tslib$tslib","~$shadow.js","~$module$node_modules$$supabase$auth_js$dist$main$lib$errors","~$module$node_modules$$supabase$auth_js$dist$main$lib$helpers"]],"~:properties",["^5",["properties","hashed_token","noResolveJson","body","action_link","handleError","method","user","__esModule","_sessionResponsePassword","error","expires_at","_noResolveJsonResponse","redirect_to","verification_type","_request","value","_ssoResponse","_sessionResponse","weak_password","session","email_otp","data","_userResponse","_generateLinkResponse","headers"]],"~:compiled-at",1771725993779,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$auth_js$dist$main$lib$fetch.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/auth-js/dist/main/lib/fetch.js\"],\n\"sourcesContent\":[\"shadow$provide[41] = function(require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.handleError = handleError;\\nexports._request = _request;\\nexports._sessionResponse = _sessionResponse;\\nexports._sessionResponsePassword = _sessionResponsePassword;\\nexports._userResponse = _userResponse;\\nexports._ssoResponse = _ssoResponse;\\nexports._generateLinkResponse = _generateLinkResponse;\\nexports._noResolveJsonResponse = _noResolveJsonResponse;\\nconst tslib_1 = require(\\\"tslib\\\");\\nconst constants_1 = require(\\\"./constants\\\");\\nconst helpers_1 = require(\\\"./helpers\\\");\\nconst errors_1 = require(\\\"./errors\\\");\\nconst _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\\nconst NETWORK_ERROR_CODES = [502, 503, 504];\\nasync function handleError(error) {\\n    var _a;\\n    if (!(0, helpers_1.looksLikeFetchResponse)(error)) {\\n        throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), 0);\\n    }\\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\\n        // status in 500...599 range - server had an error, request might be retryed.\\n        throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), error.status);\\n    }\\n    let data;\\n    try {\\n        data = await error.json();\\n    }\\n    catch (e) {\\n        throw new errors_1.AuthUnknownError(_getErrorMessage(e), e);\\n    }\\n    let errorCode = undefined;\\n    const responseAPIVersion = (0, helpers_1.parseResponseAPIVersion)(error);\\n    if (responseAPIVersion &&\\n        responseAPIVersion.getTime() >= constants_1.API_VERSIONS['2024-01-01'].timestamp &&\\n        typeof data === 'object' &&\\n        data &&\\n        typeof data.code === 'string') {\\n        errorCode = data.code;\\n    }\\n    else if (typeof data === 'object' && data && typeof data.error_code === 'string') {\\n        errorCode = data.error_code;\\n    }\\n    if (!errorCode) {\\n        // Legacy support for weak password errors, when there were no error codes\\n        if (typeof data === 'object' &&\\n            data &&\\n            typeof data.weak_password === 'object' &&\\n            data.weak_password &&\\n            Array.isArray(data.weak_password.reasons) &&\\n            data.weak_password.reasons.length &&\\n            data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {\\n            throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\\n        }\\n    }\\n    else if (errorCode === 'weak_password') {\\n        throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\\n    }\\n    else if (errorCode === 'session_not_found') {\\n        // The `session_id` inside the JWT does not correspond to a row in the\\n        // `sessions` table. This usually means the user has signed out, has been\\n        // deleted, or their session has somehow been terminated.\\n        throw new errors_1.AuthSessionMissingError();\\n    }\\n    throw new errors_1.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\\n}\\nconst _getRequestParams = (method, options, parameters, body) => {\\n    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\\n    if (method === 'GET') {\\n        return params;\\n    }\\n    params.headers = Object.assign({ 'Content-Type': 'application/json;charset=UTF-8' }, options === null || options === void 0 ? void 0 : options.headers);\\n    params.body = JSON.stringify(body);\\n    return Object.assign(Object.assign({}, params), parameters);\\n};\\nasync function _request(fetcher, method, url, options) {\\n    var _a;\\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\\n    if (!headers[constants_1.API_VERSION_HEADER_NAME]) {\\n        headers[constants_1.API_VERSION_HEADER_NAME] = constants_1.API_VERSIONS['2024-01-01'].name;\\n    }\\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\\n        headers['Authorization'] = `Bearer ${options.jwt}`;\\n    }\\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\\n        qs['redirect_to'] = options.redirectTo;\\n    }\\n    const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : '';\\n    const data = await _handleRequest(fetcher, method, url + queryString, {\\n        headers,\\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson,\\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };\\n}\\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\\n    const requestParams = _getRequestParams(method, options, parameters, body);\\n    let result;\\n    try {\\n        result = await fetcher(url, Object.assign({}, requestParams));\\n    }\\n    catch (e) {\\n        console.error(e);\\n        // fetch failed, likely due to a network or CORS error\\n        throw new errors_1.AuthRetryableFetchError(_getErrorMessage(e), 0);\\n    }\\n    if (!result.ok) {\\n        await handleError(result);\\n    }\\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\\n        return result;\\n    }\\n    try {\\n        return await result.json();\\n    }\\n    catch (e) {\\n        await handleError(e);\\n    }\\n}\\nfunction _sessionResponse(data) {\\n    var _a;\\n    let session = null;\\n    if (hasSession(data)) {\\n        session = Object.assign({}, data);\\n        if (!data.expires_at) {\\n            session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);\\n        }\\n    }\\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\\n    return { data: { session, user }, error: null };\\n}\\nfunction _sessionResponsePassword(data) {\\n    const response = _sessionResponse(data);\\n    if (!response.error &&\\n        data.weak_password &&\\n        typeof data.weak_password === 'object' &&\\n        Array.isArray(data.weak_password.reasons) &&\\n        data.weak_password.reasons.length &&\\n        data.weak_password.message &&\\n        typeof data.weak_password.message === 'string' &&\\n        data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {\\n        response.data.weak_password = data.weak_password;\\n    }\\n    return response;\\n}\\nfunction _userResponse(data) {\\n    var _a;\\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\\n    return { data: { user }, error: null };\\n}\\nfunction _ssoResponse(data) {\\n    return { data, error: null };\\n}\\nfunction _generateLinkResponse(data) {\\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = tslib_1.__rest(data, [\\\"action_link\\\", \\\"email_otp\\\", \\\"hashed_token\\\", \\\"redirect_to\\\", \\\"verification_type\\\"]);\\n    const properties = {\\n        action_link,\\n        email_otp,\\n        hashed_token,\\n        redirect_to,\\n        verification_type,\\n    };\\n    const user = Object.assign({}, rest);\\n    return {\\n        data: {\\n            properties,\\n            user,\\n        },\\n        error: null,\\n    };\\n}\\nfunction _noResolveJsonResponse(data) {\\n    return data;\\n}\\n/**\\n * hasSession checks if the response object contains a valid session\\n * @param data A response object\\n * @returns true if a session is in the response\\n */\\nfunction hasSession(data) {\\n    return data.access_token && data.refresh_token && data.expires_in;\\n}\\n//# sourceMappingURL=fetch.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"handleError\",\"error\",\"_a\",\"helpers_1\",\"looksLikeFetchResponse\",\"errors_1\",\"AuthRetryableFetchError\",\"_getErrorMessage\",\"NETWORK_ERROR_CODES\",\"includes\",\"status\",\"data\",\"json\",\"e\",\"AuthUnknownError\",\"errorCode\",\"undefined\",\"responseAPIVersion\",\"parseResponseAPIVersion\",\"getTime\",\"constants_1\",\"API_VERSIONS\",\"timestamp\",\"code\",\"error_code\",\"AuthWeakPasswordError\",\"weak_password\",\"reasons\",\"AuthSessionMissingError\",\"Array\",\"isArray\",\"length\",\"reduce\",\"a\",\"i\",\"AuthApiError\",\"_handleRequest\",\"fetcher\",\"method\",\"url\",\"options\",\"parameters\",\"body\",\"params\",\"headers\",\"Object\",\"assign\",\"JSON\",\"stringify\",\"result\",\"requestParams\",\"console\",\"ok\",\"noResolveJson\",\"_sessionResponse\",\"session\",\"access_token\",\"refresh_token\",\"expires_in\",\"expires_at\",\"expiresAt\",\"user\",\"defineProperty\",\"value\",\"_request\",\"API_VERSION_HEADER_NAME\",\"name\",\"jwt\",\"qs\",\"query\",\"redirectTo\",\"queryString\",\"keys\",\"toString\",\"URLSearchParams\",\"xform\",\"_sessionResponsePassword\",\"response\",\"message\",\"_userResponse\",\"_ssoResponse\",\"_generateLinkResponse\",\"action_link\",\"email_otp\",\"hashed_token\",\"redirect_to\",\"verification_type\",\"rest\",\"tslib_1\",\"__rest\",\"properties\",\"_noResolveJsonResponse\",\"err\",\"msg\",\"error_description\"]\n}\n"]