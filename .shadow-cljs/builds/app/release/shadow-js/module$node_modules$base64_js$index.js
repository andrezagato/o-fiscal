["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/base64-js/index.js"],"~:js","shadow$provide[32]=function(S,ka,a){function I(G){var E=G.length;if(E%4>0)throw Error(\"Invalid string. Length must be a multiple of 4\");G=G.indexOf(\"\\x3d\");G===-1&&(G=E);return[G,G===E?0:4-G%4]}a.byteLength=function(G){G=I(G);var E=G[1];return(G[0]+E)*3/4-E};a.toByteArray=function(G){var E=I(G);var M=E[0];E=E[1];var d=new C((M+E)*3/4-E),K=0,p=E>0?M-4:M,k;for(k=0;k<p;k+=4)M=D[G.charCodeAt(k)]<<18|D[G.charCodeAt(k+1)]<<12|D[G.charCodeAt(k+2)]<<6|D[G.charCodeAt(k+3)],d[K++]=M>>16&255,d[K++]=M>>8&255,\nd[K++]=M&255;E===2&&(M=D[G.charCodeAt(k)]<<2|D[G.charCodeAt(k+1)]>>4,d[K++]=M&255);E===1&&(M=D[G.charCodeAt(k)]<<10|D[G.charCodeAt(k+1)]<<4|D[G.charCodeAt(k+2)]>>2,d[K++]=M>>8&255,d[K++]=M&255);return d};a.fromByteArray=function(G){for(var E=G.length,M=E%3,d=[],K=0,p=E-M;K<p;K+=16383){for(var k=d,y=k.push,v,z=G,J=K+16383>p?p:K+16383,l=[],t=K;t<J;t+=3)v=(z[t]<<16&16711680)+(z[t+1]<<8&65280)+(z[t+2]&255),l.push(q[v>>18&63]+q[v>>12&63]+q[v>>6&63]+q[v&63]);v=l.join(\"\");y.call(k,v)}M===1?(G=G[E-1],d.push(q[G>>\n2]+q[G<<4&63]+\"\\x3d\\x3d\")):M===2&&(G=(G[E-2]<<8)+G[E-1],d.push(q[G>>10]+q[G>>4&63]+q[G<<2&63]+\"\\x3d\"));return d.join(\"\")};var q=[],D=[],C=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;for(S=0;S<64;++S)q[S]=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[S],D[\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charCodeAt(S)]=S;D[45]=62;D[95]=63}","~:source","shadow$provide[32] = function(require,module,exports) {\n'use strict'\r\n\r\nexports.byteLength = byteLength\r\nexports.toByteArray = toByteArray\r\nexports.fromByteArray = fromByteArray\r\n\r\nvar lookup = []\r\nvar revLookup = []\r\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\nfor (var i = 0, len = code.length; i < len; ++i) {\r\n  lookup[i] = code[i]\r\n  revLookup[code.charCodeAt(i)] = i\r\n}\r\n\r\n// Support decoding URL-safe base64 strings, as Node.js does.\r\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\r\nrevLookup['-'.charCodeAt(0)] = 62\r\nrevLookup['_'.charCodeAt(0)] = 63\r\n\r\nfunction getLens (b64) {\r\n  var len = b64.length\r\n\r\n  if (len % 4 > 0) {\r\n    throw new Error('Invalid string. Length must be a multiple of 4')\r\n  }\r\n\r\n  // Trim off extra bytes after placeholder bytes are found\r\n  // See: https://github.com/beatgammit/base64-js/issues/42\r\n  var validLen = b64.indexOf('=')\r\n  if (validLen === -1) validLen = len\r\n\r\n  var placeHoldersLen = validLen === len\r\n    ? 0\r\n    : 4 - (validLen % 4)\r\n\r\n  return [validLen, placeHoldersLen]\r\n}\r\n\r\n// base64 is 4/3 + up to two characters of the original data\r\nfunction byteLength (b64) {\r\n  var lens = getLens(b64)\r\n  var validLen = lens[0]\r\n  var placeHoldersLen = lens[1]\r\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n}\r\n\r\nfunction _byteLength (b64, validLen, placeHoldersLen) {\r\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n}\r\n\r\nfunction toByteArray (b64) {\r\n  var tmp\r\n  var lens = getLens(b64)\r\n  var validLen = lens[0]\r\n  var placeHoldersLen = lens[1]\r\n\r\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\r\n\r\n  var curByte = 0\r\n\r\n  // if there are placeholders, only get up to the last complete 4 chars\r\n  var len = placeHoldersLen > 0\r\n    ? validLen - 4\r\n    : validLen\r\n\r\n  var i\r\n  for (i = 0; i < len; i += 4) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 18) |\r\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\r\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\r\n      revLookup[b64.charCodeAt(i + 3)]\r\n    arr[curByte++] = (tmp >> 16) & 0xFF\r\n    arr[curByte++] = (tmp >> 8) & 0xFF\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHoldersLen === 2) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 2) |\r\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHoldersLen === 1) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 10) |\r\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\r\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n    arr[curByte++] = (tmp >> 8) & 0xFF\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\nfunction tripletToBase64 (num) {\r\n  return lookup[num >> 18 & 0x3F] +\r\n    lookup[num >> 12 & 0x3F] +\r\n    lookup[num >> 6 & 0x3F] +\r\n    lookup[num & 0x3F]\r\n}\r\n\r\nfunction encodeChunk (uint8, start, end) {\r\n  var tmp\r\n  var output = []\r\n  for (var i = start; i < end; i += 3) {\r\n    tmp =\r\n      ((uint8[i] << 16) & 0xFF0000) +\r\n      ((uint8[i + 1] << 8) & 0xFF00) +\r\n      (uint8[i + 2] & 0xFF)\r\n    output.push(tripletToBase64(tmp))\r\n  }\r\n  return output.join('')\r\n}\r\n\r\nfunction fromByteArray (uint8) {\r\n  var tmp\r\n  var len = uint8.length\r\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n  var parts = []\r\n  var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n  // go through the array every three bytes, we'll deal with trailing stuff later\r\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\r\n  }\r\n\r\n  // pad the end with zeros, but make sure to not forget the extra bytes\r\n  if (extraBytes === 1) {\r\n    tmp = uint8[len - 1]\r\n    parts.push(\r\n      lookup[tmp >> 2] +\r\n      lookup[(tmp << 4) & 0x3F] +\r\n      '=='\r\n    )\r\n  } else if (extraBytes === 2) {\r\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\r\n    parts.push(\r\n      lookup[tmp >> 10] +\r\n      lookup[(tmp >> 4) & 0x3F] +\r\n      lookup[(tmp << 2) & 0x3F] +\r\n      '='\r\n    )\r\n  }\r\n\r\n  return parts.join('')\r\n}\r\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["byteLength","fromByteArray","toByteArray"]],"~:compiled-at",1771869280869,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$base64_js$index.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAe,EAAf,CAAA,CAAqB,QAAQ,CAACC,CAAD,CAASC,EAAT,CAAgBC,CAAhB,CAAyB,CAsBtDC,QAASA,EAAQ,CAACC,CAAD,CAAM,CACrB,IAAIC,EAAMD,CAAIE,CAAAA,MAEd,IAAID,CAAJ,CAAU,CAAV,CAAc,CAAd,CACE,KAAUE,MAAJ,CAAU,gDAAV,CAAN,CAKEC,CAAAA,CAAWJ,CAAIK,CAAAA,OAAJ,CAAY,MAAZ,CACXD,EAAJ,GAAiB,CAAC,CAAlB,GAAqBA,CAArB,CAAgCH,CAAhC,CAMA,OAAO,CAACG,CAAD,CAJeA,CAAAE,GAAaL,CAAbK,CAClB,CADkBA,CAElB,CAFkBA,CAEbF,CAFaE,CAEF,CAEb,CAhBc,CAnBvBR,CAAQS,CAAAA,UAAR,CAuCAA,QAAoB,CAACP,CAAD,CAAM,CACpBQ,CAAAA,CAAOT,CAAA,CAAQC,CAAR,CAEX,KAAIM,EAAkBE,CAAA,CAAK,CAAL,CACtB,QAFeA,CAAAJ,CAAK,CAALA,CAEf,CAAoBE,CAApB,EAAuC,CAAvC,CAA2C,CAA3C,CAAgDA,CAJxB,CAtC1BR,EAAQW,CAAAA,WAAR,CAiDAA,QAAqB,CAACT,CAAD,CAAM,CACzB,IACIQ,EAAOT,CAAA,CAAQC,CAAR,CACPI,KAAAA,EAAWI,CAAA,CAAK,CAAL,CACXF,EAAAA,CAAkBE,CAAA,CAAK,CAAL,CAEtB,KAAIE,EAAM,IAAIC,CAAJ,EAAyBP,CAAzB,CAAmCE,CAAnC,EAT6B,CAS7B,CATiC,CASjC,CAAmCA,CAAnC,CAAV,CAEIM,EAAU,CAFd,CAKIX,EAAMK,CAAA,CAAkB,CAAlB,CACNF,CADM,CACK,CADL,CAENA,CAPJ,CASIS,CACJ,KAAKA,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBZ,CAAhB,CAAqBY,CAArB,EAA0B,CAA1B,CACEC,CAOA,CANGC,CAAA,CAAUf,CAAIgB,CAAAA,UAAJ,CAAeH,CAAf,CAAV,CAMH,EANmC,EAMnC,CALGE,CAAA,CAAUf,CAAIgB,CAAAA,UAAJ,CAAeH,CAAf,CAAmB,CAAnB,CAAV,CAKH,EALuC,EAKvC,CAJGE,CAAA,CAAUf,CAAIgB,CAAAA,UAAJ,CAAeH,CAAf,CAAmB,CAAnB,CAAV,CAIH,EAJuC,CAIvC,CAHEE,CAAA,CAAUf,CAAIgB,CAAAA,UAAJ,CAAeH,CAAf,CAAmB,CAAnB,CAAV,CAGF,CAFAH,CAAA,CAAIE,CAAA,EAAJ,CAEA,CAFkBE,CAElB,EAFyB,EAEzB,CAF+B,GAE/B,CADAJ,CAAA,CAAIE,CAAA,EAAJ,CACA,CADkBE,CAClB,EADyB,CACzB,CAD8B,GAC9B;AAAAJ,CAAA,CAAIE,CAAA,EAAJ,CAAA,CAAiBE,CAAjB,CAAuB,GAGrBR,EAAJ,GAAwB,CAAxB,GACEQ,CAGA,CAFGC,CAAA,CAAUf,CAAIgB,CAAAA,UAAJ,CAAeH,CAAf,CAAV,CAEH,EAFmC,CAEnC,CADGE,CAAA,CAAUf,CAAIgB,CAAAA,UAAJ,CAAeH,CAAf,CAAmB,CAAnB,CAAV,CACH,EADuC,CACvC,CAAAH,CAAA,CAAIE,CAAA,EAAJ,CAAA,CAAiBE,CAAjB,CAAuB,GAJzB,CAOIR,EAAJ,GAAwB,CAAxB,GACEQ,CAKA,CAJGC,CAAA,CAAUf,CAAIgB,CAAAA,UAAJ,CAAeH,CAAf,CAAV,CAIH,EAJmC,EAInC,CAHGE,CAAA,CAAUf,CAAIgB,CAAAA,UAAJ,CAAeH,CAAf,CAAmB,CAAnB,CAAV,CAGH,EAHuC,CAGvC,CAFGE,CAAA,CAAUf,CAAIgB,CAAAA,UAAJ,CAAeH,CAAf,CAAmB,CAAnB,CAAV,CAEH,EAFuC,CAEvC,CADAH,CAAA,CAAIE,CAAA,EAAJ,CACA,CADkBE,CAClB,EADyB,CACzB,CAD8B,GAC9B,CAAAJ,CAAA,CAAIE,CAAA,EAAJ,CAAA,CAAiBE,CAAjB,CAAuB,GANzB,CASA,OAAOJ,EA3CkB,CAhD3BZ,EAAQmB,CAAAA,aAAR,CAkHAA,QAAuB,CAACC,CAAD,CAAQ,CAQ7B,IANA,IAAIjB,EAAMiB,CAAMhB,CAAAA,MAAhB,CACIiB,EAAalB,CAAbkB,CAAmB,CADvB,CAEIC,EAAQ,EAFZ,CAMSP,EAAI,CANb,CAMgBQ,EAAOpB,CAAPoB,CAAaF,CAA7B,CAAyCN,CAAzC,CAA6CQ,CAA7C,CAAmDR,CAAnD,EAHqBS,KAGrB,CAAwE,CAlBxE,IAmBEF,IAAAA,EAAAA,CAAAA,CAAMG,EAANH,CAAMG,CAAAA,IAANH,CAAW,CAAXA,CAAuBF,EAAAA,CAAvBE,CAAiC,EAACP,CAAD,CAJdS,KAIc,CAAuBD,CAAvB,CAA8BA,CAA9B,CAAsCR,CAAtC,CAJdS,KAInBF,CApBEI,EAAS,EAoBXJ,CAnBOP,EAmBuBA,CAnBhC,CAAoBA,CAApB,CAAwBY,CAAxB,CAA6BZ,CAA7B,EAAkC,CAAlC,CACEC,CAIA,EAHII,CAAA,CAAML,CAAN,CAGJ,EAHgB,EAGhB,CAHsB,QAGtB,GAFIK,CAAA,CAAML,CAAN,CAAU,CAAV,CAEJ,EAFoB,CAEpB,CAFyB,KAEzB,GADGK,CAAA,CAAML,CAAN,CAAU,CAAV,CACH,CADkB,GAClB,EAAAW,CAAOD,CAAAA,IAAP,CAdKG,CAAA,CAcuBZ,CAdvB,EAAc,EAAd,CAAmB,EAAnB,CAcL,CAbAY,CAAA,CAa4BZ,CAb5B,EAAc,EAAd,CAAmB,EAAnB,CAaA,CAZAY,CAAA,CAY4BZ,CAZ5B,EAAc,CAAd,CAAkB,EAAlB,CAYA,CAXAY,CAAA,CAW4BZ,CAX5B,CAAa,EAAb,CAWA,CAEF,EAAA,CAAOU,CAAOG,CAAAA,IAAP,CAAY,EAAZ,CAYCJ,EAAN,CAAA,IAAA,CAAAH,CAAA,CAAW,CAAX,CADsE,CAKpED,CAAJ,GAAmB,CAAnB,EACEL,CACA,CADMI,CAAA,CAAMjB,CAAN,CAAY,CAAZ,CACN,CAAAmB,CAAMG,CAAAA,IAAN,CACEG,CAAA,CAAOZ,CAAP;AAAc,CAAd,CADF,CAEEY,CAAA,CAAQZ,CAAR,EAAe,CAAf,CAAoB,EAApB,CAFF,CAGE,UAHF,CAFF,EAOWK,CAPX,GAO0B,CAP1B,GAQEL,CACA,EADOI,CAAA,CAAMjB,CAAN,CAAY,CAAZ,CACP,EADyB,CACzB,EAD8BiB,CAAA,CAAMjB,CAAN,CAAY,CAAZ,CAC9B,CAAAmB,CAAMG,CAAAA,IAAN,CACEG,CAAA,CAAOZ,CAAP,EAAc,EAAd,CADF,CAEEY,CAAA,CAAQZ,CAAR,EAAe,CAAf,CAAoB,EAApB,CAFF,CAGEY,CAAA,CAAQZ,CAAR,EAAe,CAAf,CAAoB,EAApB,CAHF,CAIE,MAJF,CATF,CAiBA,OAAOM,EAAMO,CAAAA,IAAN,CAAW,EAAX,CA9BsB,CAhH/B,KAAID,EAAS,EAAb,CACIX,EAAY,EADhB,CAEIJ,EAAM,MAAOiB,WAAP,GAAsB,WAAtB,CAAoCA,UAApC,CAAiDC,KAG3D,KAAShB,CAAT,CAAa,CAAb,CAAmCA,CAAnC,CAA2BX,EAA3B,CAA4C,EAAEW,CAA9C,CACEa,CAAA,CAAOb,CAAP,CACA,CAHSiB,kEAEG,CAAKjB,CAAL,CACZ,CAAAE,CAAA,CAHSe,kEAGMd,CAAAA,UAAL,CAAgBH,CAAhB,CAAV,CAAA,CAAgCA,CAKlCE,EAAA,CAAU,EAAV,CAAA,CAA+B,EAC/BA,EAAA,CAAU,EAAV,CAAA,CAA+B,EApBuB;\",\n\"sources\":[\"node_modules/base64-js/index.js\"],\n\"sourcesContent\":[\"shadow$provide[32] = function(require,module,exports) {\\n'use strict'\\r\\n\\r\\nexports.byteLength = byteLength\\r\\nexports.toByteArray = toByteArray\\r\\nexports.fromByteArray = fromByteArray\\r\\n\\r\\nvar lookup = []\\r\\nvar revLookup = []\\r\\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\r\\n\\r\\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\r\\nfor (var i = 0, len = code.length; i < len; ++i) {\\r\\n  lookup[i] = code[i]\\r\\n  revLookup[code.charCodeAt(i)] = i\\r\\n}\\r\\n\\r\\n// Support decoding URL-safe base64 strings, as Node.js does.\\r\\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\\r\\nrevLookup['-'.charCodeAt(0)] = 62\\r\\nrevLookup['_'.charCodeAt(0)] = 63\\r\\n\\r\\nfunction getLens (b64) {\\r\\n  var len = b64.length\\r\\n\\r\\n  if (len % 4 > 0) {\\r\\n    throw new Error('Invalid string. Length must be a multiple of 4')\\r\\n  }\\r\\n\\r\\n  // Trim off extra bytes after placeholder bytes are found\\r\\n  // See: https://github.com/beatgammit/base64-js/issues/42\\r\\n  var validLen = b64.indexOf('=')\\r\\n  if (validLen === -1) validLen = len\\r\\n\\r\\n  var placeHoldersLen = validLen === len\\r\\n    ? 0\\r\\n    : 4 - (validLen % 4)\\r\\n\\r\\n  return [validLen, placeHoldersLen]\\r\\n}\\r\\n\\r\\n// base64 is 4/3 + up to two characters of the original data\\r\\nfunction byteLength (b64) {\\r\\n  var lens = getLens(b64)\\r\\n  var validLen = lens[0]\\r\\n  var placeHoldersLen = lens[1]\\r\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\r\\n}\\r\\n\\r\\nfunction _byteLength (b64, validLen, placeHoldersLen) {\\r\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\r\\n}\\r\\n\\r\\nfunction toByteArray (b64) {\\r\\n  var tmp\\r\\n  var lens = getLens(b64)\\r\\n  var validLen = lens[0]\\r\\n  var placeHoldersLen = lens[1]\\r\\n\\r\\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\\r\\n\\r\\n  var curByte = 0\\r\\n\\r\\n  // if there are placeholders, only get up to the last complete 4 chars\\r\\n  var len = placeHoldersLen > 0\\r\\n    ? validLen - 4\\r\\n    : validLen\\r\\n\\r\\n  var i\\r\\n  for (i = 0; i < len; i += 4) {\\r\\n    tmp =\\r\\n      (revLookup[b64.charCodeAt(i)] << 18) |\\r\\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\\r\\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\\r\\n      revLookup[b64.charCodeAt(i + 3)]\\r\\n    arr[curByte++] = (tmp >> 16) & 0xFF\\r\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\r\\n    arr[curByte++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  if (placeHoldersLen === 2) {\\r\\n    tmp =\\r\\n      (revLookup[b64.charCodeAt(i)] << 2) |\\r\\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\\r\\n    arr[curByte++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  if (placeHoldersLen === 1) {\\r\\n    tmp =\\r\\n      (revLookup[b64.charCodeAt(i)] << 10) |\\r\\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\\r\\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\\r\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\r\\n    arr[curByte++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  return arr\\r\\n}\\r\\n\\r\\nfunction tripletToBase64 (num) {\\r\\n  return lookup[num >> 18 & 0x3F] +\\r\\n    lookup[num >> 12 & 0x3F] +\\r\\n    lookup[num >> 6 & 0x3F] +\\r\\n    lookup[num & 0x3F]\\r\\n}\\r\\n\\r\\nfunction encodeChunk (uint8, start, end) {\\r\\n  var tmp\\r\\n  var output = []\\r\\n  for (var i = start; i < end; i += 3) {\\r\\n    tmp =\\r\\n      ((uint8[i] << 16) & 0xFF0000) +\\r\\n      ((uint8[i + 1] << 8) & 0xFF00) +\\r\\n      (uint8[i + 2] & 0xFF)\\r\\n    output.push(tripletToBase64(tmp))\\r\\n  }\\r\\n  return output.join('')\\r\\n}\\r\\n\\r\\nfunction fromByteArray (uint8) {\\r\\n  var tmp\\r\\n  var len = uint8.length\\r\\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\r\\n  var parts = []\\r\\n  var maxChunkLength = 16383 // must be multiple of 3\\r\\n\\r\\n  // go through the array every three bytes, we'll deal with trailing stuff later\\r\\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\r\\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\\r\\n  }\\r\\n\\r\\n  // pad the end with zeros, but make sure to not forget the extra bytes\\r\\n  if (extraBytes === 1) {\\r\\n    tmp = uint8[len - 1]\\r\\n    parts.push(\\r\\n      lookup[tmp >> 2] +\\r\\n      lookup[(tmp << 4) & 0x3F] +\\r\\n      '=='\\r\\n    )\\r\\n  } else if (extraBytes === 2) {\\r\\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\\r\\n    parts.push(\\r\\n      lookup[tmp >> 10] +\\r\\n      lookup[(tmp >> 4) & 0x3F] +\\r\\n      lookup[(tmp << 2) & 0x3F] +\\r\\n      '='\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return parts.join('')\\r\\n}\\r\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"getLens\",\"b64\",\"len\",\"length\",\"Error\",\"validLen\",\"indexOf\",\"placeHoldersLen\",\"byteLength\",\"lens\",\"toByteArray\",\"arr\",\"Arr\",\"curByte\",\"i\",\"tmp\",\"revLookup\",\"charCodeAt\",\"fromByteArray\",\"uint8\",\"extraBytes\",\"parts\",\"len2\",\"maxChunkLength\",\"push\",\"output\",\"end\",\"lookup\",\"join\",\"Uint8Array\",\"Array\",\"code\"]\n}\n"]