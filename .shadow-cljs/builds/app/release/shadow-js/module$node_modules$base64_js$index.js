["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/base64-js/index.js"],"~:js","shadow$provide[32]=function(S,ka,a){function I(G){var E=G.length;if(E%4>0)throw Error(\"Invalid string. Length must be a multiple of 4\");G=G.indexOf(\"\\x3d\");G===-1&&(G=E);return[G,G===E?0:4-G%4]}a.byteLength=function(G){G=I(G);var E=G[1];return(G[0]+E)*3/4-E};a.toByteArray=function(G){var E=I(G);var M=E[0];E=E[1];var d=new C((M+E)*3/4-E),K=0,p=E>0?M-4:M,k;for(k=0;k<p;k+=4)M=D[G.charCodeAt(k)]<<18|D[G.charCodeAt(k+1)]<<12|D[G.charCodeAt(k+2)]<<6|D[G.charCodeAt(k+3)],d[K++]=M>>16&255,d[K++]=M>>8&255,\nd[K++]=M&255;E===2&&(M=D[G.charCodeAt(k)]<<2|D[G.charCodeAt(k+1)]>>4,d[K++]=M&255);E===1&&(M=D[G.charCodeAt(k)]<<10|D[G.charCodeAt(k+1)]<<4|D[G.charCodeAt(k+2)]>>2,d[K++]=M>>8&255,d[K++]=M&255);return d};a.fromByteArray=function(G){for(var E=G.length,M=E%3,d=[],K=0,p=E-M;K<p;K+=16383){for(var k=d,y=k.push,v,z=G,J=K+16383>p?p:K+16383,l=[],t=K;t<J;t+=3)v=(z[t]<<16&16711680)+(z[t+1]<<8&65280)+(z[t+2]&255),l.push(q[v>>18&63]+q[v>>12&63]+q[v>>6&63]+q[v&63]);v=l.join(\"\");y.call(k,v)}M===1?(G=G[E-1],d.push(q[G>>\n2]+q[G<<4&63]+\"\\x3d\\x3d\")):M===2&&(G=(G[E-2]<<8)+G[E-1],d.push(q[G>>10]+q[G>>4&63]+q[G<<2&63]+\"\\x3d\"));return d.join(\"\")};var q=[],D=[],C=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;for(S=0;S<64;++S)q[S]=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[S],D[\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charCodeAt(S)]=S;D[45]=62;D[95]=63}","~:source","shadow$provide[32] = function(require,module,exports) {\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["byteLength","fromByteArray","toByteArray"]],"~:compiled-at",1771991938828,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$base64_js$index.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/base64-js/index.js\"],\n\"sourcesContent\":[\"shadow$provide[32] = function(require,module,exports) {\\n'use strict'\\n\\nexports.byteLength = byteLength\\nexports.toByteArray = toByteArray\\nexports.fromByteArray = fromByteArray\\n\\nvar lookup = []\\nvar revLookup = []\\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\n\\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\nfor (var i = 0, len = code.length; i < len; ++i) {\\n  lookup[i] = code[i]\\n  revLookup[code.charCodeAt(i)] = i\\n}\\n\\n// Support decoding URL-safe base64 strings, as Node.js does.\\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\\nrevLookup['-'.charCodeAt(0)] = 62\\nrevLookup['_'.charCodeAt(0)] = 63\\n\\nfunction getLens (b64) {\\n  var len = b64.length\\n\\n  if (len % 4 > 0) {\\n    throw new Error('Invalid string. Length must be a multiple of 4')\\n  }\\n\\n  // Trim off extra bytes after placeholder bytes are found\\n  // See: https://github.com/beatgammit/base64-js/issues/42\\n  var validLen = b64.indexOf('=')\\n  if (validLen === -1) validLen = len\\n\\n  var placeHoldersLen = validLen === len\\n    ? 0\\n    : 4 - (validLen % 4)\\n\\n  return [validLen, placeHoldersLen]\\n}\\n\\n// base64 is 4/3 + up to two characters of the original data\\nfunction byteLength (b64) {\\n  var lens = getLens(b64)\\n  var validLen = lens[0]\\n  var placeHoldersLen = lens[1]\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\n}\\n\\nfunction _byteLength (b64, validLen, placeHoldersLen) {\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\n}\\n\\nfunction toByteArray (b64) {\\n  var tmp\\n  var lens = getLens(b64)\\n  var validLen = lens[0]\\n  var placeHoldersLen = lens[1]\\n\\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\\n\\n  var curByte = 0\\n\\n  // if there are placeholders, only get up to the last complete 4 chars\\n  var len = placeHoldersLen > 0\\n    ? validLen - 4\\n    : validLen\\n\\n  var i\\n  for (i = 0; i < len; i += 4) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 18) |\\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\\n      revLookup[b64.charCodeAt(i + 3)]\\n    arr[curByte++] = (tmp >> 16) & 0xFF\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  if (placeHoldersLen === 2) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 2) |\\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  if (placeHoldersLen === 1) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 10) |\\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  return arr\\n}\\n\\nfunction tripletToBase64 (num) {\\n  return lookup[num >> 18 & 0x3F] +\\n    lookup[num >> 12 & 0x3F] +\\n    lookup[num >> 6 & 0x3F] +\\n    lookup[num & 0x3F]\\n}\\n\\nfunction encodeChunk (uint8, start, end) {\\n  var tmp\\n  var output = []\\n  for (var i = start; i < end; i += 3) {\\n    tmp =\\n      ((uint8[i] << 16) & 0xFF0000) +\\n      ((uint8[i + 1] << 8) & 0xFF00) +\\n      (uint8[i + 2] & 0xFF)\\n    output.push(tripletToBase64(tmp))\\n  }\\n  return output.join('')\\n}\\n\\nfunction fromByteArray (uint8) {\\n  var tmp\\n  var len = uint8.length\\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\n  var parts = []\\n  var maxChunkLength = 16383 // must be multiple of 3\\n\\n  // go through the array every three bytes, we'll deal with trailing stuff later\\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\\n  }\\n\\n  // pad the end with zeros, but make sure to not forget the extra bytes\\n  if (extraBytes === 1) {\\n    tmp = uint8[len - 1]\\n    parts.push(\\n      lookup[tmp >> 2] +\\n      lookup[(tmp << 4) & 0x3F] +\\n      '=='\\n    )\\n  } else if (extraBytes === 2) {\\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\\n    parts.push(\\n      lookup[tmp >> 10] +\\n      lookup[(tmp >> 4) & 0x3F] +\\n      lookup[(tmp << 2) & 0x3F] +\\n      '='\\n    )\\n  }\\n\\n  return parts.join('')\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"getLens\",\"b64\",\"len\",\"length\",\"Error\",\"validLen\",\"indexOf\",\"placeHoldersLen\",\"byteLength\",\"lens\",\"toByteArray\",\"arr\",\"Arr\",\"curByte\",\"i\",\"tmp\",\"revLookup\",\"charCodeAt\",\"fromByteArray\",\"uint8\",\"extraBytes\",\"parts\",\"len2\",\"maxChunkLength\",\"push\",\"output\",\"end\",\"lookup\",\"join\",\"Uint8Array\",\"Array\",\"code\"]\n}\n"]