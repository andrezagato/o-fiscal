["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/scheduler/cjs/scheduler-tracing.development.js"],"~:js","shadow$provide[9]=function(S,ka,a){}","~:source","shadow$provide[9] = function(require,module,exports) {\n/** @license React v0.20.2\r\n * scheduler-tracing.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n'use strict';\r\n\r\nvar DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.\r\n\r\nvar interactionIDCounter = 0;\r\nvar threadIDCounter = 0; // Set of currently traced interactions.\r\n// Interactions \"stack\"–\r\n// Meaning that newly traced interactions are appended to the previously active set.\r\n// When an interaction goes out of scope, the previous set (if any) is restored.\r\n\r\nexports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.\r\n\r\nexports.__subscriberRef = null;\r\n\r\n{\r\n  exports.__interactionsRef = {\r\n    current: new Set()\r\n  };\r\n  exports.__subscriberRef = {\r\n    current: null\r\n  };\r\n}\r\nfunction unstable_clear(callback) {\r\n\r\n  var prevInteractions = exports.__interactionsRef.current;\r\n  exports.__interactionsRef.current = new Set();\r\n\r\n  try {\r\n    return callback();\r\n  } finally {\r\n    exports.__interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\nfunction unstable_getCurrent() {\r\n  {\r\n    return exports.__interactionsRef.current;\r\n  }\r\n}\r\nfunction unstable_getThreadID() {\r\n  return ++threadIDCounter;\r\n}\r\nfunction unstable_trace(name, timestamp, callback) {\r\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\r\n\r\n  var interaction = {\r\n    __count: 1,\r\n    id: interactionIDCounter++,\r\n    name: name,\r\n    timestamp: timestamp\r\n  };\r\n  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.\r\n  // To do that, clone the current interactions.\r\n  // The previous set will be restored upon completion.\r\n\r\n  var interactions = new Set(prevInteractions);\r\n  interactions.add(interaction);\r\n  exports.__interactionsRef.current = interactions;\r\n  var subscriber = exports.__subscriberRef.current;\r\n  var returnValue;\r\n\r\n  try {\r\n    if (subscriber !== null) {\r\n      subscriber.onInteractionTraced(interaction);\r\n    }\r\n  } finally {\r\n    try {\r\n      if (subscriber !== null) {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      }\r\n    } finally {\r\n      try {\r\n        returnValue = callback();\r\n      } finally {\r\n        exports.__interactionsRef.current = prevInteractions;\r\n\r\n        try {\r\n          if (subscriber !== null) {\r\n            subscriber.onWorkStopped(interactions, threadID);\r\n          }\r\n        } finally {\r\n          interaction.__count--; // If no async work was scheduled for this interaction,\r\n          // Notify subscribers that it's completed.\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return returnValue;\r\n}\r\nfunction unstable_wrap(callback) {\r\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\r\n\r\n  var wrappedInteractions = exports.__interactionsRef.current;\r\n  var subscriber = exports.__subscriberRef.current;\r\n\r\n  if (subscriber !== null) {\r\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\r\n  } // Update the pending async work count for the current interactions.\r\n  // Update after calling subscribers in case of error.\r\n\r\n\r\n  wrappedInteractions.forEach(function (interaction) {\r\n    interaction.__count++;\r\n  });\r\n  var hasRun = false;\r\n\r\n  function wrapped() {\r\n    var prevInteractions = exports.__interactionsRef.current;\r\n    exports.__interactionsRef.current = wrappedInteractions;\r\n    subscriber = exports.__subscriberRef.current;\r\n\r\n    try {\r\n      var returnValue;\r\n\r\n      try {\r\n        if (subscriber !== null) {\r\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\r\n        }\r\n      } finally {\r\n        try {\r\n          returnValue = callback.apply(undefined, arguments);\r\n        } finally {\r\n          exports.__interactionsRef.current = prevInteractions;\r\n\r\n          if (subscriber !== null) {\r\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\r\n          }\r\n        }\r\n      }\r\n\r\n      return returnValue;\r\n    } finally {\r\n      if (!hasRun) {\r\n        // We only expect a wrapped function to be executed once,\r\n        // But in the event that it's executed more than once–\r\n        // Only decrement the outstanding interaction counts once.\r\n        hasRun = true; // Update pending async counts for all wrapped interactions.\r\n        // If this was the last scheduled async work for any of them,\r\n        // Mark them as completed.\r\n\r\n        wrappedInteractions.forEach(function (interaction) {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  wrapped.cancel = function cancel() {\r\n    subscriber = exports.__subscriberRef.current;\r\n\r\n    try {\r\n      if (subscriber !== null) {\r\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\r\n      }\r\n    } finally {\r\n      // Update pending async counts for all wrapped interactions.\r\n      // If this was the last scheduled async work for any of them,\r\n      // Mark them as completed.\r\n      wrappedInteractions.forEach(function (interaction) {\r\n        interaction.__count--;\r\n\r\n        if (subscriber && interaction.__count === 0) {\r\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  return wrapped;\r\n}\r\n\r\nvar subscribers = null;\r\n\r\n{\r\n  subscribers = new Set();\r\n}\r\n\r\nfunction unstable_subscribe(subscriber) {\r\n  {\r\n    subscribers.add(subscriber);\r\n\r\n    if (subscribers.size === 1) {\r\n      exports.__subscriberRef.current = {\r\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\r\n        onInteractionTraced: onInteractionTraced,\r\n        onWorkCanceled: onWorkCanceled,\r\n        onWorkScheduled: onWorkScheduled,\r\n        onWorkStarted: onWorkStarted,\r\n        onWorkStopped: onWorkStopped\r\n      };\r\n    }\r\n  }\r\n}\r\nfunction unstable_unsubscribe(subscriber) {\r\n  {\r\n    subscribers.delete(subscriber);\r\n\r\n    if (subscribers.size === 0) {\r\n      exports.__subscriberRef.current = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction onInteractionTraced(interaction) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onInteractionTraced(interaction);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onInteractionScheduledWorkCompleted(interaction) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkScheduled(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkStarted(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkStarted(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkStopped(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkStopped(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkCanceled(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkCanceled(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nexports.unstable_clear = unstable_clear;\r\nexports.unstable_getCurrent = unstable_getCurrent;\r\nexports.unstable_getThreadID = unstable_getThreadID;\r\nexports.unstable_subscribe = unstable_subscribe;\r\nexports.unstable_trace = unstable_trace;\r\nexports.unstable_unsubscribe = unstable_unsubscribe;\r\nexports.unstable_wrap = unstable_wrap;\r\n  })();\r\n}\r\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",[]],"~:compiled-at",1771869280569,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$scheduler$cjs$scheduler_tracing_development.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAe,CAAf,CAAA,CAAoB,QAAQ,CAACC,CAAD,CAASC,EAAT,CAAgBC,CAAhB,CAAyB;\",\n\"sources\":[\"node_modules/scheduler/cjs/scheduler-tracing.development.js\"],\n\"sourcesContent\":[\"shadow$provide[9] = function(require,module,exports) {\\n/** @license React v0.20.2\\r\\n * scheduler-tracing.development.js\\r\\n *\\r\\n * Copyright (c) Facebook, Inc. and its affiliates.\\r\\n *\\r\\n * This source code is licensed under the MIT license found in the\\r\\n * LICENSE file in the root directory of this source tree.\\r\\n */\\r\\n\\r\\n'use strict';\\r\\n\\r\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\r\\n  (function() {\\r\\n'use strict';\\r\\n\\r\\nvar DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.\\r\\n\\r\\nvar interactionIDCounter = 0;\\r\\nvar threadIDCounter = 0; // Set of currently traced interactions.\\r\\n// Interactions \\\"stack\\\"\\u2013\\r\\n// Meaning that newly traced interactions are appended to the previously active set.\\r\\n// When an interaction goes out of scope, the previous set (if any) is restored.\\r\\n\\r\\nexports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.\\r\\n\\r\\nexports.__subscriberRef = null;\\r\\n\\r\\n{\\r\\n  exports.__interactionsRef = {\\r\\n    current: new Set()\\r\\n  };\\r\\n  exports.__subscriberRef = {\\r\\n    current: null\\r\\n  };\\r\\n}\\r\\nfunction unstable_clear(callback) {\\r\\n\\r\\n  var prevInteractions = exports.__interactionsRef.current;\\r\\n  exports.__interactionsRef.current = new Set();\\r\\n\\r\\n  try {\\r\\n    return callback();\\r\\n  } finally {\\r\\n    exports.__interactionsRef.current = prevInteractions;\\r\\n  }\\r\\n}\\r\\nfunction unstable_getCurrent() {\\r\\n  {\\r\\n    return exports.__interactionsRef.current;\\r\\n  }\\r\\n}\\r\\nfunction unstable_getThreadID() {\\r\\n  return ++threadIDCounter;\\r\\n}\\r\\nfunction unstable_trace(name, timestamp, callback) {\\r\\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\\r\\n\\r\\n  var interaction = {\\r\\n    __count: 1,\\r\\n    id: interactionIDCounter++,\\r\\n    name: name,\\r\\n    timestamp: timestamp\\r\\n  };\\r\\n  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.\\r\\n  // To do that, clone the current interactions.\\r\\n  // The previous set will be restored upon completion.\\r\\n\\r\\n  var interactions = new Set(prevInteractions);\\r\\n  interactions.add(interaction);\\r\\n  exports.__interactionsRef.current = interactions;\\r\\n  var subscriber = exports.__subscriberRef.current;\\r\\n  var returnValue;\\r\\n\\r\\n  try {\\r\\n    if (subscriber !== null) {\\r\\n      subscriber.onInteractionTraced(interaction);\\r\\n    }\\r\\n  } finally {\\r\\n    try {\\r\\n      if (subscriber !== null) {\\r\\n        subscriber.onWorkStarted(interactions, threadID);\\r\\n      }\\r\\n    } finally {\\r\\n      try {\\r\\n        returnValue = callback();\\r\\n      } finally {\\r\\n        exports.__interactionsRef.current = prevInteractions;\\r\\n\\r\\n        try {\\r\\n          if (subscriber !== null) {\\r\\n            subscriber.onWorkStopped(interactions, threadID);\\r\\n          }\\r\\n        } finally {\\r\\n          interaction.__count--; // If no async work was scheduled for this interaction,\\r\\n          // Notify subscribers that it's completed.\\r\\n\\r\\n          if (subscriber !== null && interaction.__count === 0) {\\r\\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return returnValue;\\r\\n}\\r\\nfunction unstable_wrap(callback) {\\r\\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\\r\\n\\r\\n  var wrappedInteractions = exports.__interactionsRef.current;\\r\\n  var subscriber = exports.__subscriberRef.current;\\r\\n\\r\\n  if (subscriber !== null) {\\r\\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\\r\\n  } // Update the pending async work count for the current interactions.\\r\\n  // Update after calling subscribers in case of error.\\r\\n\\r\\n\\r\\n  wrappedInteractions.forEach(function (interaction) {\\r\\n    interaction.__count++;\\r\\n  });\\r\\n  var hasRun = false;\\r\\n\\r\\n  function wrapped() {\\r\\n    var prevInteractions = exports.__interactionsRef.current;\\r\\n    exports.__interactionsRef.current = wrappedInteractions;\\r\\n    subscriber = exports.__subscriberRef.current;\\r\\n\\r\\n    try {\\r\\n      var returnValue;\\r\\n\\r\\n      try {\\r\\n        if (subscriber !== null) {\\r\\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\\r\\n        }\\r\\n      } finally {\\r\\n        try {\\r\\n          returnValue = callback.apply(undefined, arguments);\\r\\n        } finally {\\r\\n          exports.__interactionsRef.current = prevInteractions;\\r\\n\\r\\n          if (subscriber !== null) {\\r\\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n\\r\\n      return returnValue;\\r\\n    } finally {\\r\\n      if (!hasRun) {\\r\\n        // We only expect a wrapped function to be executed once,\\r\\n        // But in the event that it's executed more than once\\u2013\\r\\n        // Only decrement the outstanding interaction counts once.\\r\\n        hasRun = true; // Update pending async counts for all wrapped interactions.\\r\\n        // If this was the last scheduled async work for any of them,\\r\\n        // Mark them as completed.\\r\\n\\r\\n        wrappedInteractions.forEach(function (interaction) {\\r\\n          interaction.__count--;\\r\\n\\r\\n          if (subscriber !== null && interaction.__count === 0) {\\r\\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\\r\\n          }\\r\\n        });\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  wrapped.cancel = function cancel() {\\r\\n    subscriber = exports.__subscriberRef.current;\\r\\n\\r\\n    try {\\r\\n      if (subscriber !== null) {\\r\\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\\r\\n      }\\r\\n    } finally {\\r\\n      // Update pending async counts for all wrapped interactions.\\r\\n      // If this was the last scheduled async work for any of them,\\r\\n      // Mark them as completed.\\r\\n      wrappedInteractions.forEach(function (interaction) {\\r\\n        interaction.__count--;\\r\\n\\r\\n        if (subscriber && interaction.__count === 0) {\\r\\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\\r\\n        }\\r\\n      });\\r\\n    }\\r\\n  };\\r\\n\\r\\n  return wrapped;\\r\\n}\\r\\n\\r\\nvar subscribers = null;\\r\\n\\r\\n{\\r\\n  subscribers = new Set();\\r\\n}\\r\\n\\r\\nfunction unstable_subscribe(subscriber) {\\r\\n  {\\r\\n    subscribers.add(subscriber);\\r\\n\\r\\n    if (subscribers.size === 1) {\\r\\n      exports.__subscriberRef.current = {\\r\\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\\r\\n        onInteractionTraced: onInteractionTraced,\\r\\n        onWorkCanceled: onWorkCanceled,\\r\\n        onWorkScheduled: onWorkScheduled,\\r\\n        onWorkStarted: onWorkStarted,\\r\\n        onWorkStopped: onWorkStopped\\r\\n      };\\r\\n    }\\r\\n  }\\r\\n}\\r\\nfunction unstable_unsubscribe(subscriber) {\\r\\n  {\\r\\n    subscribers.delete(subscriber);\\r\\n\\r\\n    if (subscribers.size === 0) {\\r\\n      exports.__subscriberRef.current = null;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onInteractionTraced(interaction) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onInteractionTraced(interaction);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onInteractionScheduledWorkCompleted(interaction) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onWorkScheduled(interactions, threadID) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onWorkScheduled(interactions, threadID);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onWorkStarted(interactions, threadID) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onWorkStarted(interactions, threadID);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onWorkStopped(interactions, threadID) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onWorkStopped(interactions, threadID);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onWorkCanceled(interactions, threadID) {\\r\\n  var didCatchError = false;\\r\\n  var caughtError = null;\\r\\n  subscribers.forEach(function (subscriber) {\\r\\n    try {\\r\\n      subscriber.onWorkCanceled(interactions, threadID);\\r\\n    } catch (error) {\\r\\n      if (!didCatchError) {\\r\\n        didCatchError = true;\\r\\n        caughtError = error;\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  if (didCatchError) {\\r\\n    throw caughtError;\\r\\n  }\\r\\n}\\r\\n\\r\\nexports.unstable_clear = unstable_clear;\\r\\nexports.unstable_getCurrent = unstable_getCurrent;\\r\\nexports.unstable_getThreadID = unstable_getThreadID;\\r\\nexports.unstable_subscribe = unstable_subscribe;\\r\\nexports.unstable_trace = unstable_trace;\\r\\nexports.unstable_unsubscribe = unstable_unsubscribe;\\r\\nexports.unstable_wrap = unstable_wrap;\\r\\n  })();\\r\\n}\\r\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\"]\n}\n"]