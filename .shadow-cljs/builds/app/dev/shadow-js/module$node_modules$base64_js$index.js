["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/base64-js/index.js"],"~:js","shadow$provide.module$node_modules$base64_js$index = function(require, module, exports) {\n  function getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) {\n      throw Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    b64 = b64.indexOf(\"\\x3d\");\n    b64 === -1 && (b64 = len);\n    return [b64, b64 === len ? 0 : 4 - b64 % 4];\n  }\n  exports.byteLength = function(b64) {\n    b64 = getLens(b64);\n    var placeHoldersLen = b64[1];\n    return (b64[0] + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n  };\n  exports.toByteArray = function(b64) {\n    var lens = getLens(b64);\n    var tmp = lens[0];\n    lens = lens[1];\n    var arr = new Arr((tmp + lens) * 3 / 4 - lens), curByte = 0, len = lens > 0 ? tmp - 4 : tmp, i;\n    for (i = 0; i < len; i += 4) {\n      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;\n    }\n    lens === 2 && (tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4, arr[curByte++] = tmp & 255);\n    lens === 1 && (tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255);\n    return arr;\n  };\n  exports.fromByteArray = function(uint8$jscomp$0) {\n    for (var len = uint8$jscomp$0.length, extraBytes = len % 3, parts = [], i = 0, len2 = len - extraBytes; i < len2; i += 16383) {\n      for (var JSCompiler_temp_const = parts, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.push, JSCompiler_inline_result, uint8 = uint8$jscomp$0, end = i + 16383 > len2 ? len2 : i + 16383, output = [], i$jscomp$0 = i; i$jscomp$0 < end; i$jscomp$0 += 3) {\n        JSCompiler_inline_result = (uint8[i$jscomp$0] << 16 & 16711680) + (uint8[i$jscomp$0 + 1] << 8 & 65280) + (uint8[i$jscomp$0 + 2] & 255), output.push(lookup[JSCompiler_inline_result >> 18 & 63] + lookup[JSCompiler_inline_result >> 12 & 63] + lookup[JSCompiler_inline_result >> 6 & 63] + lookup[JSCompiler_inline_result & 63]);\n      }\n      JSCompiler_inline_result = output.join(\"\");\n      JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, JSCompiler_inline_result);\n    }\n    extraBytes === 1 ? (uint8$jscomp$0 = uint8$jscomp$0[len - 1], parts.push(lookup[uint8$jscomp$0 >> 2] + lookup[uint8$jscomp$0 << 4 & 63] + \"\\x3d\\x3d\")) : extraBytes === 2 && (uint8$jscomp$0 = (uint8$jscomp$0[len - 2] << 8) + uint8$jscomp$0[len - 1], parts.push(lookup[uint8$jscomp$0 >> 10] + lookup[uint8$jscomp$0 >> 4 & 63] + lookup[uint8$jscomp$0 << 2 & 63] + \"\\x3d\"));\n    return parts.join(\"\");\n  };\n  var lookup = [], revLookup = [], Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n  for (require = 0; require < 64; ++require) {\n    lookup[require] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[require], revLookup[\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charCodeAt(require)] = require;\n  }\n  revLookup[45] = 62;\n  revLookup[95] = 63;\n};\n","~:source","shadow$provide[\"module$node_modules$base64_js$index\"] = function(require,module,exports) {\n'use strict'\r\n\r\nexports.byteLength = byteLength\r\nexports.toByteArray = toByteArray\r\nexports.fromByteArray = fromByteArray\r\n\r\nvar lookup = []\r\nvar revLookup = []\r\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\nfor (var i = 0, len = code.length; i < len; ++i) {\r\n  lookup[i] = code[i]\r\n  revLookup[code.charCodeAt(i)] = i\r\n}\r\n\r\n// Support decoding URL-safe base64 strings, as Node.js does.\r\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\r\nrevLookup['-'.charCodeAt(0)] = 62\r\nrevLookup['_'.charCodeAt(0)] = 63\r\n\r\nfunction getLens (b64) {\r\n  var len = b64.length\r\n\r\n  if (len % 4 > 0) {\r\n    throw new Error('Invalid string. Length must be a multiple of 4')\r\n  }\r\n\r\n  // Trim off extra bytes after placeholder bytes are found\r\n  // See: https://github.com/beatgammit/base64-js/issues/42\r\n  var validLen = b64.indexOf('=')\r\n  if (validLen === -1) validLen = len\r\n\r\n  var placeHoldersLen = validLen === len\r\n    ? 0\r\n    : 4 - (validLen % 4)\r\n\r\n  return [validLen, placeHoldersLen]\r\n}\r\n\r\n// base64 is 4/3 + up to two characters of the original data\r\nfunction byteLength (b64) {\r\n  var lens = getLens(b64)\r\n  var validLen = lens[0]\r\n  var placeHoldersLen = lens[1]\r\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n}\r\n\r\nfunction _byteLength (b64, validLen, placeHoldersLen) {\r\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n}\r\n\r\nfunction toByteArray (b64) {\r\n  var tmp\r\n  var lens = getLens(b64)\r\n  var validLen = lens[0]\r\n  var placeHoldersLen = lens[1]\r\n\r\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\r\n\r\n  var curByte = 0\r\n\r\n  // if there are placeholders, only get up to the last complete 4 chars\r\n  var len = placeHoldersLen > 0\r\n    ? validLen - 4\r\n    : validLen\r\n\r\n  var i\r\n  for (i = 0; i < len; i += 4) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 18) |\r\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\r\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\r\n      revLookup[b64.charCodeAt(i + 3)]\r\n    arr[curByte++] = (tmp >> 16) & 0xFF\r\n    arr[curByte++] = (tmp >> 8) & 0xFF\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHoldersLen === 2) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 2) |\r\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  if (placeHoldersLen === 1) {\r\n    tmp =\r\n      (revLookup[b64.charCodeAt(i)] << 10) |\r\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\r\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n    arr[curByte++] = (tmp >> 8) & 0xFF\r\n    arr[curByte++] = tmp & 0xFF\r\n  }\r\n\r\n  return arr\r\n}\r\n\r\nfunction tripletToBase64 (num) {\r\n  return lookup[num >> 18 & 0x3F] +\r\n    lookup[num >> 12 & 0x3F] +\r\n    lookup[num >> 6 & 0x3F] +\r\n    lookup[num & 0x3F]\r\n}\r\n\r\nfunction encodeChunk (uint8, start, end) {\r\n  var tmp\r\n  var output = []\r\n  for (var i = start; i < end; i += 3) {\r\n    tmp =\r\n      ((uint8[i] << 16) & 0xFF0000) +\r\n      ((uint8[i + 1] << 8) & 0xFF00) +\r\n      (uint8[i + 2] & 0xFF)\r\n    output.push(tripletToBase64(tmp))\r\n  }\r\n  return output.join('')\r\n}\r\n\r\nfunction fromByteArray (uint8) {\r\n  var tmp\r\n  var len = uint8.length\r\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n  var parts = []\r\n  var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n  // go through the array every three bytes, we'll deal with trailing stuff later\r\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\r\n  }\r\n\r\n  // pad the end with zeros, but make sure to not forget the extra bytes\r\n  if (extraBytes === 1) {\r\n    tmp = uint8[len - 1]\r\n    parts.push(\r\n      lookup[tmp >> 2] +\r\n      lookup[(tmp << 4) & 0x3F] +\r\n      '=='\r\n    )\r\n  } else if (extraBytes === 2) {\r\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\r\n    parts.push(\r\n      lookup[tmp >> 10] +\r\n      lookup[(tmp >> 4) & 0x3F] +\r\n      lookup[(tmp << 2) & 0x3F] +\r\n      '='\r\n    )\r\n  }\r\n\r\n  return parts.join('')\r\n}\r\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["byteLength","fromByteArray","toByteArray"]],"~:compiled-at",1771872143401,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$base64_js$index.js\",\n\"lineCount\":46,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/base64-js/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$base64_js$index\\\"] = function(require,module,exports) {\\n'use strict'\\r\\n\\r\\nexports.byteLength = byteLength\\r\\nexports.toByteArray = toByteArray\\r\\nexports.fromByteArray = fromByteArray\\r\\n\\r\\nvar lookup = []\\r\\nvar revLookup = []\\r\\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\r\\n\\r\\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\r\\nfor (var i = 0, len = code.length; i < len; ++i) {\\r\\n  lookup[i] = code[i]\\r\\n  revLookup[code.charCodeAt(i)] = i\\r\\n}\\r\\n\\r\\n// Support decoding URL-safe base64 strings, as Node.js does.\\r\\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\\r\\nrevLookup['-'.charCodeAt(0)] = 62\\r\\nrevLookup['_'.charCodeAt(0)] = 63\\r\\n\\r\\nfunction getLens (b64) {\\r\\n  var len = b64.length\\r\\n\\r\\n  if (len % 4 > 0) {\\r\\n    throw new Error('Invalid string. Length must be a multiple of 4')\\r\\n  }\\r\\n\\r\\n  // Trim off extra bytes after placeholder bytes are found\\r\\n  // See: https://github.com/beatgammit/base64-js/issues/42\\r\\n  var validLen = b64.indexOf('=')\\r\\n  if (validLen === -1) validLen = len\\r\\n\\r\\n  var placeHoldersLen = validLen === len\\r\\n    ? 0\\r\\n    : 4 - (validLen % 4)\\r\\n\\r\\n  return [validLen, placeHoldersLen]\\r\\n}\\r\\n\\r\\n// base64 is 4/3 + up to two characters of the original data\\r\\nfunction byteLength (b64) {\\r\\n  var lens = getLens(b64)\\r\\n  var validLen = lens[0]\\r\\n  var placeHoldersLen = lens[1]\\r\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\r\\n}\\r\\n\\r\\nfunction _byteLength (b64, validLen, placeHoldersLen) {\\r\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\r\\n}\\r\\n\\r\\nfunction toByteArray (b64) {\\r\\n  var tmp\\r\\n  var lens = getLens(b64)\\r\\n  var validLen = lens[0]\\r\\n  var placeHoldersLen = lens[1]\\r\\n\\r\\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\\r\\n\\r\\n  var curByte = 0\\r\\n\\r\\n  // if there are placeholders, only get up to the last complete 4 chars\\r\\n  var len = placeHoldersLen > 0\\r\\n    ? validLen - 4\\r\\n    : validLen\\r\\n\\r\\n  var i\\r\\n  for (i = 0; i < len; i += 4) {\\r\\n    tmp =\\r\\n      (revLookup[b64.charCodeAt(i)] << 18) |\\r\\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\\r\\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\\r\\n      revLookup[b64.charCodeAt(i + 3)]\\r\\n    arr[curByte++] = (tmp >> 16) & 0xFF\\r\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\r\\n    arr[curByte++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  if (placeHoldersLen === 2) {\\r\\n    tmp =\\r\\n      (revLookup[b64.charCodeAt(i)] << 2) |\\r\\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\\r\\n    arr[curByte++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  if (placeHoldersLen === 1) {\\r\\n    tmp =\\r\\n      (revLookup[b64.charCodeAt(i)] << 10) |\\r\\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\\r\\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\\r\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\r\\n    arr[curByte++] = tmp & 0xFF\\r\\n  }\\r\\n\\r\\n  return arr\\r\\n}\\r\\n\\r\\nfunction tripletToBase64 (num) {\\r\\n  return lookup[num >> 18 & 0x3F] +\\r\\n    lookup[num >> 12 & 0x3F] +\\r\\n    lookup[num >> 6 & 0x3F] +\\r\\n    lookup[num & 0x3F]\\r\\n}\\r\\n\\r\\nfunction encodeChunk (uint8, start, end) {\\r\\n  var tmp\\r\\n  var output = []\\r\\n  for (var i = start; i < end; i += 3) {\\r\\n    tmp =\\r\\n      ((uint8[i] << 16) & 0xFF0000) +\\r\\n      ((uint8[i + 1] << 8) & 0xFF00) +\\r\\n      (uint8[i + 2] & 0xFF)\\r\\n    output.push(tripletToBase64(tmp))\\r\\n  }\\r\\n  return output.join('')\\r\\n}\\r\\n\\r\\nfunction fromByteArray (uint8) {\\r\\n  var tmp\\r\\n  var len = uint8.length\\r\\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\r\\n  var parts = []\\r\\n  var maxChunkLength = 16383 // must be multiple of 3\\r\\n\\r\\n  // go through the array every three bytes, we'll deal with trailing stuff later\\r\\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\r\\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\\r\\n  }\\r\\n\\r\\n  // pad the end with zeros, but make sure to not forget the extra bytes\\r\\n  if (extraBytes === 1) {\\r\\n    tmp = uint8[len - 1]\\r\\n    parts.push(\\r\\n      lookup[tmp >> 2] +\\r\\n      lookup[(tmp << 4) & 0x3F] +\\r\\n      '=='\\r\\n    )\\r\\n  } else if (extraBytes === 2) {\\r\\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\\r\\n    parts.push(\\r\\n      lookup[tmp >> 10] +\\r\\n      lookup[(tmp >> 4) & 0x3F] +\\r\\n      lookup[(tmp << 2) & 0x3F] +\\r\\n      '='\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return parts.join('')\\r\\n}\\r\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"getLens\",\"b64\",\"len\",\"length\",\"Error\",\"validLen\",\"indexOf\",\"placeHoldersLen\",\"byteLength\",\"lens\",\"toByteArray\",\"arr\",\"Arr\",\"curByte\",\"i\",\"tmp\",\"revLookup\",\"charCodeAt\",\"fromByteArray\",\"uint8\",\"extraBytes\",\"parts\",\"len2\",\"maxChunkLength\",\"push\",\"output\",\"end\",\"lookup\",\"join\",\"Uint8Array\",\"Array\",\"code\"]\n}\n"]