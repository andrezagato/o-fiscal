["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/auth-js/dist/main/lib/webauthn.js"],"~:js","shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$webauthn = function(require, module, exports) {\n  function browserSupportsWebAuthn() {\n    var _a, _b;\n    return !!((0,helpers_1.isBrowser)() && \"PublicKeyCredential\" in window && window.PublicKeyCredential && \"credentials\" in navigator && typeof((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === \"function\" && typeof((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === \"function\");\n  }\n  async function createCredential(options) {\n    try {\n      const response = await navigator.credentials.create(options);\n      return response ? response instanceof PublicKeyCredential ? {data:response, error:null} : {data:null, error:new webauthn_errors_1.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)} : {data:null, error:new webauthn_errors_1.WebAuthnUnknownError(\"Empty credential response\", response)};\n    } catch (err) {\n      return {data:null, error:(0,webauthn_errors_1.identifyRegistrationError)({error:err, options})};\n    }\n  }\n  async function getCredential(options) {\n    try {\n      const response = await navigator.credentials.get(options);\n      return response ? response instanceof PublicKeyCredential ? {data:response, error:null} : {data:null, error:new webauthn_errors_1.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)} : {data:null, error:new webauthn_errors_1.WebAuthnUnknownError(\"Empty credential response\", response)};\n    } catch (err) {\n      return {data:null, error:(0,webauthn_errors_1.identifyAuthenticationError)({error:err, options})};\n    }\n  }\n  function deepMerge(...sources) {\n    const result = {};\n    for (const source of sources) {\n      if (source) {\n        for (const key in source) {\n          if (sources = source[key], sources !== void 0) {\n            if (Array.isArray(sources)) {\n              result[key] = sources;\n            } else if (sources instanceof ArrayBuffer || ArrayBuffer.isView(sources)) {\n              result[key] = sources;\n            } else if (sources === null || typeof sources !== \"object\" || Array.isArray(sources)) {\n              result[key] = sources;\n            } else {\n              const existing = result[key];\n              existing === null || typeof existing !== \"object\" || Array.isArray(existing) ? result[key] = deepMerge(sources) : result[key] = deepMerge(existing, sources);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n  function mergeCredentialCreationOptions(baseOptions, overrides) {\n    return deepMerge(exports.DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n  }\n  function mergeCredentialRequestOptions(baseOptions, overrides) {\n    return deepMerge(exports.DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.WebAuthnApi = exports.DEFAULT_REQUEST_OPTIONS = exports.DEFAULT_CREATION_OPTIONS = exports.webAuthnAbortService = exports.WebAuthnAbortService = exports.identifyAuthenticationError = exports.identifyRegistrationError = exports.isWebAuthnError = exports.WebAuthnError = void 0;\n  exports.deserializeCredentialCreationOptions = function(options) {\n    if (!options) {\n      throw Error(\"Credential creation options are required\");\n    }\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseCreationOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === \"function\") {\n      return PublicKeyCredential.parseCreationOptionsFromJSON(options);\n    }\n    const {challenge:challengeStr, user:userOpts, excludeCredentials} = options;\n    options = tslib_1.__rest(options, [\"challenge\", \"user\", \"excludeCredentials\"]);\n    var challenge = (0,base64url_1.base64UrlToUint8Array)(challengeStr).buffer, user = Object.assign(Object.assign({}, userOpts), {id:(0,base64url_1.base64UrlToUint8Array)(userOpts.id).buffer});\n    options = Object.assign(Object.assign({}, options), {challenge, user});\n    if (excludeCredentials && excludeCredentials.length > 0) {\n      for (options.excludeCredentials = Array(excludeCredentials.length), challenge = 0; challenge < excludeCredentials.length; challenge++) {\n        user = excludeCredentials[challenge], options.excludeCredentials[challenge] = Object.assign(Object.assign({}, user), {id:(0,base64url_1.base64UrlToUint8Array)(user.id).buffer, type:user.type || \"public-key\", transports:user.transports});\n      }\n    }\n    return options;\n  };\n  exports.deserializeCredentialRequestOptions = function(options) {\n    if (!options) {\n      throw Error(\"Credential request options are required\");\n    }\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseRequestOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === \"function\") {\n      return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n    }\n    const {challenge:challengeStr, allowCredentials} = options;\n    options = tslib_1.__rest(options, [\"challenge\", \"allowCredentials\"]);\n    var challenge = (0,base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\n    options = Object.assign(Object.assign({}, options), {challenge});\n    if (allowCredentials && allowCredentials.length > 0) {\n      for (options.allowCredentials = Array(allowCredentials.length), challenge = 0; challenge < allowCredentials.length; challenge++) {\n        const cred = allowCredentials[challenge];\n        options.allowCredentials[challenge] = Object.assign(Object.assign({}, cred), {id:(0,base64url_1.base64UrlToUint8Array)(cred.id).buffer, type:cred.type || \"public-key\", transports:cred.transports});\n      }\n    }\n    return options;\n  };\n  exports.serializeCredentialCreationResponse = function(credential) {\n    var _a;\n    return \"toJSON\" in credential && typeof credential.toJSON === \"function\" ? credential.toJSON() : {id:credential.id, rawId:credential.id, response:{attestationObject:(0,base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)), clientDataJSON:(0,base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON))}, type:\"public-key\", clientExtensionResults:credential.getClientExtensionResults(), authenticatorAttachment:(_a = credential.authenticatorAttachment) !== \n    null && _a !== void 0 ? _a : void 0};\n  };\n  exports.serializeCredentialRequestResponse = function(credential) {\n    var _a;\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n      return credential.toJSON();\n    }\n    const clientExtensionResults = credential.getClientExtensionResults(), assertionResponse = credential.response;\n    return {id:credential.id, rawId:credential.id, response:{authenticatorData:(0,base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)), clientDataJSON:(0,base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)), signature:(0,base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)), userHandle:assertionResponse.userHandle ? (0,base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle)) : void 0}, type:\"public-key\", \n    clientExtensionResults, authenticatorAttachment:(_a = credential.authenticatorAttachment) !== null && _a !== void 0 ? _a : void 0};\n  };\n  exports.isValidDomain = function(hostname) {\n    return hostname === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname);\n  };\n  exports.createCredential = createCredential;\n  exports.getCredential = getCredential;\n  exports.mergeCredentialCreationOptions = mergeCredentialCreationOptions;\n  exports.mergeCredentialRequestOptions = mergeCredentialRequestOptions;\n  const tslib_1 = require(\"module$node_modules$tslib$tslib\"), base64url_1 = require(\"module$node_modules$$supabase$auth_js$dist$main$lib$base64url\"), errors_1 = require(\"module$node_modules$$supabase$auth_js$dist$main$lib$errors\"), helpers_1 = require(\"module$node_modules$$supabase$auth_js$dist$main$lib$helpers\"), webauthn_errors_1 = require(\"module$node_modules$$supabase$auth_js$dist$main$lib$webauthn_errors\");\n  Object.defineProperty(exports, \"identifyAuthenticationError\", {enumerable:!0, get:function() {\n    return webauthn_errors_1.identifyAuthenticationError;\n  }});\n  Object.defineProperty(exports, \"identifyRegistrationError\", {enumerable:!0, get:function() {\n    return webauthn_errors_1.identifyRegistrationError;\n  }});\n  Object.defineProperty(exports, \"isWebAuthnError\", {enumerable:!0, get:function() {\n    return webauthn_errors_1.isWebAuthnError;\n  }});\n  Object.defineProperty(exports, \"WebAuthnError\", {enumerable:!0, get:function() {\n    return webauthn_errors_1.WebAuthnError;\n  }});\n  class WebAuthnAbortService {\n    createNewAbortSignal() {\n      if (this.controller) {\n        var abortError = Error(\"Cancelling existing WebAuthn API call for new one\");\n        abortError.name = \"AbortError\";\n        this.controller.abort(abortError);\n      }\n      this.controller = abortError = new AbortController();\n      return abortError.signal;\n    }\n    cancelCeremony() {\n      if (this.controller) {\n        const abortError = Error(\"Manually cancelling existing WebAuthn API call\");\n        abortError.name = \"AbortError\";\n        this.controller.abort(abortError);\n        this.controller = void 0;\n      }\n    }\n  }\n  exports.WebAuthnAbortService = WebAuthnAbortService;\n  exports.webAuthnAbortService = new WebAuthnAbortService();\n  exports.DEFAULT_CREATION_OPTIONS = {hints:[\"security-key\"], authenticatorSelection:{authenticatorAttachment:\"cross-platform\", requireResidentKey:!1, userVerification:\"preferred\", residentKey:\"discouraged\"}, attestation:\"direct\"};\n  exports.DEFAULT_REQUEST_OPTIONS = {userVerification:\"preferred\", hints:[\"security-key\"], attestation:\"direct\"};\n  class WebAuthnApi {\n    constructor(client) {\n      this.client = client;\n      this.enroll = this._enroll.bind(this);\n      this.challenge = this._challenge.bind(this);\n      this.verify = this._verify.bind(this);\n      this.authenticate = this._authenticate.bind(this);\n      this.register = this._register.bind(this);\n    }\n    async _enroll(params) {\n      return this.client.mfa.enroll(Object.assign(Object.assign({}, params), {factorType:\"webauthn\"}));\n    }\n    async _challenge({factorId, webauthn, friendlyName, signal}, overrides) {\n      var _a;\n      try {\n        const {data:challengeResponse, error:challengeError} = await this.client.mfa.challenge({factorId, webauthn});\n        if (!challengeResponse) {\n          return {data:null, error:challengeError};\n        }\n        const abortSignal = signal !== null && signal !== void 0 ? signal : exports.webAuthnAbortService.createNewAbortSignal();\n        if (challengeResponse.webauthn.type === \"create\") {\n          const {user} = challengeResponse.webauthn.credential_options.publicKey;\n          if (!user.name) {\n            if (friendlyName) {\n              user.name = `${user.id}:${friendlyName}`;\n            } else {\n              const userData = (await this.client.getUser()).data.user, fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || \"User\";\n              user.name = `${user.id}:${fallbackName}`;\n            }\n          }\n          user.displayName || (user.displayName = user.name);\n        }\n        switch(challengeResponse.webauthn.type) {\n          case \"create\":\n            const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create), {data, error} = await createCredential({publicKey:options, signal:abortSignal});\n            return data ? {data:{factorId, challengeId:challengeResponse.id, webauthn:{type:challengeResponse.webauthn.type, credential_response:data}}, error:null} : {data:null, error};\n          case \"request\":\n            const options$jscomp$0 = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request), {data:data$jscomp$0, error:error$jscomp$0} = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {publicKey:options$jscomp$0, signal:abortSignal}));\n            return data$jscomp$0 ? {data:{factorId, challengeId:challengeResponse.id, webauthn:{type:challengeResponse.webauthn.type, credential_response:data$jscomp$0}}, error:null} : {data:null, error:error$jscomp$0};\n        }\n      } catch (error) {\n        return (0,errors_1.isAuthError)(error) ? {data:null, error} : {data:null, error:new errors_1.AuthUnknownError(\"Unexpected error in challenge\", error)};\n      }\n    }\n    async _verify({challengeId, factorId, webauthn}) {\n      return this.client.mfa.verify({factorId, challengeId, webauthn});\n    }\n    async _authenticate({factorId, webauthn:{rpId = typeof window !== \"undefined\" ? window.location.hostname : void 0, rpOrigins = typeof window !== \"undefined\" ? [window.location.origin] : void 0, signal} = {}}, overrides) {\n      if (!rpId) {\n        return {data:null, error:new errors_1.AuthError(\"rpId is required for WebAuthn authentication\")};\n      }\n      try {\n        if (!browserSupportsWebAuthn()) {\n          return {data:null, error:new errors_1.AuthUnknownError(\"Browser does not support WebAuthn\", null)};\n        }\n        const {data:challengeResponse, error:challengeError} = await this.challenge({factorId, webauthn:{rpId, rpOrigins}, signal}, {request:overrides});\n        if (!challengeResponse) {\n          return {data:null, error:challengeError};\n        }\n        ({webauthn:signal} = challengeResponse);\n        return this._verify({factorId, challengeId:challengeResponse.challengeId, webauthn:{type:signal.type, rpId, rpOrigins, credential_response:signal.credential_response}});\n      } catch (error) {\n        return (0,errors_1.isAuthError)(error) ? {data:null, error} : {data:null, error:new errors_1.AuthUnknownError(\"Unexpected error in authenticate\", error)};\n      }\n    }\n    async _register({friendlyName, webauthn:{rpId = typeof window !== \"undefined\" ? window.location.hostname : void 0, rpOrigins = typeof window !== \"undefined\" ? [window.location.origin] : void 0, signal} = {}}, overrides) {\n      if (!rpId) {\n        return {data:null, error:new errors_1.AuthError(\"rpId is required for WebAuthn registration\")};\n      }\n      try {\n        if (!browserSupportsWebAuthn()) {\n          return {data:null, error:new errors_1.AuthUnknownError(\"Browser does not support WebAuthn\", null)};\n        }\n        const {data:factor, error:enrollError} = await this._enroll({friendlyName});\n        if (!factor) {\n          return await this.client.mfa.listFactors().then(factors => {\n            var _a;\n            return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find(v => v.factor_type === \"webauthn\" && v.friendly_name === friendlyName && v.status !== \"unverified\");\n          }).then(factor => factor ? this.client.mfa.unenroll({factorId:factor === null || factor === void 0 ? void 0 : factor.id}) : void 0), {data:null, error:enrollError};\n        }\n        const {data:challengeResponse, error:challengeError} = await this._challenge({factorId:factor.id, friendlyName:factor.friendly_name, webauthn:{rpId, rpOrigins}, signal}, {create:overrides});\n        return challengeResponse ? this._verify({factorId:factor.id, challengeId:challengeResponse.challengeId, webauthn:{rpId, rpOrigins, type:challengeResponse.webauthn.type, credential_response:challengeResponse.webauthn.credential_response}}) : {data:null, error:challengeError};\n      } catch (error) {\n        return (0,errors_1.isAuthError)(error) ? {data:null, error} : {data:null, error:new errors_1.AuthUnknownError(\"Unexpected error in register\", error)};\n      }\n    }\n  }\n  exports.WebAuthnApi = WebAuthnApi;\n};\n","~:source","shadow$provide[\"module$node_modules$$supabase$auth_js$dist$main$lib$webauthn\"] = function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebAuthnApi = exports.DEFAULT_REQUEST_OPTIONS = exports.DEFAULT_CREATION_OPTIONS = exports.webAuthnAbortService = exports.WebAuthnAbortService = exports.identifyAuthenticationError = exports.identifyRegistrationError = exports.isWebAuthnError = exports.WebAuthnError = void 0;\nexports.deserializeCredentialCreationOptions = deserializeCredentialCreationOptions;\nexports.deserializeCredentialRequestOptions = deserializeCredentialRequestOptions;\nexports.serializeCredentialCreationResponse = serializeCredentialCreationResponse;\nexports.serializeCredentialRequestResponse = serializeCredentialRequestResponse;\nexports.isValidDomain = isValidDomain;\nexports.createCredential = createCredential;\nexports.getCredential = getCredential;\nexports.mergeCredentialCreationOptions = mergeCredentialCreationOptions;\nexports.mergeCredentialRequestOptions = mergeCredentialRequestOptions;\nconst tslib_1 = require(\"tslib\");\nconst base64url_1 = require(\"./base64url\");\nconst errors_1 = require(\"./errors\");\nconst helpers_1 = require(\"./helpers\");\nconst webauthn_errors_1 = require(\"./webauthn.errors\");\nObject.defineProperty(exports, \"identifyAuthenticationError\", { enumerable: true, get: function () { return webauthn_errors_1.identifyAuthenticationError; } });\nObject.defineProperty(exports, \"identifyRegistrationError\", { enumerable: true, get: function () { return webauthn_errors_1.identifyRegistrationError; } });\nObject.defineProperty(exports, \"isWebAuthnError\", { enumerable: true, get: function () { return webauthn_errors_1.isWebAuthnError; } });\nObject.defineProperty(exports, \"WebAuthnError\", { enumerable: true, get: function () { return webauthn_errors_1.WebAuthnError; } });\n/**\n * WebAuthn abort service to manage ceremony cancellation.\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\n *\n * @experimental This class is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\n */\nclass WebAuthnAbortService {\n    /**\n     * Create an abort signal for a new WebAuthn operation.\n     * Automatically cancels any existing operation.\n     *\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\n     */\n    createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    /**\n     * Manually cancel the current WebAuthn operation.\n     * Useful for cleaning up when user cancels or navigates away.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\n     */\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nexports.WebAuthnAbortService = WebAuthnAbortService;\n/**\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\n *\n * @experimental This instance is experimental and may change in future releases\n */\nexports.webAuthnAbortService = new WebAuthnAbortService();\n/**\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\n */\nfunction deserializeCredentialCreationOptions(options) {\n    if (!options) {\n        throw new Error('Credential creation options are required');\n    }\n    // Check if the native parseCreationOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== 'undefined' &&\n        'parseCreationOptionsFromJSON' in PublicKeyCredential &&\n        typeof PublicKeyCredential\n            .parseCreationOptionsFromJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseCreationOptionsFromJSON(\n        /** we assert the options here as typescript still doesn't know about future webauthn types */\n        options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = tslib_1.__rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"user\", \"excludeCredentials\"]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\n    // Convert user.id from base64url to ArrayBuffer\n    const user = Object.assign(Object.assign({}, userOpts), { id: (0, base64url_1.base64UrlToUint8Array)(userOpts.id).buffer });\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), { challenge,\n        user });\n    // Only add excludeCredentials if it exists\n    if (excludeCredentials && excludeCredentials.length > 0) {\n        result.excludeCredentials = new Array(excludeCredentials.length);\n        for (let i = 0; i < excludeCredentials.length; i++) {\n            const cred = excludeCredentials[i];\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports });\n        }\n    }\n    return result;\n}\n/**\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\n */\nfunction deserializeCredentialRequestOptions(options) {\n    if (!options) {\n        throw new Error('Credential request options are required');\n    }\n    // Check if the native parseRequestOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== 'undefined' &&\n        'parseRequestOptionsFromJSON' in PublicKeyCredential &&\n        typeof PublicKeyCredential\n            .parseRequestOptionsFromJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = tslib_1.__rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"allowCredentials\"]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), { challenge });\n    // Only add allowCredentials if it exists\n    if (allowCredentials && allowCredentials.length > 0) {\n        result.allowCredentials = new Array(allowCredentials.length);\n        for (let i = 0; i < allowCredentials.length; i++) {\n            const cred = allowCredentials[i];\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports });\n        }\n    }\n    return result;\n}\n/**\n * Convert a registration/enrollment credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */\nfunction serializeCredentialCreationResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    const credentialWithAttachment = credential;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            attestationObject: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON)),\n        },\n        type: 'public-key',\n        clientExtensionResults: credential.getClientExtensionResults(),\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\n    };\n}\n/**\n * Convert an authentication/verification credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */\nfunction serializeCredentialRequestResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    // Fallback to manual conversion for browsers that don't support toJSON\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n    const credentialWithAttachment = credential;\n    const clientExtensionResults = credential.getClientExtensionResults();\n    const assertionResponse = credential.response;\n    return {\n        id: credential.id,\n        rawId: credential.id, // W3C spec expects rawId to match id for JSON format\n        response: {\n            authenticatorData: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\n            signature: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\n            userHandle: assertionResponse.userHandle\n                ? (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle))\n                : undefined,\n        },\n        type: 'public-key',\n        clientExtensionResults,\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\n    };\n}\n/**\n * A simple test to determine if a hostname is a properly-formatted domain name.\n * Considers localhost valid for development environments.\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n *\n * @param {string} hostname - The hostname to validate\n * @returns {boolean} True if valid domain or localhost\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\n */\nfunction isValidDomain(hostname) {\n    return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n/**\n * Determine if the browser is capable of WebAuthn.\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\n *\n * @returns {boolean} True if browser supports WebAuthn\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\n */\nfunction browserSupportsWebAuthn() {\n    var _a, _b;\n    return !!((0, helpers_1.isBrowser)() &&\n        'PublicKeyCredential' in window &&\n        window.PublicKeyCredential &&\n        'credentials' in navigator &&\n        typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' &&\n        typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');\n}\n/**\n * Create a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.create() with error handling.\n *\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\n */\nasync function createCredential(options) {\n    try {\n        const response = await navigator.credentials.create(\n        /** we assert the type here until typescript types are updated */\n        options);\n        if (!response) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\n            };\n        }\n        return { data: response, error: null };\n    }\n    catch (err) {\n        return {\n            data: null,\n            error: (0, webauthn_errors_1.identifyRegistrationError)({\n                error: err,\n                options,\n            }),\n        };\n    }\n}\n/**\n * Get a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.get() with error handling.\n *\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\n */\nasync function getCredential(options) {\n    try {\n        const response = await navigator.credentials.get(\n        /** we assert the type here until typescript types are updated */\n        options);\n        if (!response) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\n            };\n        }\n        return { data: response, error: null };\n    }\n    catch (err) {\n        return {\n            data: null,\n            error: (0, webauthn_errors_1.identifyAuthenticationError)({\n                error: err,\n                options,\n            }),\n        };\n    }\n}\nexports.DEFAULT_CREATION_OPTIONS = {\n    hints: ['security-key'],\n    authenticatorSelection: {\n        authenticatorAttachment: 'cross-platform',\n        requireResidentKey: false,\n        /** set to preferred because older yubikeys don't have PIN/Biometric */\n        userVerification: 'preferred',\n        residentKey: 'discouraged',\n    },\n    attestation: 'direct',\n};\nexports.DEFAULT_REQUEST_OPTIONS = {\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\n    userVerification: 'preferred',\n    hints: ['security-key'],\n    attestation: 'direct',\n};\nfunction deepMerge(...sources) {\n    const isObject = (val) => val !== null && typeof val === 'object' && !Array.isArray(val);\n    const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n    const result = {};\n    for (const source of sources) {\n        if (!source)\n            continue;\n        for (const key in source) {\n            const value = source[key];\n            if (value === undefined)\n                continue;\n            if (Array.isArray(value)) {\n                // preserve array reference, including unions like AuthenticatorTransport[]\n                result[key] = value;\n            }\n            else if (isArrayBufferLike(value)) {\n                result[key] = value;\n            }\n            else if (isObject(value)) {\n                const existing = result[key];\n                if (isObject(existing)) {\n                    result[key] = deepMerge(existing, value);\n                }\n                else {\n                    result[key] = deepMerge(value);\n                }\n            }\n            else {\n                result[key] = value;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Merges WebAuthn credential creation options with overrides.\n * Sets sensible defaults for authenticator selection and extensions.\n *\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\n * @param {string} friendlyName - Optional friendly name for the credential\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\n */\nfunction mergeCredentialCreationOptions(baseOptions, overrides) {\n    return deepMerge(exports.DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * Merges WebAuthn credential request options with overrides.\n * Sets sensible defaults for user verification and hints.\n *\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\n */\nfunction mergeCredentialRequestOptions(baseOptions, overrides) {\n    return deepMerge(exports.DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * WebAuthn API wrapper for Supabase Auth.\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\n *\n * @experimental This API is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\n */\nclass WebAuthnApi {\n    constructor(client) {\n        this.client = client;\n        // Bind all methods so they can be destructured\n        this.enroll = this._enroll.bind(this);\n        this.challenge = this._challenge.bind(this);\n        this.verify = this._verify.bind(this);\n        this.authenticate = this._authenticate.bind(this);\n        this.register = this._register.bind(this);\n    }\n    /**\n     * Enroll a new WebAuthn factor.\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\n     */\n    async _enroll(params) {\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: 'webauthn' }));\n    }\n    /**\n     * Challenge for WebAuthn credential creation or authentication.\n     * Combines server challenge with browser credential operations.\n     * Handles both registration (create) and authentication (request) flows.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\n     */\n    async _challenge({ factorId, webauthn, friendlyName, signal, }, overrides) {\n        var _a;\n        try {\n            // Get challenge from server using the client's MFA methods\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\n                factorId,\n                webauthn,\n            });\n            if (!challengeResponse) {\n                return { data: null, error: challengeError };\n            }\n            const abortSignal = signal !== null && signal !== void 0 ? signal : exports.webAuthnAbortService.createNewAbortSignal();\n            /** webauthn will fail if either of the name/displayname are blank */\n            if (challengeResponse.webauthn.type === 'create') {\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\n                if (!user.name) {\n                    // Preserve original format: use friendlyName if provided, otherwise fetch fallback\n                    // This maintains backward compatibility with the ${user.id}:${name} format\n                    const nameToUse = friendlyName;\n                    if (!nameToUse) {\n                        // Only fetch user data if friendlyName is not provided (bug fix for null friendlyName)\n                        const currentUser = await this.client.getUser();\n                        const userData = currentUser.data.user;\n                        const fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || 'User';\n                        user.name = `${user.id}:${fallbackName}`;\n                    }\n                    else {\n                        user.name = `${user.id}:${nameToUse}`;\n                    }\n                }\n                if (!user.displayName) {\n                    user.displayName = user.name;\n                }\n            }\n            switch (challengeResponse.webauthn.type) {\n                case 'create': {\n                    const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n                    const { data, error } = await createCredential({\n                        publicKey: options,\n                        signal: abortSignal,\n                    });\n                    if (data) {\n                        return {\n                            data: {\n                                factorId,\n                                challengeId: challengeResponse.id,\n                                webauthn: {\n                                    type: challengeResponse.webauthn.type,\n                                    credential_response: data,\n                                },\n                            },\n                            error: null,\n                        };\n                    }\n                    return { data: null, error };\n                }\n                case 'request': {\n                    const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n                    const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));\n                    if (data) {\n                        return {\n                            data: {\n                                factorId,\n                                challengeId: challengeResponse.id,\n                                webauthn: {\n                                    type: challengeResponse.webauthn.type,\n                                    credential_response: data,\n                                },\n                            },\n                            error: null,\n                        };\n                    }\n                    return { data: null, error };\n                }\n            }\n        }\n        catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            return {\n                data: null,\n                error: new errors_1.AuthUnknownError('Unexpected error in challenge', error),\n            };\n        }\n    }\n    /**\n     * Verify a WebAuthn credential with the server.\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Verification parameters\n     * @param {string} params.challengeId - ID of the challenge being verified\n     * @param {string} params.factorId - ID of the WebAuthn factor\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\n     * */\n    async _verify({ challengeId, factorId, webauthn, }) {\n        return this.client.mfa.verify({\n            factorId,\n            challengeId,\n            webauthn: webauthn,\n        });\n    }\n    /**\n     * Complete WebAuthn authentication flow.\n     * Performs challenge and verification in a single operation for existing credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Authentication parameters\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\n     * @param {Object} params.webauthn - WebAuthn configuration\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\n     */\n    async _authenticate({ factorId, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new errors_1.AuthError('rpId is required for WebAuthn authentication'),\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\n                };\n            }\n            // Get challenge and credential\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\n                factorId,\n                webauthn: { rpId, rpOrigins },\n                signal,\n            }, { request: overrides });\n            if (!challengeResponse) {\n                return { data: null, error: challengeError };\n            }\n            const { webauthn } = challengeResponse;\n            // Verify credential\n            return this._verify({\n                factorId,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    type: webauthn.type,\n                    rpId,\n                    rpOrigins,\n                    credential_response: webauthn.credential_response,\n                },\n            });\n        }\n        catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            return {\n                data: null,\n                error: new errors_1.AuthUnknownError('Unexpected error in authenticate', error),\n            };\n        }\n    }\n    /**\n     * Complete WebAuthn registration flow.\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Registration parameters\n     * @param {string} params.friendlyName - User-friendly name for the credential\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.signal - Optional abort signal\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\n     */\n    async _register({ friendlyName, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new errors_1.AuthError('rpId is required for WebAuthn registration'),\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\n                };\n            }\n            // Enroll factor\n            const { data: factor, error: enrollError } = await this._enroll({\n                friendlyName,\n            });\n            if (!factor) {\n                await this.client.mfa\n                    .listFactors()\n                    .then((factors) => {\n                    var _a;\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v) => v.factor_type === 'webauthn' &&\n                        v.friendly_name === friendlyName &&\n                        v.status !== 'unverified');\n                })\n                    .then((factor) => (factor ? this.client.mfa.unenroll({ factorId: factor === null || factor === void 0 ? void 0 : factor.id }) : void 0));\n                return { data: null, error: enrollError };\n            }\n            // Get challenge and create credential\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\n                factorId: factor.id,\n                friendlyName: factor.friendly_name,\n                webauthn: { rpId, rpOrigins },\n                signal,\n            }, {\n                create: overrides,\n            });\n            if (!challengeResponse) {\n                return { data: null, error: challengeError };\n            }\n            return this._verify({\n                factorId: factor.id,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    rpId,\n                    rpOrigins,\n                    type: challengeResponse.webauthn.type,\n                    credential_response: challengeResponse.webauthn.credential_response,\n                },\n            });\n        }\n        catch (error) {\n            if ((0, errors_1.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            return {\n                data: null,\n                error: new errors_1.AuthUnknownError('Unexpected error in register', error),\n            };\n        }\n    }\n}\nexports.WebAuthnApi = WebAuthnApi;\n//# sourceMappingURL=webauthn.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$tslib$tslib","~$shadow.js","~$module$node_modules$$supabase$auth_js$dist$main$lib$base64url","~$module$node_modules$$supabase$auth_js$dist$main$lib$errors","~$module$node_modules$$supabase$auth_js$dist$main$lib$helpers","~$module$node_modules$$supabase$auth_js$dist$main$lib$webauthn_errors"]],"~:properties",["^5",["clientDataJSON","rawId","allowCredentials","authenticate","webAuthnAbortService","attestation","deserializeCredentialCreationOptions","deserializeCredentialRequestOptions","userVerification","userHandle","displayName","clientExtensionResults","user","__esModule","excludeCredentials","challengeId","serializeCredentialCreationResponse","error","rpId","createCredential","id","publicKey","getCredential","signal","factorType","name","challenge","WebAuthnAbortService","transports","value","verify","hints","authenticatorAttachment","enumerable","friendlyName","attestationObject","request","rpOrigins","identifyRegistrationError","authenticatorSelection","authenticatorData","signature","requireResidentKey","register","DEFAULT_REQUEST_OPTIONS","type","isWebAuthnError","serializeCredentialRequestResponse","enroll","mergeCredentialRequestOptions","credential_response","identifyAuthenticationError","create","factorId","response","mergeCredentialCreationOptions","webauthn","WebAuthnError","DEFAULT_CREATION_OPTIONS","client","options","data","get","WebAuthnApi","residentKey","controller","isValidDomain"]],"~:compiled-at",1771981597335,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$auth_js$dist$main$lib$webauthn.js\",\n\"lineCount\":235,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/auth-js/dist/main/lib/webauthn.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$supabase$auth_js$dist$main$lib$webauthn\\\"] = function(require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.WebAuthnApi = exports.DEFAULT_REQUEST_OPTIONS = exports.DEFAULT_CREATION_OPTIONS = exports.webAuthnAbortService = exports.WebAuthnAbortService = exports.identifyAuthenticationError = exports.identifyRegistrationError = exports.isWebAuthnError = exports.WebAuthnError = void 0;\\nexports.deserializeCredentialCreationOptions = deserializeCredentialCreationOptions;\\nexports.deserializeCredentialRequestOptions = deserializeCredentialRequestOptions;\\nexports.serializeCredentialCreationResponse = serializeCredentialCreationResponse;\\nexports.serializeCredentialRequestResponse = serializeCredentialRequestResponse;\\nexports.isValidDomain = isValidDomain;\\nexports.createCredential = createCredential;\\nexports.getCredential = getCredential;\\nexports.mergeCredentialCreationOptions = mergeCredentialCreationOptions;\\nexports.mergeCredentialRequestOptions = mergeCredentialRequestOptions;\\nconst tslib_1 = require(\\\"tslib\\\");\\nconst base64url_1 = require(\\\"./base64url\\\");\\nconst errors_1 = require(\\\"./errors\\\");\\nconst helpers_1 = require(\\\"./helpers\\\");\\nconst webauthn_errors_1 = require(\\\"./webauthn.errors\\\");\\nObject.defineProperty(exports, \\\"identifyAuthenticationError\\\", { enumerable: true, get: function () { return webauthn_errors_1.identifyAuthenticationError; } });\\nObject.defineProperty(exports, \\\"identifyRegistrationError\\\", { enumerable: true, get: function () { return webauthn_errors_1.identifyRegistrationError; } });\\nObject.defineProperty(exports, \\\"isWebAuthnError\\\", { enumerable: true, get: function () { return webauthn_errors_1.isWebAuthnError; } });\\nObject.defineProperty(exports, \\\"WebAuthnError\\\", { enumerable: true, get: function () { return webauthn_errors_1.WebAuthnError; } });\\n/**\\n * WebAuthn abort service to manage ceremony cancellation.\\n * Ensures only one WebAuthn ceremony is active at a time to prevent \\\"operation already in progress\\\" errors.\\n *\\n * @experimental This class is experimental and may change in future releases\\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\\n */\\nclass WebAuthnAbortService {\\n    /**\\n     * Create an abort signal for a new WebAuthn operation.\\n     * Automatically cancels any existing operation.\\n     *\\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\\n     */\\n    createNewAbortSignal() {\\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\\n        if (this.controller) {\\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\\n            abortError.name = 'AbortError';\\n            this.controller.abort(abortError);\\n        }\\n        const newController = new AbortController();\\n        this.controller = newController;\\n        return newController.signal;\\n    }\\n    /**\\n     * Manually cancel the current WebAuthn operation.\\n     * Useful for cleaning up when user cancels or navigates away.\\n     *\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\\n     */\\n    cancelCeremony() {\\n        if (this.controller) {\\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\\n            abortError.name = 'AbortError';\\n            this.controller.abort(abortError);\\n            this.controller = undefined;\\n        }\\n    }\\n}\\nexports.WebAuthnAbortService = WebAuthnAbortService;\\n/**\\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\\n * This prevents \\\"operation already in progress\\\" errors when retrying WebAuthn operations.\\n *\\n * @experimental This instance is experimental and may change in future releases\\n */\\nexports.webAuthnAbortService = new WebAuthnAbortService();\\n/**\\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\\n * as required by the WebAuthn browser API.\\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\\n *\\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\\n */\\nfunction deserializeCredentialCreationOptions(options) {\\n    if (!options) {\\n        throw new Error('Credential creation options are required');\\n    }\\n    // Check if the native parseCreationOptionsFromJSON method is available\\n    if (typeof PublicKeyCredential !== 'undefined' &&\\n        'parseCreationOptionsFromJSON' in PublicKeyCredential &&\\n        typeof PublicKeyCredential\\n            .parseCreationOptionsFromJSON === 'function') {\\n        // Use the native WebAuthn Level 3 method\\n        return PublicKeyCredential.parseCreationOptionsFromJSON(\\n        /** we assert the options here as typescript still doesn't know about future webauthn types */\\n        options);\\n    }\\n    // Fallback to manual parsing for browsers that don't support the native method\\n    // Destructure to separate fields that need transformation\\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = tslib_1.__rest(options\\n    // Convert challenge from base64url to ArrayBuffer\\n    , [\\\"challenge\\\", \\\"user\\\", \\\"excludeCredentials\\\"]);\\n    // Convert challenge from base64url to ArrayBuffer\\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\\n    // Convert user.id from base64url to ArrayBuffer\\n    const user = Object.assign(Object.assign({}, userOpts), { id: (0, base64url_1.base64UrlToUint8Array)(userOpts.id).buffer });\\n    // Build the result object\\n    const result = Object.assign(Object.assign({}, restOptions), { challenge,\\n        user });\\n    // Only add excludeCredentials if it exists\\n    if (excludeCredentials && excludeCredentials.length > 0) {\\n        result.excludeCredentials = new Array(excludeCredentials.length);\\n        for (let i = 0; i < excludeCredentials.length; i++) {\\n            const cred = excludeCredentials[i];\\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \\n                // Cast transports to handle future transport types like \\\"cable\\\"\\n                transports: cred.transports });\\n        }\\n    }\\n    return result;\\n}\\n/**\\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\\n * as required by the WebAuthn browser API.\\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\\n *\\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\\n */\\nfunction deserializeCredentialRequestOptions(options) {\\n    if (!options) {\\n        throw new Error('Credential request options are required');\\n    }\\n    // Check if the native parseRequestOptionsFromJSON method is available\\n    if (typeof PublicKeyCredential !== 'undefined' &&\\n        'parseRequestOptionsFromJSON' in PublicKeyCredential &&\\n        typeof PublicKeyCredential\\n            .parseRequestOptionsFromJSON === 'function') {\\n        // Use the native WebAuthn Level 3 method\\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\\n    }\\n    // Fallback to manual parsing for browsers that don't support the native method\\n    // Destructure to separate fields that need transformation\\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = tslib_1.__rest(options\\n    // Convert challenge from base64url to ArrayBuffer\\n    , [\\\"challenge\\\", \\\"allowCredentials\\\"]);\\n    // Convert challenge from base64url to ArrayBuffer\\n    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;\\n    // Build the result object\\n    const result = Object.assign(Object.assign({}, restOptions), { challenge });\\n    // Only add allowCredentials if it exists\\n    if (allowCredentials && allowCredentials.length > 0) {\\n        result.allowCredentials = new Array(allowCredentials.length);\\n        for (let i = 0; i < allowCredentials.length; i++) {\\n            const cred = allowCredentials[i];\\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \\n                // Cast transports to handle future transport types like \\\"cable\\\"\\n                transports: cred.transports });\\n        }\\n    }\\n    return result;\\n}\\n/**\\n * Convert a registration/enrollment credential response to server format.\\n * Serializes binary fields to base64url for JSON transmission.\\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\\n *\\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\\n */\\nfunction serializeCredentialCreationResponse(credential) {\\n    var _a;\\n    // Check if the credential instance has the toJSON method\\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\\n        // Use the native WebAuthn Level 3 method\\n        return credential.toJSON();\\n    }\\n    const credentialWithAttachment = credential;\\n    return {\\n        id: credential.id,\\n        rawId: credential.id,\\n        response: {\\n            attestationObject: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON)),\\n        },\\n        type: 'public-key',\\n        clientExtensionResults: credential.getClientExtensionResults(),\\n        // Convert null to undefined and cast to AuthenticatorAttachment type\\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\\n    };\\n}\\n/**\\n * Convert an authentication/verification credential response to server format.\\n * Serializes binary fields to base64url for JSON transmission.\\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\\n *\\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\\n */\\nfunction serializeCredentialRequestResponse(credential) {\\n    var _a;\\n    // Check if the credential instance has the toJSON method\\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\\n        // Use the native WebAuthn Level 3 method\\n        return credential.toJSON();\\n    }\\n    // Fallback to manual conversion for browsers that don't support toJSON\\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\\n    const credentialWithAttachment = credential;\\n    const clientExtensionResults = credential.getClientExtensionResults();\\n    const assertionResponse = credential.response;\\n    return {\\n        id: credential.id,\\n        rawId: credential.id, // W3C spec expects rawId to match id for JSON format\\n        response: {\\n            authenticatorData: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\\n            clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\\n            signature: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\\n            userHandle: assertionResponse.userHandle\\n                ? (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle))\\n                : undefined,\\n        },\\n        type: 'public-key',\\n        clientExtensionResults,\\n        // Convert null to undefined and cast to AuthenticatorAttachment type\\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\\n    };\\n}\\n/**\\n * A simple test to determine if a hostname is a properly-formatted domain name.\\n * Considers localhost valid for development environments.\\n *\\n * A \\\"valid domain\\\" is defined here: https://url.spec.whatwg.org/#valid-domain\\n *\\n * Regex sourced from here:\\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\\n *\\n * @param {string} hostname - The hostname to validate\\n * @returns {boolean} True if valid domain or localhost\\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\\n */\\nfunction isValidDomain(hostname) {\\n    return (\\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\\\.)+[a-z]{2,}$/i.test(hostname));\\n}\\n/**\\n * Determine if the browser is capable of WebAuthn.\\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\\n *\\n * @returns {boolean} True if browser supports WebAuthn\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\\n */\\nfunction browserSupportsWebAuthn() {\\n    var _a, _b;\\n    return !!((0, helpers_1.isBrowser)() &&\\n        'PublicKeyCredential' in window &&\\n        window.PublicKeyCredential &&\\n        'credentials' in navigator &&\\n        typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' &&\\n        typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');\\n}\\n/**\\n * Create a WebAuthn credential using the browser's credentials API.\\n * Wraps navigator.credentials.create() with error handling.\\n *\\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\\n */\\nasync function createCredential(options) {\\n    try {\\n        const response = await navigator.credentials.create(\\n        /** we assert the type here until typescript types are updated */\\n        options);\\n        if (!response) {\\n            return {\\n                data: null,\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\\n            };\\n        }\\n        if (!(response instanceof PublicKeyCredential)) {\\n            return {\\n                data: null,\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\\n            };\\n        }\\n        return { data: response, error: null };\\n    }\\n    catch (err) {\\n        return {\\n            data: null,\\n            error: (0, webauthn_errors_1.identifyRegistrationError)({\\n                error: err,\\n                options,\\n            }),\\n        };\\n    }\\n}\\n/**\\n * Get a WebAuthn credential using the browser's credentials API.\\n * Wraps navigator.credentials.get() with error handling.\\n *\\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\\n */\\nasync function getCredential(options) {\\n    try {\\n        const response = await navigator.credentials.get(\\n        /** we assert the type here until typescript types are updated */\\n        options);\\n        if (!response) {\\n            return {\\n                data: null,\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Empty credential response', response),\\n            };\\n        }\\n        if (!(response instanceof PublicKeyCredential)) {\\n            return {\\n                data: null,\\n                error: new webauthn_errors_1.WebAuthnUnknownError('Browser returned unexpected credential type', response),\\n            };\\n        }\\n        return { data: response, error: null };\\n    }\\n    catch (err) {\\n        return {\\n            data: null,\\n            error: (0, webauthn_errors_1.identifyAuthenticationError)({\\n                error: err,\\n                options,\\n            }),\\n        };\\n    }\\n}\\nexports.DEFAULT_CREATION_OPTIONS = {\\n    hints: ['security-key'],\\n    authenticatorSelection: {\\n        authenticatorAttachment: 'cross-platform',\\n        requireResidentKey: false,\\n        /** set to preferred because older yubikeys don't have PIN/Biometric */\\n        userVerification: 'preferred',\\n        residentKey: 'discouraged',\\n    },\\n    attestation: 'direct',\\n};\\nexports.DEFAULT_REQUEST_OPTIONS = {\\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\\n    userVerification: 'preferred',\\n    hints: ['security-key'],\\n    attestation: 'direct',\\n};\\nfunction deepMerge(...sources) {\\n    const isObject = (val) => val !== null && typeof val === 'object' && !Array.isArray(val);\\n    const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);\\n    const result = {};\\n    for (const source of sources) {\\n        if (!source)\\n            continue;\\n        for (const key in source) {\\n            const value = source[key];\\n            if (value === undefined)\\n                continue;\\n            if (Array.isArray(value)) {\\n                // preserve array reference, including unions like AuthenticatorTransport[]\\n                result[key] = value;\\n            }\\n            else if (isArrayBufferLike(value)) {\\n                result[key] = value;\\n            }\\n            else if (isObject(value)) {\\n                const existing = result[key];\\n                if (isObject(existing)) {\\n                    result[key] = deepMerge(existing, value);\\n                }\\n                else {\\n                    result[key] = deepMerge(value);\\n                }\\n            }\\n            else {\\n                result[key] = value;\\n            }\\n        }\\n    }\\n    return result;\\n}\\n/**\\n * Merges WebAuthn credential creation options with overrides.\\n * Sets sensible defaults for authenticator selection and extensions.\\n *\\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\\n * @param {string} friendlyName - Optional friendly name for the credential\\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\\n */\\nfunction mergeCredentialCreationOptions(baseOptions, overrides) {\\n    return deepMerge(exports.DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\\n}\\n/**\\n * Merges WebAuthn credential request options with overrides.\\n * Sets sensible defaults for user verification and hints.\\n *\\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\\n */\\nfunction mergeCredentialRequestOptions(baseOptions, overrides) {\\n    return deepMerge(exports.DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\\n}\\n/**\\n * WebAuthn API wrapper for Supabase Auth.\\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\\n *\\n * @experimental This API is experimental and may change in future releases\\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\\n */\\nclass WebAuthnApi {\\n    constructor(client) {\\n        this.client = client;\\n        // Bind all methods so they can be destructured\\n        this.enroll = this._enroll.bind(this);\\n        this.challenge = this._challenge.bind(this);\\n        this.verify = this._verify.bind(this);\\n        this.authenticate = this._authenticate.bind(this);\\n        this.register = this._register.bind(this);\\n    }\\n    /**\\n     * Enroll a new WebAuthn factor.\\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\\n     *\\n     * @experimental This method is experimental and may change in future releases\\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\\n     */\\n    async _enroll(params) {\\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: 'webauthn' }));\\n    }\\n    /**\\n     * Challenge for WebAuthn credential creation or authentication.\\n     * Combines server challenge with browser credential operations.\\n     * Handles both registration (create) and authentication (request) flows.\\n     *\\n     * @experimental This method is experimental and may change in future releases\\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\\n     */\\n    async _challenge({ factorId, webauthn, friendlyName, signal, }, overrides) {\\n        var _a;\\n        try {\\n            // Get challenge from server using the client's MFA methods\\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\\n                factorId,\\n                webauthn,\\n            });\\n            if (!challengeResponse) {\\n                return { data: null, error: challengeError };\\n            }\\n            const abortSignal = signal !== null && signal !== void 0 ? signal : exports.webAuthnAbortService.createNewAbortSignal();\\n            /** webauthn will fail if either of the name/displayname are blank */\\n            if (challengeResponse.webauthn.type === 'create') {\\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\\n                if (!user.name) {\\n                    // Preserve original format: use friendlyName if provided, otherwise fetch fallback\\n                    // This maintains backward compatibility with the ${user.id}:${name} format\\n                    const nameToUse = friendlyName;\\n                    if (!nameToUse) {\\n                        // Only fetch user data if friendlyName is not provided (bug fix for null friendlyName)\\n                        const currentUser = await this.client.getUser();\\n                        const userData = currentUser.data.user;\\n                        const fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || 'User';\\n                        user.name = `${user.id}:${fallbackName}`;\\n                    }\\n                    else {\\n                        user.name = `${user.id}:${nameToUse}`;\\n                    }\\n                }\\n                if (!user.displayName) {\\n                    user.displayName = user.name;\\n                }\\n            }\\n            switch (challengeResponse.webauthn.type) {\\n                case 'create': {\\n                    const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\\n                    const { data, error } = await createCredential({\\n                        publicKey: options,\\n                        signal: abortSignal,\\n                    });\\n                    if (data) {\\n                        return {\\n                            data: {\\n                                factorId,\\n                                challengeId: challengeResponse.id,\\n                                webauthn: {\\n                                    type: challengeResponse.webauthn.type,\\n                                    credential_response: data,\\n                                },\\n                            },\\n                            error: null,\\n                        };\\n                    }\\n                    return { data: null, error };\\n                }\\n                case 'request': {\\n                    const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\\n                    const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));\\n                    if (data) {\\n                        return {\\n                            data: {\\n                                factorId,\\n                                challengeId: challengeResponse.id,\\n                                webauthn: {\\n                                    type: challengeResponse.webauthn.type,\\n                                    credential_response: data,\\n                                },\\n                            },\\n                            error: null,\\n                        };\\n                    }\\n                    return { data: null, error };\\n                }\\n            }\\n        }\\n        catch (error) {\\n            if ((0, errors_1.isAuthError)(error)) {\\n                return { data: null, error };\\n            }\\n            return {\\n                data: null,\\n                error: new errors_1.AuthUnknownError('Unexpected error in challenge', error),\\n            };\\n        }\\n    }\\n    /**\\n     * Verify a WebAuthn credential with the server.\\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\\n     *\\n     * @experimental This method is experimental and may change in future releases\\n     * @param {Object} params - Verification parameters\\n     * @param {string} params.challengeId - ID of the challenge being verified\\n     * @param {string} params.factorId - ID of the WebAuthn factor\\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\\n     * */\\n    async _verify({ challengeId, factorId, webauthn, }) {\\n        return this.client.mfa.verify({\\n            factorId,\\n            challengeId,\\n            webauthn: webauthn,\\n        });\\n    }\\n    /**\\n     * Complete WebAuthn authentication flow.\\n     * Performs challenge and verification in a single operation for existing credentials.\\n     *\\n     * @experimental This method is experimental and may change in future releases\\n     * @param {Object} params - Authentication parameters\\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\\n     * @param {Object} params.webauthn - WebAuthn configuration\\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\\n     */\\n    async _authenticate({ factorId, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\\n        if (!rpId) {\\n            return {\\n                data: null,\\n                error: new errors_1.AuthError('rpId is required for WebAuthn authentication'),\\n            };\\n        }\\n        try {\\n            if (!browserSupportsWebAuthn()) {\\n                return {\\n                    data: null,\\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\\n                };\\n            }\\n            // Get challenge and credential\\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\\n                factorId,\\n                webauthn: { rpId, rpOrigins },\\n                signal,\\n            }, { request: overrides });\\n            if (!challengeResponse) {\\n                return { data: null, error: challengeError };\\n            }\\n            const { webauthn } = challengeResponse;\\n            // Verify credential\\n            return this._verify({\\n                factorId,\\n                challengeId: challengeResponse.challengeId,\\n                webauthn: {\\n                    type: webauthn.type,\\n                    rpId,\\n                    rpOrigins,\\n                    credential_response: webauthn.credential_response,\\n                },\\n            });\\n        }\\n        catch (error) {\\n            if ((0, errors_1.isAuthError)(error)) {\\n                return { data: null, error };\\n            }\\n            return {\\n                data: null,\\n                error: new errors_1.AuthUnknownError('Unexpected error in authenticate', error),\\n            };\\n        }\\n    }\\n    /**\\n     * Complete WebAuthn registration flow.\\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\\n     *\\n     * @experimental This method is experimental and may change in future releases\\n     * @param {Object} params - Registration parameters\\n     * @param {string} params.friendlyName - User-friendly name for the credential\\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\\n     * @param {AbortSignal} params.signal - Optional abort signal\\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\\n     */\\n    async _register({ friendlyName, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, } = {}, }, overrides) {\\n        if (!rpId) {\\n            return {\\n                data: null,\\n                error: new errors_1.AuthError('rpId is required for WebAuthn registration'),\\n            };\\n        }\\n        try {\\n            if (!browserSupportsWebAuthn()) {\\n                return {\\n                    data: null,\\n                    error: new errors_1.AuthUnknownError('Browser does not support WebAuthn', null),\\n                };\\n            }\\n            // Enroll factor\\n            const { data: factor, error: enrollError } = await this._enroll({\\n                friendlyName,\\n            });\\n            if (!factor) {\\n                await this.client.mfa\\n                    .listFactors()\\n                    .then((factors) => {\\n                    var _a;\\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v) => v.factor_type === 'webauthn' &&\\n                        v.friendly_name === friendlyName &&\\n                        v.status !== 'unverified');\\n                })\\n                    .then((factor) => (factor ? this.client.mfa.unenroll({ factorId: factor === null || factor === void 0 ? void 0 : factor.id }) : void 0));\\n                return { data: null, error: enrollError };\\n            }\\n            // Get challenge and create credential\\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\\n                factorId: factor.id,\\n                friendlyName: factor.friendly_name,\\n                webauthn: { rpId, rpOrigins },\\n                signal,\\n            }, {\\n                create: overrides,\\n            });\\n            if (!challengeResponse) {\\n                return { data: null, error: challengeError };\\n            }\\n            return this._verify({\\n                factorId: factor.id,\\n                challengeId: challengeResponse.challengeId,\\n                webauthn: {\\n                    rpId,\\n                    rpOrigins,\\n                    type: challengeResponse.webauthn.type,\\n                    credential_response: challengeResponse.webauthn.credential_response,\\n                },\\n            });\\n        }\\n        catch (error) {\\n            if ((0, errors_1.isAuthError)(error)) {\\n                return { data: null, error };\\n            }\\n            return {\\n                data: null,\\n                error: new errors_1.AuthUnknownError('Unexpected error in register', error),\\n            };\\n        }\\n    }\\n}\\nexports.WebAuthnApi = WebAuthnApi;\\n//# sourceMappingURL=webauthn.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"browserSupportsWebAuthn\",\"_a\",\"_b\",\"helpers_1\",\"isBrowser\",\"window\",\"PublicKeyCredential\",\"navigator\",\"credentials\",\"create\",\"get\",\"createCredential\",\"options\",\"response\",\"data\",\"error\",\"webauthn_errors_1\",\"WebAuthnUnknownError\",\"err\",\"identifyRegistrationError\",\"getCredential\",\"identifyAuthenticationError\",\"deepMerge\",\"sources\",\"result\",\"source\",\"key\",\"value\",\"undefined\",\"Array\",\"isArray\",\"ArrayBuffer\",\"isView\",\"existing\",\"mergeCredentialCreationOptions\",\"baseOptions\",\"overrides\",\"DEFAULT_CREATION_OPTIONS\",\"mergeCredentialRequestOptions\",\"DEFAULT_REQUEST_OPTIONS\",\"Object\",\"defineProperty\",\"WebAuthnApi\",\"webAuthnAbortService\",\"WebAuthnAbortService\",\"isWebAuthnError\",\"WebAuthnError\",\"deserializeCredentialCreationOptions\",\"Error\",\"parseCreationOptionsFromJSON\",\"challengeStr\",\"userOpts\",\"excludeCredentials\",\"restOptions\",\"tslib_1\",\"__rest\",\"challenge\",\"base64url_1\",\"base64UrlToUint8Array\",\"buffer\",\"user\",\"assign\",\"id\",\"length\",\"i\",\"cred\",\"type\",\"transports\",\"deserializeCredentialRequestOptions\",\"parseRequestOptionsFromJSON\",\"allowCredentials\",\"serializeCredentialCreationResponse\",\"credential\",\"toJSON\",\"rawId\",\"attestationObject\",\"bytesToBase64URL\",\"Uint8Array\",\"clientDataJSON\",\"clientExtensionResults\",\"getClientExtensionResults\",\"authenticatorAttachment\",\"serializeCredentialRequestResponse\",\"assertionResponse\",\"authenticatorData\",\"signature\",\"userHandle\",\"isValidDomain\",\"hostname\",\"test\",\"errors_1\",\"enumerable\",\"createNewAbortSignal\",\"controller\",\"abortError\",\"name\",\"abort\",\"newController\",\"AbortController\",\"signal\",\"cancelCeremony\",\"hints\",\"authenticatorSelection\",\"requireResidentKey\",\"userVerification\",\"residentKey\",\"attestation\",\"constructor\",\"client\",\"enroll\",\"_enroll\",\"bind\",\"_challenge\",\"verify\",\"_verify\",\"authenticate\",\"_authenticate\",\"register\",\"_register\",\"params\",\"mfa\",\"factorType\",\"factorId\",\"webauthn\",\"friendlyName\",\"challengeResponse\",\"challengeError\",\"abortSignal\",\"credential_options\",\"publicKey\",\"userData\",\"currentUser\",\"getUser\",\"fallbackName\",\"user_metadata\",\"email\",\"displayName\",\"challengeId\",\"credential_response\",\"request\",\"isAuthError\",\"AuthUnknownError\",\"rpId\",\"location\",\"rpOrigins\",\"origin\",\"AuthError\",\"factor\",\"enrollError\",\"listFactors\",\"then\",\"factors\",\"all\",\"find\",\"v\",\"factor_type\",\"friendly_name\",\"status\",\"unenroll\"]\n}\n"]