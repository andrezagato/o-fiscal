["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/auth-js/dist/main/lib/locks.js"],"~:js","shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$locks = function(require, module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.ProcessLockAcquireTimeoutError = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = exports.internals = void 0;\n  exports.navigatorLock = async function(name, acquireTimeout, fn) {\n    exports.internals.debug && console.log(\"@supabase/gotrue-js: navigatorLock: acquire lock\", name, acquireTimeout);\n    const abortController = new globalThis.AbortController();\n    acquireTimeout > 0 && setTimeout(() => {\n      abortController.abort();\n      exports.internals.debug && console.log(\"@supabase/gotrue-js: navigatorLock acquire timed out\", name);\n    }, acquireTimeout);\n    await Promise.resolve();\n    try {\n      return await globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {mode:\"exclusive\", ifAvailable:!0} : {mode:\"exclusive\", signal:abortController.signal}, async lock => {\n        if (lock) {\n          exports.internals.debug && console.log(\"@supabase/gotrue-js: navigatorLock: acquired\", name, lock.name);\n          try {\n            return await fn();\n          } finally {\n            exports.internals.debug && console.log(\"@supabase/gotrue-js: navigatorLock: released\", name, lock.name);\n          }\n        } else {\n          if (acquireTimeout === 0) {\n            throw exports.internals.debug && console.log(\"@supabase/gotrue-js: navigatorLock: not immediately available\", name), new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n          }\n          if (exports.internals.debug) {\n            try {\n              const result = await globalThis.navigator.locks.query();\n              console.log(\"@supabase/gotrue-js: Navigator LockManager state\", JSON.stringify(result, null, \"  \"));\n            } catch (e) {\n              console.warn(\"@supabase/gotrue-js: Error when querying Navigator LockManager state\", e);\n            }\n          }\n          console.warn(\"@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\");\n          return await fn();\n        }\n      });\n    } catch (e) {\n      if ((e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" timed out waiting ${acquireTimeout}ms`);\n      }\n      throw e;\n    }\n  };\n  exports.processLock = async function(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve(), previousOperationHandled = (async() => {\n      try {\n        return await previousOperation, null;\n      } catch (e) {\n        return null;\n      }\n    })(), currentOperation = (async() => {\n      let timeoutId = null;\n      try {\n        const timeoutPromise = acquireTimeout >= 0 ? new Promise((_, reject) => {\n          timeoutId = setTimeout(() => {\n            console.warn(`@supabase/gotrue-js: Lock \"${name}\" acquisition timed out after ${acquireTimeout}ms. ` + \"This may be caused by another operation holding the lock. Consider increasing lockAcquireTimeout or checking for stuck operations.\");\n            reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \"${name}\" timed out`));\n          }, acquireTimeout);\n        }) : null;\n        await Promise.race([previousOperationHandled, timeoutPromise].filter(x => x));\n        timeoutId !== null && clearTimeout(timeoutId);\n      } catch (e) {\n        if (timeoutId !== null && clearTimeout(timeoutId), e && e.isAcquireTimeout) {\n          throw e;\n        }\n      }\n      return await fn();\n    })();\n    PROCESS_LOCKS[name] = (async() => {\n      try {\n        return await currentOperation;\n      } catch (e) {\n        if (e && e.isAcquireTimeout) {\n          try {\n            await previousOperation;\n          } catch (prevError) {\n          }\n          return null;\n        }\n        throw e;\n      }\n    })();\n    return await currentOperation;\n  };\n  require = require(\"module$node_modules$$supabase$auth_js$dist$main$lib$helpers\");\n  exports.internals = {debug:!!(globalThis && (0,require.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem(\"supabase.gotrue-js.locks.debug\") === \"true\")};\n  class LockAcquireTimeoutError extends Error {\n    constructor(message) {\n      super(message);\n      this.isAcquireTimeout = !0;\n    }\n  }\n  exports.LockAcquireTimeoutError = LockAcquireTimeoutError;\n  class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n  }\n  exports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;\n  class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n  }\n  exports.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;\n  const PROCESS_LOCKS = {};\n};\n","~:source","shadow$provide[\"module$node_modules$$supabase$auth_js$dist$main$lib$locks\"] = function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProcessLockAcquireTimeoutError = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = exports.internals = void 0;\nexports.navigatorLock = navigatorLock;\nexports.processLock = processLock;\nconst helpers_1 = require(\"./helpers\");\n/**\n * @experimental\n */\nexports.internals = {\n    /**\n     * @experimental\n     */\n    debug: !!(globalThis &&\n        (0, helpers_1.supportsLocalStorage)() &&\n        globalThis.localStorage &&\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n *\n * @example\n * ```ts\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * class CustomLockError extends LockAcquireTimeoutError {\n *   constructor() {\n *     super('Lock timed out')\n *   }\n * }\n * ```\n */\nclass LockAcquireTimeoutError extends Error {\n    constructor(message) {\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nexports.LockAcquireTimeoutError = LockAcquireTimeoutError;\n/**\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\n *\n * @example\n * ```ts\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\n * ```\n */\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nexports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;\n/**\n * Error thrown when the process-level lock helper cannot acquire a lock.\n *\n * @example\n * ```ts\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\n * ```\n */\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nexports.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await navigatorLock('sync-user', 1000, async () => {\n *   await refreshSession()\n * })\n * ```\n */\nasync function navigatorLock(name, acquireTimeout, fn) {\n    if (exports.internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n            if (exports.internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping with await Promise.resolve() is done as some libraries like zone.js\n    // patch the Promise object to track execution context. We use await instead of\n    // .then() to avoid Firefox content script security errors where accessing .then()\n    // on cross-context promises is forbidden.\n    await Promise.resolve();\n    try {\n        return await globalThis.navigator.locks.request(name, acquireTimeout === 0\n            ? {\n                mode: 'exclusive',\n                ifAvailable: true,\n            }\n            : {\n                mode: 'exclusive',\n                signal: abortController.signal,\n            }, async (lock) => {\n            if (lock) {\n                if (exports.internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n                }\n                try {\n                    return await fn();\n                }\n                finally {\n                    if (exports.internals.debug) {\n                        console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n                    }\n                }\n            }\n            else {\n                if (acquireTimeout === 0) {\n                    if (exports.internals.debug) {\n                        console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n                    }\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n                }\n                else {\n                    if (exports.internals.debug) {\n                        try {\n                            const result = await globalThis.navigator.locks.query();\n                            console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n                        }\n                        catch (e) {\n                            console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n                        }\n                    }\n                    // Browser is not following the Navigator LockManager spec, it\n                    // returned a null lock when we didn't use ifAvailable. So we can\n                    // pretend the lock is acquired in the name of backward compatibility\n                    // and user experience and just run the function.\n                    console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n                    return await fn();\n                }\n            }\n        });\n    }\n    catch (e) {\n        // When the AbortController times out, navigator.locks.request rejects with\n        // a DOMException named 'AbortError'. Convert this to NavigatorLockAcquireTimeoutError\n        // so callers can check error.isAcquireTimeout as documented.\n        if ((e === null || e === void 0 ? void 0 : e.name) === 'AbortError') {\n            throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" timed out waiting ${acquireTimeout}ms`);\n        }\n        throw e;\n    }\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await processLock('migrate', 5000, async () => {\n *   await runMigration()\n * })\n * ```\n */\nasync function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    // Wrap previousOperation to handle errors without using .catch()\n    // This avoids Firefox content script security errors\n    const previousOperationHandled = (async () => {\n        try {\n            await previousOperation;\n            return null;\n        }\n        catch (e) {\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }\n    })();\n    const currentOperation = (async () => {\n        let timeoutId = null;\n        try {\n            // Wait for either previous operation or timeout\n            const timeoutPromise = acquireTimeout >= 0\n                ? new Promise((_, reject) => {\n                    timeoutId = setTimeout(() => {\n                        console.warn(`@supabase/gotrue-js: Lock \"${name}\" acquisition timed out after ${acquireTimeout}ms. ` +\n                            'This may be caused by another operation holding the lock. ' +\n                            'Consider increasing lockAcquireTimeout or checking for stuck operations.');\n                        reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \"${name}\" timed out`));\n                    }, acquireTimeout);\n                })\n                : null;\n            await Promise.race([previousOperationHandled, timeoutPromise].filter((x) => x));\n            // If we reach here, previousOperationHandled won the race\n            // Clear the timeout to prevent false warnings\n            if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n            }\n        }\n        catch (e) {\n            // Clear the timeout on error path as well\n            if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n            }\n            // Re-throw timeout errors, ignore others\n            if (e && e.isAcquireTimeout) {\n                throw e;\n            }\n            // Fall through to run fn() - previous operation finished with error\n        }\n        // Previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    })();\n    PROCESS_LOCKS[name] = (async () => {\n        try {\n            return await currentOperation;\n        }\n        catch (e) {\n            if (e && e.isAcquireTimeout) {\n                // if the current operation timed out, it doesn't mean that the previous\n                // operation finished, so we need continue waiting for it to finish\n                try {\n                    await previousOperation;\n                }\n                catch (prevError) {\n                    // Ignore previous operation errors\n                }\n                return null;\n            }\n            throw e;\n        }\n    })();\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n}\n//# sourceMappingURL=locks.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$supabase$auth_js$dist$main$lib$helpers"]],"~:properties",["^5",["isAcquireTimeout","__esModule","navigatorLock","mode","signal","ProcessLockAcquireTimeoutError","value","NavigatorLockAcquireTimeoutError","debug","ifAvailable","processLock","internals","LockAcquireTimeoutError"]],"~:compiled-at",1771644653499,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$auth_js$dist$main$lib$locks.js\",\n\"lineCount\":103,\n\"mappings\":\"AAAAA,cAAA,CAAA,yDAAA,GAA8E,QAAQ,CAACC,OAAD,EAASC,MAAT,EAAgBC,OAAhB,CAAyB;AAE/GC,QAAOC,CAAAA,cAAP,CAAsBF,OAAtB,EAA+B,YAA/B,EAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAAA;AACAH,SAAQI,CAAAA,8BAAR,GAAyCJ,OAAQK,CAAAA,gCAAjD,GAAoFL,OAAQM,CAAAA,uBAA5F,GAAsHN,OAAQO,CAAAA,SAA9H,GAA0I,IAAK,EAA/I;AACAP,SAAQQ,CAAAA,aAAR,GA+FAA,cAA4B,CAACC,IAAD,EAAOC,cAAP,EAAuBC,EAAvB,CAA2B;AAC/CX,WAAQO,CAAAA,SAAUK,CAAAA,KAAtB,IACIC,OAAQC,CAAAA,GAAR,CAAY,kDAAZ,EAAgEL,IAAhE,EAAsEC,cAAtE,CADJ;AAGA,UAAMK,kBAAkB,IAAIC,UAAWC,CAAAA,eAAf,EAAxB;AACIP,kBAAJ,GAAqB,CAArB,IACIQ,UAAA,CAAW,EAAA,IAAM;AACbH,qBAAgBI,CAAAA,KAAhB,EAAA;AACInB,aAAQO,CAAAA,SAAUK,CAAAA,KAAtB,IACIC,OAAQC,CAAAA,GAAR,CAAY,sDAAZ,EAAoEL,IAApE,CADJ;AAFa,KAAjB,EAKGC,cALH,CADJ;AAaA,UAAMU,OAAQC,CAAAA,OAAR,EAAN;AACA,OAAI;AACA,aAAO,MAAML,UAAWM,CAAAA,SAAUC,CAAAA,KAAMC,CAAAA,OAA3B,CAAmCf,IAAnC,EAAyCC,cAAA,KAAmB,CAAnB,GAChD,CACEe,KAAM,WADR,EAEEC,YAAa,CAAA,CAFf,CADgD,GAKhD,CACED,KAAM,WADR,EAEEE,OAAQZ,eAAgBY,CAAAA,MAF1B,CALO,EAQN,KAAOC,KAAP,IAAgB;AACnB,YAAIA,IAAJ,CAAU;AACF5B,iBAAQO,CAAAA,SAAUK,CAAAA,KAAtB,IACIC,OAAQC,CAAAA,GAAR,CAAY,8CAAZ,EAA4DL,IAA5D,EAAkEmB,IAAKnB,CAAAA,IAAvE,CADJ;AAGA,aAAI;AACA,mBAAO,MAAME,EAAA,EAAb;AADA,WAAJ,QAGQ;AACAX,mBAAQO,CAAAA,SAAUK,CAAAA,KAAtB,IACIC,OAAQC,CAAAA,GAAR,CAAY,8CAAZ,EAA4DL,IAA5D,EAAkEmB,IAAKnB,CAAAA,IAAvE,CADJ;AADI;AAPF,SAAV,KAaK;AACD,cAAIC,cAAJ,KAAuB,CAAvB;AAII,kBAHIV,OAAQO,CAAAA,SAAUK,CAAAA,KAGhB,IAFFC,OAAQC,CAAAA,GAAR,CAAY,+DAAZ,EAA6EL,IAA7E,CAEE,EAAA,IAAIJ,gCAAJ,CAAsC,sDAAqDI,IAArD,sBAAtC,CAAN;AAJJ;AAOI,cAAIT,OAAQO,CAAAA,SAAUK,CAAAA,KAAtB;AACI,eAAI;AACA,oBAAMiB,SAAS,MAAMb,UAAWM,CAAAA,SAAUC,CAAAA,KAAMO,CAAAA,KAA3B,EAArB;AACAjB,qBAAQC,CAAAA,GAAR,CAAY,kDAAZ,EAAgEiB,IAAKC,CAAAA,SAAL,CAAeH,MAAf,EAAuB,IAAvB,EAA6B,IAA7B,CAAhE,CAAA;AAFA,aAIJ,QAAOI,CAAP,CAAU;AACNpB,qBAAQqB,CAAAA,IAAR,CAAa,sEAAb,EAAqFD,CAArF,CAAA;AADM;AALd;AAaApB,iBAAQqB,CAAAA,IAAR,CAAa,yPAAb,CAAA;AACA,iBAAO,MAAMvB,EAAA,EAAb;AAtBH;AAdc,OARV,CAAb;AADA,KAkDJ,QAAOsB,CAAP,CAAU;AAIN,WAAKA,CAAA,KAAM,IAAN,IAAcA,CAAd,KAAoB,IAAK,EAAzB,GAA6B,IAAK,EAAlC,GAAsCA,CAAExB,CAAAA,IAA7C,MAAuD,YAAvD;AACI,cAAM,IAAIJ,gCAAJ,CAAsC,sDAAqDI,IAArD,uBAAgFC,cAAhF,IAAtC,CAAN;AADJ;AAGA,YAAMuB,CAAN;AAPM;AArEyC,GA/FvD;AACAjC,SAAQmC,CAAAA,WAAR,GAkMAA,cAA0B,CAAC1B,IAAD,EAAOC,cAAP,EAAuBC,EAAvB,CAA2B;AACjD,QAAIyB,EAAJ;AACA,UAAMC,oBAAoB,CAACD,EAAD,GAAME,aAAA,CAAc7B,IAAd,CAAN,MAA+B,IAA/B,IAAuC2B,EAAvC,KAA8C,IAAK,EAAnD,GAAuDA,EAAvD,GAA4DhB,OAAQC,CAAAA,OAAR,EAAtF,EAGMkB,2BAA4B,MAAM,EAAN,IAAY;AAC1C,SAAI;AAEA,eADA,MAAMF,iBACC,EAAA,IAAP;AAFA,OAIJ,QAAOJ,CAAP,CAAU;AAEN,eAAO,IAAP;AAFM;AALgC,KAAZ,CAAD,EAHjC,EAaMO,mBAAoB,MAAM,EAAN,IAAY;AAClC,UAAIC,YAAY,IAAhB;AACA,SAAI;AAEA,cAAMC,iBAAiBhC,cAAA,IAAkB,CAAlB,GACjB,IAAIU,OAAJ,CAAY,CAACuB,CAAD,EAAIC,MAAJ,CAAA,IAAe;AACzBH,mBAAA,GAAYvB,UAAA,CAAW,EAAA,IAAM;AACzBL,mBAAQqB,CAAAA,IAAR,CAAc,8BAA6BzB,IAA7B,iCAAkEC,cAAlE,MAAd,GACI,oIADJ,CAAA;AAGAkC,kBAAA,CAAO,IAAIxC,8BAAJ,CAAoC,qCAAoCK,IAApC,aAApC,CAAP,CAAA;AAJyB,WAAjB,EAKTC,cALS,CAAZ;AADyB,SAA3B,CADiB,GASjB,IATN;AAUA,cAAMU,OAAQyB,CAAAA,IAAR,CAAa,CAACN,wBAAD,EAA2BG,cAA3B,CAA2CI,CAAAA,MAA3C,CAAmDC,CAAD,IAAOA,CAAzD,CAAb,CAAN;AAGIN,iBAAJ,KAAkB,IAAlB,IACIO,YAAA,CAAaP,SAAb,CADJ;AAfA,OAmBJ,QAAOR,CAAP,CAAU;AAMN,YAJIQ,SAIA,KAJc,IAId,IAHAO,YAAA,CAAaP,SAAb,CAGA,EAAAR,CAAA,IAAKA,CAAEgB,CAAAA,gBAAX;AACI,gBAAMhB,CAAN;AADJ;AANM;AAaV,aAAO,MAAMtB,EAAA,EAAb;AAlCkC,KAAZ,CAAD,EAbzB;AAiDA2B,iBAAA,CAAc7B,IAAd,CAAA,GAAuB,MAAM,EAAN,IAAY;AAC/B,SAAI;AACA,eAAO,MAAM+B,gBAAb;AADA,OAGJ,QAAOP,CAAP,CAAU;AACN,YAAIA,CAAJ,IAASA,CAAEgB,CAAAA,gBAAX,CAA6B;AAGzB,aAAI;AACA,kBAAMZ,iBAAN;AADA,WAGJ,QAAOa,SAAP,CAAkB;;AAGlB,iBAAO,IAAP;AATyB;AAW7B,cAAMjB,CAAN;AAZM;AAJqB,KAAZ,CAAD,EAAtB;AAqBA,WAAO,MAAMO,gBAAb;AAxEiD,GAlMrD;AACMW,SAAAA,GAAYrD,OAAA,CAAQ,6DAAR,CAAZqD;AAINnD,SAAQO,CAAAA,SAAR,GAAoB,CAIhBK,MAAO,CAAC,EAAEI,UAAF,IACJ,GAAImC,OAAUC,CAAAA,oBAAd,GADI,IAEJpC,UAAWqC,CAAAA,YAFP,IAGJrC,UAAWqC,CAAAA,YAAaC,CAAAA,OAAxB,CAAgC,gCAAhC,CAHI,KAGkE,MAHlE,CAJQ,CAApB;AAyBA,OAAMhD,wBAAN,QAAsCiD,MAAtC;AACIC,eAAW,CAACC,OAAD,CAAU;AACjB,WAAA,CAAMA,OAAN,CAAA;AACA,UAAKR,CAAAA,gBAAL,GAAwB,CAAA,CAAxB;AAFiB;AADzB;AAMAjD,SAAQM,CAAAA,uBAAR,GAAkCA,uBAAlC;AAWA,OAAMD,iCAAN,QAA+CC,wBAA/C;;AAEAN,SAAQK,CAAAA,gCAAR,GAA2CA,gCAA3C;AAWA,OAAMD,+BAAN,QAA6CE,wBAA7C;;AAEAN,SAAQI,CAAAA,8BAAR,GAAyCA,8BAAzC;AA+GA,QAAMkC,gBAAgB,EAAtB;AAlL+G,CAA/G;;\",\n\"sources\":[\"node_modules/@supabase/auth-js/dist/main/lib/locks.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$supabase$auth_js$dist$main$lib$locks\\\"] = function(require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.ProcessLockAcquireTimeoutError = exports.NavigatorLockAcquireTimeoutError = exports.LockAcquireTimeoutError = exports.internals = void 0;\\nexports.navigatorLock = navigatorLock;\\nexports.processLock = processLock;\\nconst helpers_1 = require(\\\"./helpers\\\");\\n/**\\n * @experimental\\n */\\nexports.internals = {\\n    /**\\n     * @experimental\\n     */\\n    debug: !!(globalThis &&\\n        (0, helpers_1.supportsLocalStorage)() &&\\n        globalThis.localStorage &&\\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\\n};\\n/**\\n * An error thrown when a lock cannot be acquired after some amount of time.\\n *\\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\\n *\\n * @example\\n * ```ts\\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\\n *\\n * class CustomLockError extends LockAcquireTimeoutError {\\n *   constructor() {\\n *     super('Lock timed out')\\n *   }\\n * }\\n * ```\\n */\\nclass LockAcquireTimeoutError extends Error {\\n    constructor(message) {\\n        super(message);\\n        this.isAcquireTimeout = true;\\n    }\\n}\\nexports.LockAcquireTimeoutError = LockAcquireTimeoutError;\\n/**\\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\\n *\\n * @example\\n * ```ts\\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\\n *\\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\\n * ```\\n */\\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\\n}\\nexports.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;\\n/**\\n * Error thrown when the process-level lock helper cannot acquire a lock.\\n *\\n * @example\\n * ```ts\\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\\n *\\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\\n * ```\\n */\\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\\n}\\nexports.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;\\n/**\\n * Implements a global exclusive lock using the Navigator LockManager API. It\\n * is available on all browsers released after 2022-03-15 with Safari being the\\n * last one to release support. If the API is not available, this function will\\n * throw. Make sure you check availablility before configuring {@link\\n * GoTrueClient}.\\n *\\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\\n * local storage item to `true`.\\n *\\n * Internals:\\n *\\n * Since the LockManager API does not preserve stack traces for the async\\n * function passed in the `request` method, a trick is used where acquiring the\\n * lock releases a previously started promise to run the operation in the `fn`\\n * function. The lock waits for that promise to finish (with or without error),\\n * while the function will finally wait for the result anyway.\\n *\\n * @param name Name of the lock to be acquired.\\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\\n *                       will time out after so many milliseconds. An error is\\n *                       a timeout if it has `isAcquireTimeout` set to true.\\n * @param fn The operation to run once the lock is acquired.\\n * @example\\n * ```ts\\n * await navigatorLock('sync-user', 1000, async () => {\\n *   await refreshSession()\\n * })\\n * ```\\n */\\nasync function navigatorLock(name, acquireTimeout, fn) {\\n    if (exports.internals.debug) {\\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\\n    }\\n    const abortController = new globalThis.AbortController();\\n    if (acquireTimeout > 0) {\\n        setTimeout(() => {\\n            abortController.abort();\\n            if (exports.internals.debug) {\\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\\n            }\\n        }, acquireTimeout);\\n    }\\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\\n    // Wrapping with await Promise.resolve() is done as some libraries like zone.js\\n    // patch the Promise object to track execution context. We use await instead of\\n    // .then() to avoid Firefox content script security errors where accessing .then()\\n    // on cross-context promises is forbidden.\\n    await Promise.resolve();\\n    try {\\n        return await globalThis.navigator.locks.request(name, acquireTimeout === 0\\n            ? {\\n                mode: 'exclusive',\\n                ifAvailable: true,\\n            }\\n            : {\\n                mode: 'exclusive',\\n                signal: abortController.signal,\\n            }, async (lock) => {\\n            if (lock) {\\n                if (exports.internals.debug) {\\n                    console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\\n                }\\n                try {\\n                    return await fn();\\n                }\\n                finally {\\n                    if (exports.internals.debug) {\\n                        console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\\n                    }\\n                }\\n            }\\n            else {\\n                if (acquireTimeout === 0) {\\n                    if (exports.internals.debug) {\\n                        console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\\n                    }\\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \\\"${name}\\\" immediately failed`);\\n                }\\n                else {\\n                    if (exports.internals.debug) {\\n                        try {\\n                            const result = await globalThis.navigator.locks.query();\\n                            console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\\n                        }\\n                        catch (e) {\\n                            console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\\n                        }\\n                    }\\n                    // Browser is not following the Navigator LockManager spec, it\\n                    // returned a null lock when we didn't use ifAvailable. So we can\\n                    // pretend the lock is acquired in the name of backward compatibility\\n                    // and user experience and just run the function.\\n                    console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\\n                    return await fn();\\n                }\\n            }\\n        });\\n    }\\n    catch (e) {\\n        // When the AbortController times out, navigator.locks.request rejects with\\n        // a DOMException named 'AbortError'. Convert this to NavigatorLockAcquireTimeoutError\\n        // so callers can check error.isAcquireTimeout as documented.\\n        if ((e === null || e === void 0 ? void 0 : e.name) === 'AbortError') {\\n            throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \\\"${name}\\\" timed out waiting ${acquireTimeout}ms`);\\n        }\\n        throw e;\\n    }\\n}\\nconst PROCESS_LOCKS = {};\\n/**\\n * Implements a global exclusive lock that works only in the current process.\\n * Useful for environments like React Native or other non-browser\\n * single-process (i.e. no concept of \\\"tabs\\\") environments.\\n *\\n * Use {@link #navigatorLock} in browser environments.\\n *\\n * @param name Name of the lock to be acquired.\\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\\n *                       will time out after so many milliseconds. An error is\\n *                       a timeout if it has `isAcquireTimeout` set to true.\\n * @param fn The operation to run once the lock is acquired.\\n * @example\\n * ```ts\\n * await processLock('migrate', 5000, async () => {\\n *   await runMigration()\\n * })\\n * ```\\n */\\nasync function processLock(name, acquireTimeout, fn) {\\n    var _a;\\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\\n    // Wrap previousOperation to handle errors without using .catch()\\n    // This avoids Firefox content script security errors\\n    const previousOperationHandled = (async () => {\\n        try {\\n            await previousOperation;\\n            return null;\\n        }\\n        catch (e) {\\n            // ignore error of previous operation that we're waiting to finish\\n            return null;\\n        }\\n    })();\\n    const currentOperation = (async () => {\\n        let timeoutId = null;\\n        try {\\n            // Wait for either previous operation or timeout\\n            const timeoutPromise = acquireTimeout >= 0\\n                ? new Promise((_, reject) => {\\n                    timeoutId = setTimeout(() => {\\n                        console.warn(`@supabase/gotrue-js: Lock \\\"${name}\\\" acquisition timed out after ${acquireTimeout}ms. ` +\\n                            'This may be caused by another operation holding the lock. ' +\\n                            'Consider increasing lockAcquireTimeout or checking for stuck operations.');\\n                        reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \\\"${name}\\\" timed out`));\\n                    }, acquireTimeout);\\n                })\\n                : null;\\n            await Promise.race([previousOperationHandled, timeoutPromise].filter((x) => x));\\n            // If we reach here, previousOperationHandled won the race\\n            // Clear the timeout to prevent false warnings\\n            if (timeoutId !== null) {\\n                clearTimeout(timeoutId);\\n            }\\n        }\\n        catch (e) {\\n            // Clear the timeout on error path as well\\n            if (timeoutId !== null) {\\n                clearTimeout(timeoutId);\\n            }\\n            // Re-throw timeout errors, ignore others\\n            if (e && e.isAcquireTimeout) {\\n                throw e;\\n            }\\n            // Fall through to run fn() - previous operation finished with error\\n        }\\n        // Previous operations finished and we didn't get a race on the acquire\\n        // timeout, so the current operation can finally start\\n        return await fn();\\n    })();\\n    PROCESS_LOCKS[name] = (async () => {\\n        try {\\n            return await currentOperation;\\n        }\\n        catch (e) {\\n            if (e && e.isAcquireTimeout) {\\n                // if the current operation timed out, it doesn't mean that the previous\\n                // operation finished, so we need continue waiting for it to finish\\n                try {\\n                    await previousOperation;\\n                }\\n                catch (prevError) {\\n                    // Ignore previous operation errors\\n                }\\n                return null;\\n            }\\n            throw e;\\n        }\\n    })();\\n    // finally wait for the current operation to finish successfully, with an\\n    // error or with an acquire timeout error\\n    return await currentOperation;\\n}\\n//# sourceMappingURL=locks.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"ProcessLockAcquireTimeoutError\",\"NavigatorLockAcquireTimeoutError\",\"LockAcquireTimeoutError\",\"internals\",\"navigatorLock\",\"name\",\"acquireTimeout\",\"fn\",\"debug\",\"console\",\"log\",\"abortController\",\"globalThis\",\"AbortController\",\"setTimeout\",\"abort\",\"Promise\",\"resolve\",\"navigator\",\"locks\",\"request\",\"mode\",\"ifAvailable\",\"signal\",\"lock\",\"result\",\"query\",\"JSON\",\"stringify\",\"e\",\"warn\",\"processLock\",\"_a\",\"previousOperation\",\"PROCESS_LOCKS\",\"previousOperationHandled\",\"currentOperation\",\"timeoutId\",\"timeoutPromise\",\"_\",\"reject\",\"race\",\"filter\",\"x\",\"clearTimeout\",\"isAcquireTimeout\",\"prevError\",\"helpers_1\",\"supportsLocalStorage\",\"localStorage\",\"getItem\",\"Error\",\"constructor\",\"message\"]\n}\n"]