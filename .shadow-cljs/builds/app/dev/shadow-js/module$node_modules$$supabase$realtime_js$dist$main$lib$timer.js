["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/realtime-js/dist/main/lib/timer.js"],"~:js","shadow$provide.module$node_modules$$supabase$realtime_js$dist$main$lib$timer = function(require, module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  class Timer {\n    constructor(callback, timerCalc) {\n      this.timerCalc = timerCalc;\n      this.timer = void 0;\n      this.tries = 0;\n      this.callback = callback;\n      this.timerCalc = timerCalc;\n    }\n    reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n      this.timer = void 0;\n    }\n    scheduleTimeout() {\n      clearTimeout(this.timer);\n      this.timer = setTimeout(() => {\n        this.tries += 1;\n        this.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n  }\n  exports.default = Timer;\n};\n","~:source","shadow$provide[\"module$node_modules$$supabase$realtime_js$dist$main$lib$timer\"] = function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nclass Timer {\n    constructor(callback, timerCalc) {\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(() => {\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n}\nexports.default = Timer;\n//# sourceMappingURL=timer.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["callback","__esModule","timerCalc","value","tries","default","timer"]],"~:compiled-at",1771981597301,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$realtime_js$dist$main$lib$timer.js\",\n\"lineCount\":26,\n\"mappings\":\"AAAAA,cAAA,CAAA,6DAAA,GAAkF,QAAQ,CAACC,OAAD,EAASC,MAAT,EAAgBC,OAAhB,CAAyB;AAEnHC,QAAOC,CAAAA,cAAP,CAAsBF,OAAtB,EAA+B,YAA/B,EAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAAA;AAaA,OAAMC,MAAN;AACIC,eAAW,CAACC,QAAD,EAAWC,SAAX,CAAsB;AAE7B,UAAKA,CAAAA,SAAL,GAAiBA,SAAjB;AACA,UAAKC,CAAAA,KAAL,GAAaC,IAAAA,EAAb;AACA,UAAKC,CAAAA,KAAL,GAAa,CAAb;AACA,UAAKJ,CAAAA,QAAL,GAAgBA,QAAhB;AACA,UAAKC,CAAAA,SAAL,GAAiBA,SAAjB;AAN6B;AAQjCI,SAAK,EAAG;AACJ,UAAKD,CAAAA,KAAL,GAAa,CAAb;AACAE,kBAAA,CAAa,IAAKJ,CAAAA,KAAlB,CAAA;AACA,UAAKA,CAAAA,KAAL,GAAaC,IAAAA,EAAb;AAHI;AAMRI,mBAAe,EAAG;AACdD,kBAAA,CAAa,IAAKJ,CAAAA,KAAlB,CAAA;AACA,UAAKA,CAAAA,KAAL,GAAaM,UAAA,CAAW,EAAA,IAAM;AAC1B,YAAKJ,CAAAA,KAAL,IAA0B,CAA1B;AACA,YAAKJ,CAAAA,QAAL,EAAA;AAF0B,OAAjB,EAGV,IAAKC,CAAAA,SAAL,CAAe,IAAKG,CAAAA,KAApB,GAA4B,CAA5B,CAHU,CAAb;AAFc;AAftB;AAuBAV,SAAQe,CAAAA,OAAR,GAAkBX,KAAlB;AAtCmH,CAAnH;;\",\n\"sources\":[\"node_modules/@supabase/realtime-js/dist/main/lib/timer.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$supabase$realtime_js$dist$main$lib$timer\\\"] = function(require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\n/**\\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\\n *\\n * @example\\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\\n *      return [1000, 5000, 10000][tries - 1] || 10000\\n *    })\\n *    reconnectTimer.scheduleTimeout() // fires after 1000\\n *    reconnectTimer.scheduleTimeout() // fires after 5000\\n *    reconnectTimer.reset()\\n *    reconnectTimer.scheduleTimeout() // fires after 1000\\n */\\nclass Timer {\\n    constructor(callback, timerCalc) {\\n        this.callback = callback;\\n        this.timerCalc = timerCalc;\\n        this.timer = undefined;\\n        this.tries = 0;\\n        this.callback = callback;\\n        this.timerCalc = timerCalc;\\n    }\\n    reset() {\\n        this.tries = 0;\\n        clearTimeout(this.timer);\\n        this.timer = undefined;\\n    }\\n    // Cancels any previous scheduleTimeout and schedules callback\\n    scheduleTimeout() {\\n        clearTimeout(this.timer);\\n        this.timer = setTimeout(() => {\\n            this.tries = this.tries + 1;\\n            this.callback();\\n        }, this.timerCalc(this.tries + 1));\\n    }\\n}\\nexports.default = Timer;\\n//# sourceMappingURL=timer.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"Timer\",\"constructor\",\"callback\",\"timerCalc\",\"timer\",\"undefined\",\"tries\",\"reset\",\"clearTimeout\",\"scheduleTimeout\",\"setTimeout\",\"default\"]\n}\n"]