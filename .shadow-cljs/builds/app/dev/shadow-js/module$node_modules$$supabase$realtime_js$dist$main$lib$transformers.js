["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/realtime-js/dist/main/lib/transformers.js"],"~:js","shadow$provide.module$node_modules$$supabase$realtime_js$dist$main$lib$transformers = function(require, module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.httpEndpointURL = exports.toTimestampString = exports.toArray = exports.toJson = exports.toNumber = exports.toBoolean = exports.convertCell = exports.convertColumn = exports.convertChangeData = exports.PostgresTypes = void 0;\n  var PostgresTypes;\n  (function(PostgresTypes) {\n    PostgresTypes.abstime = \"abstime\";\n    PostgresTypes.bool = \"bool\";\n    PostgresTypes.date = \"date\";\n    PostgresTypes.daterange = \"daterange\";\n    PostgresTypes.float4 = \"float4\";\n    PostgresTypes.float8 = \"float8\";\n    PostgresTypes.int2 = \"int2\";\n    PostgresTypes.int4 = \"int4\";\n    PostgresTypes.int4range = \"int4range\";\n    PostgresTypes.int8 = \"int8\";\n    PostgresTypes.int8range = \"int8range\";\n    PostgresTypes.json = \"json\";\n    PostgresTypes.jsonb = \"jsonb\";\n    PostgresTypes.money = \"money\";\n    PostgresTypes.numeric = \"numeric\";\n    PostgresTypes.oid = \"oid\";\n    PostgresTypes.reltime = \"reltime\";\n    PostgresTypes.text = \"text\";\n    PostgresTypes.time = \"time\";\n    PostgresTypes.timestamp = \"timestamp\";\n    PostgresTypes.timestamptz = \"timestamptz\";\n    PostgresTypes.timetz = \"timetz\";\n    PostgresTypes.tsrange = \"tsrange\";\n    PostgresTypes.tstzrange = \"tstzrange\";\n  })(PostgresTypes || (exports.PostgresTypes = PostgresTypes = {}));\n  exports.convertChangeData = (columns, record, options = {}) => {\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    return record ? Object.keys(record).reduce((acc, rec_key) => {\n      acc[rec_key] = (0,exports.convertColumn)(rec_key, columns, record, skipTypes);\n      return acc;\n    }, {}) : {};\n  };\n  exports.convertColumn = (columnName, columns, record, skipTypes) => {\n    columns = columns.find(x => x.name === columnName);\n    columns = columns === null || columns === void 0 ? void 0 : columns.type;\n    record = record[columnName];\n    return columns && !skipTypes.includes(columns) ? (0,exports.convertCell)(columns, record) : record;\n  };\n  exports.convertCell = (type, value) => {\n    if (type.charAt(0) === \"_\") {\n      return type = type.slice(1, type.length), (0,exports.toArray)(value, type);\n    }\n    switch(type) {\n      case PostgresTypes.bool:\n        return (0,exports.toBoolean)(value);\n      case PostgresTypes.float4:\n      case PostgresTypes.float8:\n      case PostgresTypes.int2:\n      case PostgresTypes.int4:\n      case PostgresTypes.int8:\n      case PostgresTypes.numeric:\n      case PostgresTypes.oid:\n        return (0,exports.toNumber)(value);\n      case PostgresTypes.json:\n      case PostgresTypes.jsonb:\n        return (0,exports.toJson)(value);\n      case PostgresTypes.timestamp:\n        return (0,exports.toTimestampString)(value);\n      case PostgresTypes.abstime:\n      case PostgresTypes.date:\n      case PostgresTypes.daterange:\n      case PostgresTypes.int4range:\n      case PostgresTypes.int8range:\n      case PostgresTypes.money:\n      case PostgresTypes.reltime:\n      case PostgresTypes.text:\n      case PostgresTypes.time:\n      case PostgresTypes.timestamptz:\n      case PostgresTypes.timetz:\n      case PostgresTypes.tsrange:\n      case PostgresTypes.tstzrange:\n        return value;\n      default:\n        return value;\n    }\n  };\n  exports.toBoolean = value => {\n    switch(value) {\n      case \"t\":\n        return !0;\n      case \"f\":\n        return !1;\n      default:\n        return value;\n    }\n  };\n  exports.toNumber = value => {\n    if (typeof value === \"string\") {\n      const parsedValue = parseFloat(value);\n      if (!Number.isNaN(parsedValue)) {\n        return parsedValue;\n      }\n    }\n    return value;\n  };\n  exports.toJson = value => {\n    if (typeof value === \"string\") {\n      try {\n        return JSON.parse(value);\n      } catch (_a) {\n      }\n    }\n    return value;\n  };\n  exports.toArray = (value, type) => {\n    if (typeof value !== \"string\") {\n      return value;\n    }\n    const lastIdx = value.length - 1, closeBrace = value[lastIdx];\n    if (value[0] === \"{\" && closeBrace === \"}\") {\n      let arr;\n      value = value.slice(1, lastIdx);\n      try {\n        arr = JSON.parse(\"[\" + value + \"]\");\n      } catch (_) {\n        arr = value ? value.split(\",\") : [];\n      }\n      return arr.map(val => (0,exports.convertCell)(type, val));\n    }\n    return value;\n  };\n  exports.toTimestampString = value => typeof value === \"string\" ? value.replace(\" \", \"T\") : value;\n  exports.httpEndpointURL = socketUrl => {\n    socketUrl = new URL(socketUrl);\n    socketUrl.protocol = socketUrl.protocol.replace(/^ws/i, \"http\");\n    socketUrl.pathname = socketUrl.pathname.replace(/\\/+$/, \"\").replace(/\\/socket\\/websocket$/i, \"\").replace(/\\/socket$/i, \"\").replace(/\\/websocket$/i, \"\");\n    socketUrl.pathname = socketUrl.pathname === \"\" || socketUrl.pathname === \"/\" ? \"/api/broadcast\" : socketUrl.pathname + \"/api/broadcast\";\n    return socketUrl.href;\n  };\n};\n","~:source","shadow$provide[\"module$node_modules$$supabase$realtime_js$dist$main$lib$transformers\"] = function(require,module,exports) {\n\"use strict\";\n/**\n * Helpers to convert the change Payload into native JS types.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.httpEndpointURL = exports.toTimestampString = exports.toArray = exports.toJson = exports.toNumber = exports.toBoolean = exports.convertCell = exports.convertColumn = exports.convertChangeData = exports.PostgresTypes = void 0;\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nvar PostgresTypes;\n(function (PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (exports.PostgresTypes = PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nconst convertChangeData = (columns, record, options = {}) => {\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    if (!record) {\n        return {};\n    }\n    return Object.keys(record).reduce((acc, rec_key) => {\n        acc[rec_key] = (0, exports.convertColumn)(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\nexports.convertChangeData = convertChangeData;\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nconst convertColumn = (columnName, columns, record, skipTypes) => {\n    const column = columns.find((x) => x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return (0, exports.convertCell)(colType, value);\n    }\n    return noop(value);\n};\nexports.convertColumn = convertColumn;\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nconst convertCell = (type, value) => {\n    // if data type is an array\n    if (type.charAt(0) === '_') {\n        const dataType = type.slice(1, type.length);\n        return (0, exports.toArray)(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch (type) {\n        case PostgresTypes.bool:\n            return (0, exports.toBoolean)(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return (0, exports.toNumber)(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return (0, exports.toJson)(value);\n        case PostgresTypes.timestamp:\n            return (0, exports.toTimestampString)(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n        case PostgresTypes.date: // To allow users to cast it based on Timezone\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n        case PostgresTypes.text:\n        case PostgresTypes.time: // To allow users to cast it based on Timezone\n        case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n        case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nexports.convertCell = convertCell;\nconst noop = (value) => {\n    return value;\n};\nconst toBoolean = (value) => {\n    switch (value) {\n        case 't':\n            return true;\n        case 'f':\n            return false;\n        default:\n            return value;\n    }\n};\nexports.toBoolean = toBoolean;\nconst toNumber = (value) => {\n    if (typeof value === 'string') {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nexports.toNumber = toNumber;\nconst toJson = (value) => {\n    if (typeof value === 'string') {\n        try {\n            return JSON.parse(value);\n        }\n        catch (_a) {\n            return value;\n        }\n    }\n    return value;\n};\nexports.toJson = toJson;\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nconst toArray = (value, type) => {\n    if (typeof value !== 'string') {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === '{' && closeBrace === '}') {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse('[' + valTrim + ']');\n        }\n        catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(',') : [];\n        }\n        return arr.map((val) => (0, exports.convertCell)(type, val));\n    }\n    return value;\n};\nexports.toArray = toArray;\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nconst toTimestampString = (value) => {\n    if (typeof value === 'string') {\n        return value.replace(' ', 'T');\n    }\n    return value;\n};\nexports.toTimestampString = toTimestampString;\nconst httpEndpointURL = (socketUrl) => {\n    const wsUrl = new URL(socketUrl);\n    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, 'http');\n    wsUrl.pathname = wsUrl.pathname\n        .replace(/\\/+$/, '') // remove all trailing slashes\n        .replace(/\\/socket\\/websocket$/i, '') // remove the socket/websocket path\n        .replace(/\\/socket$/i, '') // remove the socket path\n        .replace(/\\/websocket$/i, ''); // remove the websocket path\n    if (wsUrl.pathname === '' || wsUrl.pathname === '/') {\n        wsUrl.pathname = '/api/broadcast';\n    }\n    else {\n        wsUrl.pathname = wsUrl.pathname + '/api/broadcast';\n    }\n    return wsUrl.href;\n};\nexports.httpEndpointURL = httpEndpointURL;\n//# sourceMappingURL=transformers.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["toTimestampString","protocol","httpEndpointURL","pathname","__esModule","convertColumn","convertChangeData","PostgresTypes","value","convertCell","toBoolean","toJson","toNumber","toArray"]],"~:compiled-at",1771981597302,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$realtime_js$dist$main$lib$transformers.js\",\n\"lineCount\":137,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/realtime-js/dist/main/lib/transformers.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$supabase$realtime_js$dist$main$lib$transformers\\\"] = function(require,module,exports) {\\n\\\"use strict\\\";\\n/**\\n * Helpers to convert the change Payload into native JS types.\\n */\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.httpEndpointURL = exports.toTimestampString = exports.toArray = exports.toJson = exports.toNumber = exports.toBoolean = exports.convertCell = exports.convertColumn = exports.convertChangeData = exports.PostgresTypes = void 0;\\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\\nvar PostgresTypes;\\n(function (PostgresTypes) {\\n    PostgresTypes[\\\"abstime\\\"] = \\\"abstime\\\";\\n    PostgresTypes[\\\"bool\\\"] = \\\"bool\\\";\\n    PostgresTypes[\\\"date\\\"] = \\\"date\\\";\\n    PostgresTypes[\\\"daterange\\\"] = \\\"daterange\\\";\\n    PostgresTypes[\\\"float4\\\"] = \\\"float4\\\";\\n    PostgresTypes[\\\"float8\\\"] = \\\"float8\\\";\\n    PostgresTypes[\\\"int2\\\"] = \\\"int2\\\";\\n    PostgresTypes[\\\"int4\\\"] = \\\"int4\\\";\\n    PostgresTypes[\\\"int4range\\\"] = \\\"int4range\\\";\\n    PostgresTypes[\\\"int8\\\"] = \\\"int8\\\";\\n    PostgresTypes[\\\"int8range\\\"] = \\\"int8range\\\";\\n    PostgresTypes[\\\"json\\\"] = \\\"json\\\";\\n    PostgresTypes[\\\"jsonb\\\"] = \\\"jsonb\\\";\\n    PostgresTypes[\\\"money\\\"] = \\\"money\\\";\\n    PostgresTypes[\\\"numeric\\\"] = \\\"numeric\\\";\\n    PostgresTypes[\\\"oid\\\"] = \\\"oid\\\";\\n    PostgresTypes[\\\"reltime\\\"] = \\\"reltime\\\";\\n    PostgresTypes[\\\"text\\\"] = \\\"text\\\";\\n    PostgresTypes[\\\"time\\\"] = \\\"time\\\";\\n    PostgresTypes[\\\"timestamp\\\"] = \\\"timestamp\\\";\\n    PostgresTypes[\\\"timestamptz\\\"] = \\\"timestamptz\\\";\\n    PostgresTypes[\\\"timetz\\\"] = \\\"timetz\\\";\\n    PostgresTypes[\\\"tsrange\\\"] = \\\"tsrange\\\";\\n    PostgresTypes[\\\"tstzrange\\\"] = \\\"tstzrange\\\";\\n})(PostgresTypes || (exports.PostgresTypes = PostgresTypes = {}));\\n/**\\n * Takes an array of columns and an object of string values then converts each string value\\n * to its mapped type.\\n *\\n * @param {{name: String, type: String}[]} columns\\n * @param {Object} record\\n * @param {Object} options The map of various options that can be applied to the mapper\\n * @param {Array} options.skipTypes The array of types that should not be converted\\n *\\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\\n * //=>{ first_name: 'Paul', age: 33 }\\n */\\nconst convertChangeData = (columns, record, options = {}) => {\\n    var _a;\\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\\n    if (!record) {\\n        return {};\\n    }\\n    return Object.keys(record).reduce((acc, rec_key) => {\\n        acc[rec_key] = (0, exports.convertColumn)(rec_key, columns, record, skipTypes);\\n        return acc;\\n    }, {});\\n};\\nexports.convertChangeData = convertChangeData;\\n/**\\n * Converts the value of an individual column.\\n *\\n * @param {String} columnName The column that you want to convert\\n * @param {{name: String, type: String}[]} columns All of the columns\\n * @param {Object} record The map of string values\\n * @param {Array} skipTypes An array of types that should not be converted\\n * @return {object} Useless information\\n *\\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\\n * //=> 33\\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\\n * //=> \\\"33\\\"\\n */\\nconst convertColumn = (columnName, columns, record, skipTypes) => {\\n    const column = columns.find((x) => x.name === columnName);\\n    const colType = column === null || column === void 0 ? void 0 : column.type;\\n    const value = record[columnName];\\n    if (colType && !skipTypes.includes(colType)) {\\n        return (0, exports.convertCell)(colType, value);\\n    }\\n    return noop(value);\\n};\\nexports.convertColumn = convertColumn;\\n/**\\n * If the value of the cell is `null`, returns null.\\n * Otherwise converts the string value to the correct type.\\n * @param {String} type A postgres column type\\n * @param {String} value The cell value\\n *\\n * @example convertCell('bool', 't')\\n * //=> true\\n * @example convertCell('int8', '10')\\n * //=> 10\\n * @example convertCell('_int4', '{1,2,3,4}')\\n * //=> [1,2,3,4]\\n */\\nconst convertCell = (type, value) => {\\n    // if data type is an array\\n    if (type.charAt(0) === '_') {\\n        const dataType = type.slice(1, type.length);\\n        return (0, exports.toArray)(value, dataType);\\n    }\\n    // If not null, convert to correct type.\\n    switch (type) {\\n        case PostgresTypes.bool:\\n            return (0, exports.toBoolean)(value);\\n        case PostgresTypes.float4:\\n        case PostgresTypes.float8:\\n        case PostgresTypes.int2:\\n        case PostgresTypes.int4:\\n        case PostgresTypes.int8:\\n        case PostgresTypes.numeric:\\n        case PostgresTypes.oid:\\n            return (0, exports.toNumber)(value);\\n        case PostgresTypes.json:\\n        case PostgresTypes.jsonb:\\n            return (0, exports.toJson)(value);\\n        case PostgresTypes.timestamp:\\n            return (0, exports.toTimestampString)(value); // Format to be consistent with PostgREST\\n        case PostgresTypes.abstime: // To allow users to cast it based on Timezone\\n        case PostgresTypes.date: // To allow users to cast it based on Timezone\\n        case PostgresTypes.daterange:\\n        case PostgresTypes.int4range:\\n        case PostgresTypes.int8range:\\n        case PostgresTypes.money:\\n        case PostgresTypes.reltime: // To allow users to cast it based on Timezone\\n        case PostgresTypes.text:\\n        case PostgresTypes.time: // To allow users to cast it based on Timezone\\n        case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\\n        case PostgresTypes.timetz: // To allow users to cast it based on Timezone\\n        case PostgresTypes.tsrange:\\n        case PostgresTypes.tstzrange:\\n            return noop(value);\\n        default:\\n            // Return the value for remaining types\\n            return noop(value);\\n    }\\n};\\nexports.convertCell = convertCell;\\nconst noop = (value) => {\\n    return value;\\n};\\nconst toBoolean = (value) => {\\n    switch (value) {\\n        case 't':\\n            return true;\\n        case 'f':\\n            return false;\\n        default:\\n            return value;\\n    }\\n};\\nexports.toBoolean = toBoolean;\\nconst toNumber = (value) => {\\n    if (typeof value === 'string') {\\n        const parsedValue = parseFloat(value);\\n        if (!Number.isNaN(parsedValue)) {\\n            return parsedValue;\\n        }\\n    }\\n    return value;\\n};\\nexports.toNumber = toNumber;\\nconst toJson = (value) => {\\n    if (typeof value === 'string') {\\n        try {\\n            return JSON.parse(value);\\n        }\\n        catch (_a) {\\n            return value;\\n        }\\n    }\\n    return value;\\n};\\nexports.toJson = toJson;\\n/**\\n * Converts a Postgres Array into a native JS array\\n *\\n * @example toArray('{}', 'int4')\\n * //=> []\\n * @example toArray('{\\\"[2021-01-01,2021-12-31)\\\",\\\"(2021-01-01,2021-12-32]\\\"}', 'daterange')\\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\\n * @example toArray([1,2,3,4], 'int4')\\n * //=> [1,2,3,4]\\n */\\nconst toArray = (value, type) => {\\n    if (typeof value !== 'string') {\\n        return value;\\n    }\\n    const lastIdx = value.length - 1;\\n    const closeBrace = value[lastIdx];\\n    const openBrace = value[0];\\n    // Confirm value is a Postgres array by checking curly brackets\\n    if (openBrace === '{' && closeBrace === '}') {\\n        let arr;\\n        const valTrim = value.slice(1, lastIdx);\\n        // TODO: find a better solution to separate Postgres array data\\n        try {\\n            arr = JSON.parse('[' + valTrim + ']');\\n        }\\n        catch (_) {\\n            // WARNING: splitting on comma does not cover all edge cases\\n            arr = valTrim ? valTrim.split(',') : [];\\n        }\\n        return arr.map((val) => (0, exports.convertCell)(type, val));\\n    }\\n    return value;\\n};\\nexports.toArray = toArray;\\n/**\\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\\n * See https://github.com/supabase/supabase/issues/18\\n *\\n * @example toTimestampString('2019-09-10 00:00:00')\\n * //=> '2019-09-10T00:00:00'\\n */\\nconst toTimestampString = (value) => {\\n    if (typeof value === 'string') {\\n        return value.replace(' ', 'T');\\n    }\\n    return value;\\n};\\nexports.toTimestampString = toTimestampString;\\nconst httpEndpointURL = (socketUrl) => {\\n    const wsUrl = new URL(socketUrl);\\n    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, 'http');\\n    wsUrl.pathname = wsUrl.pathname\\n        .replace(/\\\\/+$/, '') // remove all trailing slashes\\n        .replace(/\\\\/socket\\\\/websocket$/i, '') // remove the socket/websocket path\\n        .replace(/\\\\/socket$/i, '') // remove the socket path\\n        .replace(/\\\\/websocket$/i, ''); // remove the websocket path\\n    if (wsUrl.pathname === '' || wsUrl.pathname === '/') {\\n        wsUrl.pathname = '/api/broadcast';\\n    }\\n    else {\\n        wsUrl.pathname = wsUrl.pathname + '/api/broadcast';\\n    }\\n    return wsUrl.href;\\n};\\nexports.httpEndpointURL = httpEndpointURL;\\n//# sourceMappingURL=transformers.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"httpEndpointURL\",\"toTimestampString\",\"toArray\",\"toJson\",\"toNumber\",\"toBoolean\",\"convertCell\",\"convertColumn\",\"convertChangeData\",\"PostgresTypes\",\"columns\",\"record\",\"options\",\"_a\",\"skipTypes\",\"keys\",\"reduce\",\"acc\",\"rec_key\",\"columnName\",\"column\",\"find\",\"x\",\"name\",\"colType\",\"type\",\"includes\",\"charAt\",\"dataType\",\"slice\",\"length\",\"bool\",\"float4\",\"float8\",\"int2\",\"int4\",\"int8\",\"numeric\",\"oid\",\"json\",\"jsonb\",\"timestamp\",\"abstime\",\"date\",\"daterange\",\"int4range\",\"int8range\",\"money\",\"reltime\",\"text\",\"time\",\"timestamptz\",\"timetz\",\"tsrange\",\"tstzrange\",\"parsedValue\",\"parseFloat\",\"Number\",\"isNaN\",\"JSON\",\"parse\",\"lastIdx\",\"closeBrace\",\"openBrace\",\"arr\",\"valTrim\",\"_\",\"split\",\"map\",\"val\",\"replace\",\"socketUrl\",\"wsUrl\",\"URL\",\"protocol\",\"pathname\",\"href\"]\n}\n"]