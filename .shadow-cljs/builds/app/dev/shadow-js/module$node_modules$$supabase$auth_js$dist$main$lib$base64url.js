["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@supabase/auth-js/dist/main/lib/base64url.js"],"~:js","shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$base64url = function(require, module, exports) {\n  function byteToBase64URL(byte, state, emit) {\n    if (byte !== null) {\n      for (state.queue = state.queue << 8 | byte, state.queuedBits += 8; state.queuedBits >= 6;) {\n        emit(TO_BASE64URL[state.queue >> state.queuedBits - 6 & 63]), state.queuedBits -= 6;\n      }\n    } else if (state.queuedBits > 0) {\n      for (state.queue <<= 6 - state.queuedBits, state.queuedBits = 6; state.queuedBits >= 6;) {\n        emit(TO_BASE64URL[state.queue >> state.queuedBits - 6 & 63]), state.queuedBits -= 6;\n      }\n    }\n  }\n  function byteFromBase64URL(charCode, state, emit) {\n    const bits = FROM_BASE64URL[charCode];\n    if (bits > -1) {\n      for (state.queue = state.queue << 6 | bits, state.queuedBits += 6; state.queuedBits >= 8;) {\n        emit(state.queue >> state.queuedBits - 8 & 255), state.queuedBits -= 8;\n      }\n    } else if (bits !== -2) {\n      throw Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n    }\n  }\n  function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 127) {\n      emit(codepoint);\n    } else if (codepoint <= 2047) {\n      emit(192 | codepoint >> 6), emit(128 | codepoint & 63);\n    } else {\n      if (codepoint <= 65535) {\n        emit(224 | codepoint >> 12), emit(128 | codepoint >> 6 & 63), emit(128 | codepoint & 63);\n      } else {\n        if (codepoint <= 1114111) {\n          emit(240 | codepoint >> 18), emit(128 | codepoint >> 12 & 63), emit(128 | codepoint >> 6 & 63), emit(128 | codepoint & 63);\n        } else {\n          throw Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n        }\n      }\n    }\n  }\n  function stringToUTF8(str, emit) {\n    for (let i = 0; i < str.length; i += 1) {\n      var codepoint = str.charCodeAt(i);\n      codepoint > 55295 && codepoint <= 56319 && (codepoint = (codepoint - 55296) * 1024 & 65535, codepoint = (str.charCodeAt(i + 1) - 56320 & 65535 | codepoint) + 65536, i += 1);\n      codepointToUTF8(codepoint, emit);\n    }\n  }\n  function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n      if (byte <= 127) {\n        emit(byte);\n      } else {\n        for (emit = 1; emit < 6; emit += 1) {\n          if ((byte >> 7 - emit & 1) === 0) {\n            state.utf8seq = emit;\n            break;\n          }\n        }\n        if (state.utf8seq === 2) {\n          state.codepoint = byte & 31;\n        } else if (state.utf8seq === 3) {\n          state.codepoint = byte & 15;\n        } else if (state.utf8seq === 4) {\n          state.codepoint = byte & 7;\n        } else {\n          throw Error(\"Invalid UTF-8 sequence\");\n        }\n        --state.utf8seq;\n      }\n    } else if (state.utf8seq > 0) {\n      if (byte <= 127) {\n        throw Error(\"Invalid UTF-8 sequence\");\n      }\n      state.codepoint = state.codepoint << 6 | byte & 63;\n      --state.utf8seq;\n      state.utf8seq === 0 && emit(state.codepoint);\n    }\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  exports.byteToBase64URL = byteToBase64URL;\n  exports.byteFromBase64URL = byteFromBase64URL;\n  exports.stringToBase64URL = function(str) {\n    const base64 = [], emitter = char => {\n      base64.push(char);\n    }, state = {queue:0, queuedBits:0};\n    stringToUTF8(str, byte => {\n      byteToBase64URL(byte, state, emitter);\n    });\n    byteToBase64URL(null, state, emitter);\n    return base64.join(\"\");\n  };\n  exports.stringFromBase64URL = function(str) {\n    const conv = [], utf8Emit = codepoint => {\n      conv.push(String.fromCodePoint(codepoint));\n    }, utf8State = {utf8seq:0, codepoint:0}, b64State = {queue:0, queuedBits:0}, byteEmit = byte => {\n      stringFromUTF8(byte, utf8State, utf8Emit);\n    };\n    for (let i = 0; i < str.length; i += 1) {\n      byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n    }\n    return conv.join(\"\");\n  };\n  exports.codepointToUTF8 = codepointToUTF8;\n  exports.stringToUTF8 = stringToUTF8;\n  exports.stringFromUTF8 = stringFromUTF8;\n  exports.base64UrlToUint8Array = function(str) {\n    const result = [], state = {queue:0, queuedBits:0}, onByte = byte => {\n      result.push(byte);\n    };\n    for (let i = 0; i < str.length; i += 1) {\n      byteFromBase64URL(str.charCodeAt(i), state, onByte);\n    }\n    return new Uint8Array(result);\n  };\n  exports.stringToUint8Array = function(str) {\n    const result = [];\n    stringToUTF8(str, byte => result.push(byte));\n    return new Uint8Array(result);\n  };\n  exports.bytesToBase64URL = function(bytes) {\n    const result = [], state = {queue:0, queuedBits:0}, onChar = char => {\n      result.push(char);\n    };\n    bytes.forEach(byte => byteToBase64URL(byte, state, onChar));\n    byteToBase64URL(null, state, onChar);\n    return result.join(\"\");\n  };\n  const TO_BASE64URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\"), IGNORE_BASE64URL = [\" \", \"\\t\", \"\\n\", \"\\r\", \"\\x3d\"], FROM_BASE64URL = (() => {\n    const charMap = Array(128);\n    for (var i = 0; i < charMap.length; i += 1) {\n      charMap[i] = -1;\n    }\n    for (i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n      charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for (i = 0; i < TO_BASE64URL.length; i += 1) {\n      charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n  })();\n};\n","~:source","shadow$provide[\"module$node_modules$$supabase$auth_js$dist$main$lib$base64url\"] = function(require,module,exports) {\n\"use strict\";\r\n/**\r\n * Avoid modifying this file. It's part of\r\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\r\n * that repo!\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.byteToBase64URL = byteToBase64URL;\r\nexports.byteFromBase64URL = byteFromBase64URL;\r\nexports.stringToBase64URL = stringToBase64URL;\r\nexports.stringFromBase64URL = stringFromBase64URL;\r\nexports.codepointToUTF8 = codepointToUTF8;\r\nexports.stringToUTF8 = stringToUTF8;\r\nexports.stringFromUTF8 = stringFromUTF8;\r\nexports.base64UrlToUint8Array = base64UrlToUint8Array;\r\nexports.stringToUint8Array = stringToUint8Array;\r\nexports.bytesToBase64URL = bytesToBase64URL;\r\n/**\r\n * An array of characters that encode 6 bits into a Base64-URL alphabet\r\n * character.\r\n */\r\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\r\n/**\r\n * An array of characters that can appear in a Base64-URL encoded string but\r\n * should be ignored.\r\n */\r\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('');\r\n/**\r\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\r\n * used to skip the character, or if -1 used to error out.\r\n */\r\nconst FROM_BASE64URL = (() => {\r\n    const charMap = new Array(128);\r\n    for (let i = 0; i < charMap.length; i += 1) {\r\n        charMap[i] = -1;\r\n    }\r\n    for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\r\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\r\n    }\r\n    for (let i = 0; i < TO_BASE64URL.length; i += 1) {\r\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\r\n    }\r\n    return charMap;\r\n})();\r\n/**\r\n * Converts a byte to a Base64-URL string.\r\n *\r\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\r\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\r\n * @param emit A function called with the next Base64 character when ready.\r\n */\r\nfunction byteToBase64URL(byte, state, emit) {\r\n    if (byte !== null) {\r\n        state.queue = (state.queue << 8) | byte;\r\n        state.queuedBits += 8;\r\n        while (state.queuedBits >= 6) {\r\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\r\n            emit(TO_BASE64URL[pos]);\r\n            state.queuedBits -= 6;\r\n        }\r\n    }\r\n    else if (state.queuedBits > 0) {\r\n        state.queue = state.queue << (6 - state.queuedBits);\r\n        state.queuedBits = 6;\r\n        while (state.queuedBits >= 6) {\r\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\r\n            emit(TO_BASE64URL[pos]);\r\n            state.queuedBits -= 6;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\r\n *\r\n * @param charCode The char code of the JavaScript string.\r\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\r\n * @param emit A function called with the next byte.\r\n */\r\nfunction byteFromBase64URL(charCode, state, emit) {\r\n    const bits = FROM_BASE64URL[charCode];\r\n    if (bits > -1) {\r\n        // valid Base64-URL character\r\n        state.queue = (state.queue << 6) | bits;\r\n        state.queuedBits += 6;\r\n        while (state.queuedBits >= 8) {\r\n            emit((state.queue >> (state.queuedBits - 8)) & 0xff);\r\n            state.queuedBits -= 8;\r\n        }\r\n    }\r\n    else if (bits === -2) {\r\n        // ignore spaces, tabs, newlines, =\r\n        return;\r\n    }\r\n    else {\r\n        throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\r\n    }\r\n}\r\n/**\r\n * Converts a JavaScript string (which may include any valid character) into a\r\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\r\n * then encoded as Base64-URL.\r\n *\r\n * @param str The string to convert.\r\n */\r\nfunction stringToBase64URL(str) {\r\n    const base64 = [];\r\n    const emitter = (char) => {\r\n        base64.push(char);\r\n    };\r\n    const state = { queue: 0, queuedBits: 0 };\r\n    stringToUTF8(str, (byte) => {\r\n        byteToBase64URL(byte, state, emitter);\r\n    });\r\n    byteToBase64URL(null, state, emitter);\r\n    return base64.join('');\r\n}\r\n/**\r\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\r\n * that the underlying string has been encoded as UTF-8.\r\n *\r\n * @param str The Base64-URL encoded string.\r\n */\r\nfunction stringFromBase64URL(str) {\r\n    const conv = [];\r\n    const utf8Emit = (codepoint) => {\r\n        conv.push(String.fromCodePoint(codepoint));\r\n    };\r\n    const utf8State = {\r\n        utf8seq: 0,\r\n        codepoint: 0,\r\n    };\r\n    const b64State = { queue: 0, queuedBits: 0 };\r\n    const byteEmit = (byte) => {\r\n        stringFromUTF8(byte, utf8State, utf8Emit);\r\n    };\r\n    for (let i = 0; i < str.length; i += 1) {\r\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\r\n    }\r\n    return conv.join('');\r\n}\r\n/**\r\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\r\n *\r\n * @param codepoint The Unicode codepoint.\r\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\r\n */\r\nfunction codepointToUTF8(codepoint, emit) {\r\n    if (codepoint <= 0x7f) {\r\n        emit(codepoint);\r\n        return;\r\n    }\r\n    else if (codepoint <= 0x7ff) {\r\n        emit(0xc0 | (codepoint >> 6));\r\n        emit(0x80 | (codepoint & 0x3f));\r\n        return;\r\n    }\r\n    else if (codepoint <= 0xffff) {\r\n        emit(0xe0 | (codepoint >> 12));\r\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\r\n        emit(0x80 | (codepoint & 0x3f));\r\n        return;\r\n    }\r\n    else if (codepoint <= 0x10ffff) {\r\n        emit(0xf0 | (codepoint >> 18));\r\n        emit(0x80 | ((codepoint >> 12) & 0x3f));\r\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\r\n        emit(0x80 | (codepoint & 0x3f));\r\n        return;\r\n    }\r\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\r\n}\r\n/**\r\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\r\n *\r\n * @param str  The string to convert to UTF-8.\r\n * @param emit Function which will be called for each UTF-8 byte of the string.\r\n */\r\nfunction stringToUTF8(str, emit) {\r\n    for (let i = 0; i < str.length; i += 1) {\r\n        let codepoint = str.charCodeAt(i);\r\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\r\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\r\n            // range where the next UTF-16 codepoint needs to be combined with the\r\n            // current one to get the Unicode codepoint\r\n            const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff;\r\n            const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff;\r\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\r\n            i += 1;\r\n        }\r\n        codepointToUTF8(codepoint, emit);\r\n    }\r\n}\r\n/**\r\n * Converts a UTF-8 byte to a Unicode codepoint.\r\n *\r\n * @param byte  The UTF-8 byte next in the sequence.\r\n * @param state The shared state between consecutive UTF-8 bytes in the\r\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\r\n * @param emit  Function which will be called for each codepoint.\r\n */\r\nfunction stringFromUTF8(byte, state, emit) {\r\n    if (state.utf8seq === 0) {\r\n        if (byte <= 0x7f) {\r\n            emit(byte);\r\n            return;\r\n        }\r\n        // count the number of 1 leading bits until you reach 0\r\n        for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\r\n            if (((byte >> (7 - leadingBit)) & 1) === 0) {\r\n                state.utf8seq = leadingBit;\r\n                break;\r\n            }\r\n        }\r\n        if (state.utf8seq === 2) {\r\n            state.codepoint = byte & 31;\r\n        }\r\n        else if (state.utf8seq === 3) {\r\n            state.codepoint = byte & 15;\r\n        }\r\n        else if (state.utf8seq === 4) {\r\n            state.codepoint = byte & 7;\r\n        }\r\n        else {\r\n            throw new Error('Invalid UTF-8 sequence');\r\n        }\r\n        state.utf8seq -= 1;\r\n    }\r\n    else if (state.utf8seq > 0) {\r\n        if (byte <= 0x7f) {\r\n            throw new Error('Invalid UTF-8 sequence');\r\n        }\r\n        state.codepoint = (state.codepoint << 6) | (byte & 63);\r\n        state.utf8seq -= 1;\r\n        if (state.utf8seq === 0) {\r\n            emit(state.codepoint);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Helper functions to convert different types of strings to Uint8Array\r\n */\r\nfunction base64UrlToUint8Array(str) {\r\n    const result = [];\r\n    const state = { queue: 0, queuedBits: 0 };\r\n    const onByte = (byte) => {\r\n        result.push(byte);\r\n    };\r\n    for (let i = 0; i < str.length; i += 1) {\r\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\r\n    }\r\n    return new Uint8Array(result);\r\n}\r\nfunction stringToUint8Array(str) {\r\n    const result = [];\r\n    stringToUTF8(str, (byte) => result.push(byte));\r\n    return new Uint8Array(result);\r\n}\r\nfunction bytesToBase64URL(bytes) {\r\n    const result = [];\r\n    const state = { queue: 0, queuedBits: 0 };\r\n    const onChar = (char) => {\r\n        result.push(char);\r\n    };\r\n    bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));\r\n    // always call with `null` after processing all bytes\r\n    byteToBase64URL(null, state, onChar);\r\n    return result.join('');\r\n}\r\n//# sourceMappingURL=base64url.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["byteFromBase64URL","stringToUint8Array","byteToBase64URL","queue","__esModule","stringFromUTF8","value","stringFromBase64URL","stringToBase64URL","codepoint","codepointToUTF8","bytesToBase64URL","utf8seq","queuedBits","base64UrlToUint8Array","stringToUTF8"]],"~:compiled-at",1771872143436,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$supabase$auth_js$dist$main$lib$base64url.js\",\n\"lineCount\":141,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@supabase/auth-js/dist/main/lib/base64url.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$supabase$auth_js$dist$main$lib$base64url\\\"] = function(require,module,exports) {\\n\\\"use strict\\\";\\r\\n/**\\r\\n * Avoid modifying this file. It's part of\\r\\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\\r\\n * that repo!\\r\\n */\\r\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\r\\nexports.byteToBase64URL = byteToBase64URL;\\r\\nexports.byteFromBase64URL = byteFromBase64URL;\\r\\nexports.stringToBase64URL = stringToBase64URL;\\r\\nexports.stringFromBase64URL = stringFromBase64URL;\\r\\nexports.codepointToUTF8 = codepointToUTF8;\\r\\nexports.stringToUTF8 = stringToUTF8;\\r\\nexports.stringFromUTF8 = stringFromUTF8;\\r\\nexports.base64UrlToUint8Array = base64UrlToUint8Array;\\r\\nexports.stringToUint8Array = stringToUint8Array;\\r\\nexports.bytesToBase64URL = bytesToBase64URL;\\r\\n/**\\r\\n * An array of characters that encode 6 bits into a Base64-URL alphabet\\r\\n * character.\\r\\n */\\r\\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\\r\\n/**\\r\\n * An array of characters that can appear in a Base64-URL encoded string but\\r\\n * should be ignored.\\r\\n */\\r\\nconst IGNORE_BASE64URL = ' \\\\t\\\\n\\\\r='.split('');\\r\\n/**\\r\\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\\r\\n * used to skip the character, or if -1 used to error out.\\r\\n */\\r\\nconst FROM_BASE64URL = (() => {\\r\\n    const charMap = new Array(128);\\r\\n    for (let i = 0; i < charMap.length; i += 1) {\\r\\n        charMap[i] = -1;\\r\\n    }\\r\\n    for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\\r\\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\\r\\n    }\\r\\n    for (let i = 0; i < TO_BASE64URL.length; i += 1) {\\r\\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\\r\\n    }\\r\\n    return charMap;\\r\\n})();\\r\\n/**\\r\\n * Converts a byte to a Base64-URL string.\\r\\n *\\r\\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\\r\\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\\r\\n * @param emit A function called with the next Base64 character when ready.\\r\\n */\\r\\nfunction byteToBase64URL(byte, state, emit) {\\r\\n    if (byte !== null) {\\r\\n        state.queue = (state.queue << 8) | byte;\\r\\n        state.queuedBits += 8;\\r\\n        while (state.queuedBits >= 6) {\\r\\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\\r\\n            emit(TO_BASE64URL[pos]);\\r\\n            state.queuedBits -= 6;\\r\\n        }\\r\\n    }\\r\\n    else if (state.queuedBits > 0) {\\r\\n        state.queue = state.queue << (6 - state.queuedBits);\\r\\n        state.queuedBits = 6;\\r\\n        while (state.queuedBits >= 6) {\\r\\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\\r\\n            emit(TO_BASE64URL[pos]);\\r\\n            state.queuedBits -= 6;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\\r\\n *\\r\\n * @param charCode The char code of the JavaScript string.\\r\\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\\r\\n * @param emit A function called with the next byte.\\r\\n */\\r\\nfunction byteFromBase64URL(charCode, state, emit) {\\r\\n    const bits = FROM_BASE64URL[charCode];\\r\\n    if (bits > -1) {\\r\\n        // valid Base64-URL character\\r\\n        state.queue = (state.queue << 6) | bits;\\r\\n        state.queuedBits += 6;\\r\\n        while (state.queuedBits >= 8) {\\r\\n            emit((state.queue >> (state.queuedBits - 8)) & 0xff);\\r\\n            state.queuedBits -= 8;\\r\\n        }\\r\\n    }\\r\\n    else if (bits === -2) {\\r\\n        // ignore spaces, tabs, newlines, =\\r\\n        return;\\r\\n    }\\r\\n    else {\\r\\n        throw new Error(`Invalid Base64-URL character \\\"${String.fromCharCode(charCode)}\\\"`);\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Converts a JavaScript string (which may include any valid character) into a\\r\\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\\r\\n * then encoded as Base64-URL.\\r\\n *\\r\\n * @param str The string to convert.\\r\\n */\\r\\nfunction stringToBase64URL(str) {\\r\\n    const base64 = [];\\r\\n    const emitter = (char) => {\\r\\n        base64.push(char);\\r\\n    };\\r\\n    const state = { queue: 0, queuedBits: 0 };\\r\\n    stringToUTF8(str, (byte) => {\\r\\n        byteToBase64URL(byte, state, emitter);\\r\\n    });\\r\\n    byteToBase64URL(null, state, emitter);\\r\\n    return base64.join('');\\r\\n}\\r\\n/**\\r\\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\\r\\n * that the underlying string has been encoded as UTF-8.\\r\\n *\\r\\n * @param str The Base64-URL encoded string.\\r\\n */\\r\\nfunction stringFromBase64URL(str) {\\r\\n    const conv = [];\\r\\n    const utf8Emit = (codepoint) => {\\r\\n        conv.push(String.fromCodePoint(codepoint));\\r\\n    };\\r\\n    const utf8State = {\\r\\n        utf8seq: 0,\\r\\n        codepoint: 0,\\r\\n    };\\r\\n    const b64State = { queue: 0, queuedBits: 0 };\\r\\n    const byteEmit = (byte) => {\\r\\n        stringFromUTF8(byte, utf8State, utf8Emit);\\r\\n    };\\r\\n    for (let i = 0; i < str.length; i += 1) {\\r\\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\\r\\n    }\\r\\n    return conv.join('');\\r\\n}\\r\\n/**\\r\\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\\r\\n *\\r\\n * @param codepoint The Unicode codepoint.\\r\\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\\r\\n */\\r\\nfunction codepointToUTF8(codepoint, emit) {\\r\\n    if (codepoint <= 0x7f) {\\r\\n        emit(codepoint);\\r\\n        return;\\r\\n    }\\r\\n    else if (codepoint <= 0x7ff) {\\r\\n        emit(0xc0 | (codepoint >> 6));\\r\\n        emit(0x80 | (codepoint & 0x3f));\\r\\n        return;\\r\\n    }\\r\\n    else if (codepoint <= 0xffff) {\\r\\n        emit(0xe0 | (codepoint >> 12));\\r\\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\\r\\n        emit(0x80 | (codepoint & 0x3f));\\r\\n        return;\\r\\n    }\\r\\n    else if (codepoint <= 0x10ffff) {\\r\\n        emit(0xf0 | (codepoint >> 18));\\r\\n        emit(0x80 | ((codepoint >> 12) & 0x3f));\\r\\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\\r\\n        emit(0x80 | (codepoint & 0x3f));\\r\\n        return;\\r\\n    }\\r\\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\\r\\n}\\r\\n/**\\r\\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\\r\\n *\\r\\n * @param str  The string to convert to UTF-8.\\r\\n * @param emit Function which will be called for each UTF-8 byte of the string.\\r\\n */\\r\\nfunction stringToUTF8(str, emit) {\\r\\n    for (let i = 0; i < str.length; i += 1) {\\r\\n        let codepoint = str.charCodeAt(i);\\r\\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\\r\\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\\r\\n            // range where the next UTF-16 codepoint needs to be combined with the\\r\\n            // current one to get the Unicode codepoint\\r\\n            const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff;\\r\\n            const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff;\\r\\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\\r\\n            i += 1;\\r\\n        }\\r\\n        codepointToUTF8(codepoint, emit);\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Converts a UTF-8 byte to a Unicode codepoint.\\r\\n *\\r\\n * @param byte  The UTF-8 byte next in the sequence.\\r\\n * @param state The shared state between consecutive UTF-8 bytes in the\\r\\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\\r\\n * @param emit  Function which will be called for each codepoint.\\r\\n */\\r\\nfunction stringFromUTF8(byte, state, emit) {\\r\\n    if (state.utf8seq === 0) {\\r\\n        if (byte <= 0x7f) {\\r\\n            emit(byte);\\r\\n            return;\\r\\n        }\\r\\n        // count the number of 1 leading bits until you reach 0\\r\\n        for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\\r\\n            if (((byte >> (7 - leadingBit)) & 1) === 0) {\\r\\n                state.utf8seq = leadingBit;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (state.utf8seq === 2) {\\r\\n            state.codepoint = byte & 31;\\r\\n        }\\r\\n        else if (state.utf8seq === 3) {\\r\\n            state.codepoint = byte & 15;\\r\\n        }\\r\\n        else if (state.utf8seq === 4) {\\r\\n            state.codepoint = byte & 7;\\r\\n        }\\r\\n        else {\\r\\n            throw new Error('Invalid UTF-8 sequence');\\r\\n        }\\r\\n        state.utf8seq -= 1;\\r\\n    }\\r\\n    else if (state.utf8seq > 0) {\\r\\n        if (byte <= 0x7f) {\\r\\n            throw new Error('Invalid UTF-8 sequence');\\r\\n        }\\r\\n        state.codepoint = (state.codepoint << 6) | (byte & 63);\\r\\n        state.utf8seq -= 1;\\r\\n        if (state.utf8seq === 0) {\\r\\n            emit(state.codepoint);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Helper functions to convert different types of strings to Uint8Array\\r\\n */\\r\\nfunction base64UrlToUint8Array(str) {\\r\\n    const result = [];\\r\\n    const state = { queue: 0, queuedBits: 0 };\\r\\n    const onByte = (byte) => {\\r\\n        result.push(byte);\\r\\n    };\\r\\n    for (let i = 0; i < str.length; i += 1) {\\r\\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\\r\\n    }\\r\\n    return new Uint8Array(result);\\r\\n}\\r\\nfunction stringToUint8Array(str) {\\r\\n    const result = [];\\r\\n    stringToUTF8(str, (byte) => result.push(byte));\\r\\n    return new Uint8Array(result);\\r\\n}\\r\\nfunction bytesToBase64URL(bytes) {\\r\\n    const result = [];\\r\\n    const state = { queue: 0, queuedBits: 0 };\\r\\n    const onChar = (char) => {\\r\\n        result.push(char);\\r\\n    };\\r\\n    bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));\\r\\n    // always call with `null` after processing all bytes\\r\\n    byteToBase64URL(null, state, onChar);\\r\\n    return result.join('');\\r\\n}\\r\\n//# sourceMappingURL=base64url.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"require\",\"module\",\"exports\",\"byteToBase64URL\",\"byte\",\"state\",\"emit\",\"queue\",\"queuedBits\",\"TO_BASE64URL\",\"byteFromBase64URL\",\"charCode\",\"bits\",\"FROM_BASE64URL\",\"Error\",\"String\",\"fromCharCode\",\"codepointToUTF8\",\"codepoint\",\"toString\",\"stringToUTF8\",\"str\",\"i\",\"length\",\"charCodeAt\",\"highSurrogate\",\"stringFromUTF8\",\"utf8seq\",\"leadingBit\",\"Object\",\"defineProperty\",\"value\",\"stringToBase64URL\",\"base64\",\"emitter\",\"char\",\"push\",\"join\",\"stringFromBase64URL\",\"conv\",\"utf8Emit\",\"fromCodePoint\",\"utf8State\",\"b64State\",\"byteEmit\",\"base64UrlToUint8Array\",\"result\",\"onByte\",\"Uint8Array\",\"stringToUint8Array\",\"bytesToBase64URL\",\"bytes\",\"onChar\",\"forEach\",\"IGNORE_BASE64URL\",\"charMap\",\"Array\"]\n}\n"]