shadow$provide.module$node_modules$$supabase$realtime_js$dist$main$RealtimeChannel = function(require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.REALTIME_CHANNEL_STATES = exports.REALTIME_SUBSCRIBE_STATES = exports.REALTIME_LISTEN_TYPES = exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = void 0;
  module = require("module$node_modules$tslib$tslib");
  const constants_1 = require("module$node_modules$$supabase$realtime_js$dist$main$lib$constants"), push_1 = module.__importDefault(require("module$node_modules$$supabase$realtime_js$dist$main$lib$push")), timer_1 = module.__importDefault(require("module$node_modules$$supabase$realtime_js$dist$main$lib$timer")), RealtimePresence_1 = module.__importDefault(require("module$node_modules$$supabase$realtime_js$dist$main$RealtimePresence")), Transformers = module.__importStar(require("module$node_modules$$supabase$realtime_js$dist$main$lib$transformers")), 
  transformers_1 = require("module$node_modules$$supabase$realtime_js$dist$main$lib$transformers");
  var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
  (function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL = "*";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT = "INSERT";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE = "UPDATE";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE = "DELETE";
  })(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (exports.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
  var REALTIME_LISTEN_TYPES;
  (function(REALTIME_LISTEN_TYPES) {
    REALTIME_LISTEN_TYPES.BROADCAST = "broadcast";
    REALTIME_LISTEN_TYPES.PRESENCE = "presence";
    REALTIME_LISTEN_TYPES.POSTGRES_CHANGES = "postgres_changes";
    REALTIME_LISTEN_TYPES.SYSTEM = "system";
  })(REALTIME_LISTEN_TYPES || (exports.REALTIME_LISTEN_TYPES = REALTIME_LISTEN_TYPES = {}));
  var REALTIME_SUBSCRIBE_STATES;
  (function(REALTIME_SUBSCRIBE_STATES) {
    REALTIME_SUBSCRIBE_STATES.SUBSCRIBED = "SUBSCRIBED";
    REALTIME_SUBSCRIBE_STATES.TIMED_OUT = "TIMED_OUT";
    REALTIME_SUBSCRIBE_STATES.CLOSED = "CLOSED";
    REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR = "CHANNEL_ERROR";
  })(REALTIME_SUBSCRIBE_STATES || (exports.REALTIME_SUBSCRIBE_STATES = REALTIME_SUBSCRIBE_STATES = {}));
  exports.REALTIME_CHANNEL_STATES = constants_1.CHANNEL_STATES;
  class RealtimeChannel {
    constructor(topic, params = {config:{}}, socket) {
      var _a, _b;
      this.topic = topic;
      this.params = params;
      this.socket = socket;
      this.bindings = {};
      this.state = constants_1.CHANNEL_STATES.closed;
      this.joinedOnce = !1;
      this.pushBuffer = [];
      this.subTopic = topic.replace(/^realtime:/i, "");
      this.params.config = Object.assign({broadcast:{ack:!1, self:!1}, presence:{key:"", enabled:!1}, private:!1}, params.config);
      this.timeout = this.socket.timeout;
      this.joinPush = new push_1.default(this, constants_1.CHANNEL_EVENTS.join, this.params, this.timeout);
      this.rejoinTimer = new timer_1.default(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
      this.joinPush.receive("ok", () => {
        this.state = constants_1.CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach(pushEvent => pushEvent.send());
        this.pushBuffer = [];
      });
      this._onClose(() => {
        this.rejoinTimer.reset();
        this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
        this.state = constants_1.CHANNEL_STATES.closed;
        this.socket._remove(this);
      });
      this._onError(reason => {
        this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, reason), this.state = constants_1.CHANNEL_STATES.errored, this.rejoinTimer.scheduleTimeout());
      });
      this.joinPush.receive("timeout", () => {
        this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = constants_1.CHANNEL_STATES.errored, this.rejoinTimer.scheduleTimeout());
      });
      this.joinPush.receive("error", reason => {
        this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, reason), this.state = constants_1.CHANNEL_STATES.errored, this.rejoinTimer.scheduleTimeout());
      });
      this._on(constants_1.CHANNEL_EVENTS.reply, {}, (payload, ref) => {
        this._trigger(this._replyEventName(ref), payload);
      });
      this.presence = new RealtimePresence_1.default(this);
      this.broadcastEndpointURL = (0,transformers_1.httpEndpointURL)(this.socket.endPoint);
      this.private = this.params.config.private || !1;
      if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? 0 : _b.replay)) {
        throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
      }
    }
    subscribe(callback, timeout = this.timeout) {
      var _a, _b, _c;
      this.socket.isConnected() || this.socket.connect();
      if (this.state == constants_1.CHANNEL_STATES.closed) {
        const {config:{broadcast, presence, private:isPrivate}} = this.params;
        var postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : [];
        _a = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === !0;
        _c = {};
        postgres_changes = {broadcast, presence:Object.assign(Object.assign({}, presence), {enabled:_a}), postgres_changes, private:isPrivate};
        this.socket.accessTokenValue && (_c.access_token = this.socket.accessTokenValue);
        this._onError(e => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
        this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
        this.updateJoinPayload(Object.assign({config:postgres_changes}, _c));
        this.joinedOnce = !0;
        this._rejoin(timeout);
        this.joinPush.receive("ok", async({postgres_changes}) => {
          var _a;
          this.socket._isManualToken() || this.socket.setAuth();
          if (postgres_changes === void 0) {
            callback === null || callback === void 0 || callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          } else {
            const clientPostgresBindings = this.bindings.postgres_changes, bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;
            _a = [];
            for (let i = 0; i < bindingsLen; i++) {
              const clientPostgresBinding = clientPostgresBindings[i], {filter:{event, schema, table, filter}} = clientPostgresBinding, serverPostgresFilter = postgres_changes && postgres_changes[i];
              if (serverPostgresFilter && serverPostgresFilter.event === event && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {
                _a.push(Object.assign(Object.assign({}, clientPostgresBinding), {id:serverPostgresFilter.id}));
              } else {
                this.unsubscribe();
                this.state = constants_1.CHANNEL_STATES.errored;
                callback === null || callback === void 0 || callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, Error("mismatch between server and client bindings for postgres changes"));
                return;
              }
            }
            this.bindings.postgres_changes = _a;
            callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          }
        }).receive("error", error => {
          this.state = constants_1.CHANNEL_STATES.errored;
          callback === null || callback === void 0 || callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, Error(JSON.stringify(Object.values(error).join(", ") || "error")));
        }).receive("timeout", () => {
          callback === null || callback === void 0 || callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
        });
      }
      return this;
    }
    presenceState() {
      return this.presence.state;
    }
    async track(payload, opts = {}) {
      return await this.send({type:"presence", event:"track", payload}, opts.timeout || this.timeout);
    }
    async untrack(opts = {}) {
      return await this.send({type:"presence", event:"untrack"}, opts);
    }
    on(type, filter, callback) {
      this.state === constants_1.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`), this.unsubscribe().then(async() => await this.subscribe()));
      return this._on(type, filter, callback);
    }
    async httpSend(event, payload, opts = {}) {
      var _a;
      if (payload === void 0 || payload === null) {
        return Promise.reject("Payload is required for httpSend()");
      }
      const headers = {apikey:this.socket.apiKey ? this.socket.apiKey : "", "Content-Type":"application/json"};
      this.socket.accessTokenValue && (headers.Authorization = `Bearer ${this.socket.accessTokenValue}`);
      event = {method:"POST", headers, body:JSON.stringify({messages:[{topic:this.subTopic, event, payload, private:this.private}]})};
      opts = await this._fetchWithTimeout(this.broadcastEndpointURL, event, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);
      if (opts.status === 202) {
        return {success:!0};
      }
      _a = opts.statusText;
      try {
        const errorBody = await opts.json();
        _a = errorBody.error || errorBody.message || _a;
      } catch (_b) {
      }
      return Promise.reject(Error(_a));
    }
    async send(args, opts = {}) {
      var _a, _b;
      if (this._canPush() || args.type !== "broadcast") {
        return new Promise(resolve => {
          var _a, _b, _c;
          const push = this._push(args.type, args, opts.timeout || this.timeout);
          args.type !== "broadcast" || ((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? 0 : _c.ack) || resolve("ok");
          push.receive("ok", () => resolve("ok"));
          push.receive("error", () => resolve("error"));
          push.receive("timeout", () => resolve("timed out"));
        });
      }
      console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
      const {event, payload:endpoint_payload} = args;
      var headers = {apikey:this.socket.apiKey ? this.socket.apiKey : "", "Content-Type":"application/json"};
      this.socket.accessTokenValue && (headers.Authorization = `Bearer ${this.socket.accessTokenValue}`);
      headers = {method:"POST", headers, body:JSON.stringify({messages:[{topic:this.subTopic, event, payload:endpoint_payload, private:this.private}]})};
      try {
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, headers, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);
        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
        return response.ok ? "ok" : "error";
      } catch (error) {
        return error.name === "AbortError" ? "timed out" : "error";
      }
    }
    updateJoinPayload(payload) {
      this.joinPush.updatePayload(payload);
    }
    unsubscribe(timeout = this.timeout) {
      this.state = constants_1.CHANNEL_STATES.leaving;
      const onClose = () => {
        this.socket.log("channel", `leave ${this.topic}`);
        this._trigger(constants_1.CHANNEL_EVENTS.close, "leave", this._joinRef());
      };
      this.joinPush.destroy();
      let leavePush = null;
      return (new Promise(resolve => {
        leavePush = new push_1.default(this, constants_1.CHANNEL_EVENTS.leave, {}, timeout);
        leavePush.receive("ok", () => {
          onClose();
          resolve("ok");
        }).receive("timeout", () => {
          onClose();
          resolve("timed out");
        }).receive("error", () => {
          resolve("error");
        });
        leavePush.send();
        this._canPush() || leavePush.trigger("ok", {});
      })).finally(() => {
        leavePush === null || leavePush === void 0 || leavePush.destroy();
      });
    }
    teardown() {
      this.pushBuffer.forEach(push => push.destroy());
      this.pushBuffer = [];
      this.rejoinTimer.reset();
      this.joinPush.destroy();
      this.state = constants_1.CHANNEL_STATES.closed;
      this.bindings = {};
    }
    async _fetchWithTimeout(url, options, timeout) {
      const controller = new AbortController();
      timeout = setTimeout(() => controller.abort(), timeout);
      url = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {signal:controller.signal}));
      clearTimeout(timeout);
      return url;
    }
    _push(event, payload, timeout = this.timeout) {
      if (!this.joinedOnce) {
        throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
      }
      event = new push_1.default(this, event, payload, timeout);
      this._canPush() ? event.send() : this._addToPushBuffer(event);
      return event;
    }
    _addToPushBuffer(pushEvent) {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
      this.pushBuffer.length > constants_1.MAX_PUSH_BUFFER_SIZE && (pushEvent = this.pushBuffer.shift()) && (pushEvent.destroy(), this.socket.log("channel", `discarded push due to buffer overflow: ${pushEvent.event}`, pushEvent.payload));
    }
    _onMessage(_event, payload, _ref) {
      return payload;
    }
    _isMember(topic) {
      return this.topic === topic;
    }
    _joinRef() {
      return this.joinPush.ref;
    }
    _trigger(type, payload, ref) {
      var _a, _b;
      const typeLower = type.toLocaleLowerCase(), {close, error, leave, join} = constants_1.CHANNEL_EVENTS;
      type = [close, error, leave, join];
      if (!(ref && type.indexOf(typeLower) >= 0 && ref !== this._joinRef())) {
        var handledPayload = this._onMessage(typeLower, payload, ref);
        if (payload && !handledPayload) {
          throw "channel onMessage callbacks must return the payload, modified or unmodified";
        }
        ["insert", "update", "delete"].includes(typeLower) ? (_a = this.bindings.postgres_changes) === null || _a === void 0 || _a.filter(bind => {
          var _a, _b, _c;
          return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === "*" || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
        }).map(bind => bind.callback(handledPayload, ref)) : (_b = this.bindings[typeLower]) === null || _b === void 0 || _b.filter(bind => {
          var _a, _b, _c, _e, _f;
          if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
            if ("id" in bind) {
              var _d = bind.id;
              bind = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;
              return _d && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(_d)) && (bind === "*" || (bind === null || bind === void 0 ? void 0 : bind.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
            }
            _a = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return _a === "*" || _a === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
          return bind.type.toLocaleLowerCase() === typeLower;
        }).map(bind => {
          if (typeof handledPayload === "object" && "ids" in handledPayload) {
            const postgresChanges = handledPayload.data, {schema, table, commit_timestamp, type, errors} = postgresChanges;
            handledPayload = Object.assign(Object.assign({}, {schema, table, commit_timestamp, eventType:type, new:{}, old:{}, errors}), this._getPayloadRecords(postgresChanges));
          }
          bind.callback(handledPayload, ref);
        });
      }
    }
    _isClosed() {
      return this.state === constants_1.CHANNEL_STATES.closed;
    }
    _isJoined() {
      return this.state === constants_1.CHANNEL_STATES.joined;
    }
    _isJoining() {
      return this.state === constants_1.CHANNEL_STATES.joining;
    }
    _isLeaving() {
      return this.state === constants_1.CHANNEL_STATES.leaving;
    }
    _replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    _on(type, filter, callback) {
      type = type.toLocaleLowerCase();
      filter = {type, filter, callback};
      this.bindings[type] ? this.bindings[type].push(filter) : this.bindings[type] = [filter];
      return this;
    }
    _off(type, filter) {
      const typeLower = type.toLocaleLowerCase();
      this.bindings[typeLower] && (this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {
        var _a;
        return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
      }));
      return this;
    }
    static isEqual(obj1, obj2) {
      if (Object.keys(obj1).length !== Object.keys(obj2).length) {
        return !1;
      }
      for (const k in obj1) {
        if (obj1[k] !== obj2[k]) {
          return !1;
        }
      }
      return !0;
    }
    static isFilterValueEqual(serverValue, clientValue) {
      return (serverValue !== null && serverValue !== void 0 ? serverValue : void 0) === (clientValue !== null && clientValue !== void 0 ? clientValue : void 0);
    }
    _rejoinUntilConnected() {
      this.rejoinTimer.scheduleTimeout();
      this.socket.isConnected() && this._rejoin();
    }
    _onClose(callback) {
      this._on(constants_1.CHANNEL_EVENTS.close, {}, callback);
    }
    _onError(callback) {
      this._on(constants_1.CHANNEL_EVENTS.error, {}, reason => callback(reason));
    }
    _canPush() {
      return this.socket.isConnected() && this._isJoined();
    }
    _rejoin(timeout = this.timeout) {
      this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = constants_1.CHANNEL_STATES.joining, this.joinPush.resend(timeout));
    }
    _getPayloadRecords(payload) {
      const records = {new:{}, old:{}};
      if (payload.type === "INSERT" || payload.type === "UPDATE") {
        records.new = Transformers.convertChangeData(payload.columns, payload.record);
      }
      if (payload.type === "UPDATE" || payload.type === "DELETE") {
        records.old = Transformers.convertChangeData(payload.columns, payload.old_record);
      }
      return records;
    }
  }
  exports.default = RealtimeChannel;
};

//# sourceMappingURL=module$node_modules$$supabase$realtime_js$dist$main$RealtimeChannel.js.map
