shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$fetch = function(require, module, exports) {
  async function handleError(error) {
    var _a;
    if (!(0,helpers_1.looksLikeFetchResponse)(error)) {
      throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), 0);
    }
    if (NETWORK_ERROR_CODES.includes(error.status)) {
      throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), error.status);
    }
    let data;
    try {
      data = await error.json();
    } catch (e) {
      throw new errors_1.AuthUnknownError(_getErrorMessage(e), e);
    }
    let errorCode = void 0;
    const responseAPIVersion = (0,helpers_1.parseResponseAPIVersion)(error);
    responseAPIVersion && responseAPIVersion.getTime() >= constants_1.API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string" ? errorCode = data.code : typeof data === "object" && data && typeof data.error_code === "string" && (errorCode = data.error_code);
    if (errorCode) {
      if (errorCode === "weak_password") {
        throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);
      }
      if (errorCode === "session_not_found") {
        throw new errors_1.AuthSessionMissingError();
      }
    } else {
      if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", !0)) {
        throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);
      }
    }
    throw new errors_1.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);
  }
  async function _handleRequest(fetcher, method, url, options, parameters, body) {
    {
      const params = {method, headers:(options === null || options === void 0 ? void 0 : options.headers) || {}};
      method === "GET" ? method = params : (params.headers = Object.assign({"Content-Type":"application/json;charset\x3dUTF-8"}, options === null || options === void 0 ? void 0 : options.headers), params.body = JSON.stringify(body), method = Object.assign(Object.assign({}, params), parameters));
    }
    let result;
    try {
      result = await fetcher(url, Object.assign({}, method));
    } catch (e) {
      throw console.error(e), new errors_1.AuthRetryableFetchError(_getErrorMessage(e), 0);
    }
    result.ok || await handleError(result);
    if (options === null || options === void 0 ? 0 : options.noResolveJson) {
      return result;
    }
    try {
      return await result.json();
    } catch (e) {
      await handleError(e);
    }
  }
  function _sessionResponse(data) {
    var _a;
    let session = null;
    data.access_token && data.refresh_token && data.expires_in && (session = Object.assign({}, data), data.expires_at || (session.expires_at = (0,helpers_1.expiresAt)(data.expires_in)));
    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
    return {data:{session, user}, error:null};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.handleError = handleError;
  exports._request = async function(fetcher, method, url, options) {
    var _a;
    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
    headers[constants_1.API_VERSION_HEADER_NAME] || (headers[constants_1.API_VERSION_HEADER_NAME] = constants_1.API_VERSIONS["2024-01-01"].name);
    if (options === null || options === void 0 ? 0 : options.jwt) {
      headers.Authorization = `Bearer ${options.jwt}`;
    }
    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};
    if (options === null || options === void 0 ? 0 : options.redirectTo) {
      qs.redirect_to = options.redirectTo;
    }
    _a = Object.keys(qs).length ? "?" + (new URLSearchParams(qs)).toString() : "";
    fetcher = await _handleRequest(fetcher, method, url + _a, {headers, noResolveJson:options === null || options === void 0 ? void 0 : options.noResolveJson}, {}, options === null || options === void 0 ? void 0 : options.body);
    return (options === null || options === void 0 ? 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(fetcher) : {data:Object.assign({}, fetcher), error:null};
  };
  exports._sessionResponse = _sessionResponse;
  exports._sessionResponsePassword = function(data) {
    const response = _sessionResponse(data);
    !response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", !0) && (response.data.weak_password = data.weak_password);
    return response;
  };
  exports._userResponse = function(data) {
    var _a;
    return {data:{user:(_a = data.user) !== null && _a !== void 0 ? _a : data}, error:null};
  };
  exports._ssoResponse = function(data) {
    return {data, error:null};
  };
  exports._generateLinkResponse = function(data) {
    const {action_link, email_otp, hashed_token, redirect_to, verification_type} = data;
    var rest = tslib_1.__rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
    data = {action_link, email_otp, hashed_token, redirect_to, verification_type};
    rest = Object.assign({}, rest);
    return {data:{properties:data, user:rest}, error:null};
  };
  exports._noResolveJsonResponse = function(data) {
    return data;
  };
  const tslib_1 = require("module$node_modules$tslib$tslib"), constants_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$constants"), helpers_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$helpers"), errors_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$errors"), _getErrorMessage = err => err.msg || err.message || err.error_description || err.error || JSON.stringify(err), NETWORK_ERROR_CODES = [502, 503, 504];
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$lib$fetch.js.map
