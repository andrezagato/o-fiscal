shadow$provide.module$node_modules$iceberg_js$dist$index_cjs = function(require, module, exports) {
  async function buildAuthHeaders(auth) {
    return auth && auth.type !== "none" ? auth.type === "bearer" ? {Authorization:`Bearer ${auth.token}`} : auth.type === "header" ? {[auth.name]:auth.value} : auth.type === "custom" ? await auth.getHeaders() : {} : {};
  }
  function createFetchClient(options) {
    const fetchFn = options.fetchImpl ?? globalThis.fetch;
    return {async request({method, path, query, body, headers}) {
      path = new URL(path, options.baseUrl);
      if (query) {
        for (const [key, value] of Object.entries(query)) {
          value !== void 0 && path.searchParams.set(key, value);
        }
      }
      query = path.toString();
      path = await buildAuthHeaders(options.auth);
      method = await fetchFn(query, {method, headers:{...(body ? {"Content-Type":"application/json"} : {}), ...path, ...headers}, body:body ? JSON.stringify(body) : void 0});
      headers = await method.text();
      headers = (body = (method.headers.get("content-type") || "").includes("application/json")) && headers ? JSON.parse(headers) : headers;
      if (!method.ok) {
        throw body = body ? headers : void 0, headers = body?.error, new IcebergError(headers?.message ?? `Request failed with status ${method.status}`, {status:method.status, icebergType:headers?.type, icebergCode:headers?.code, details:body});
      }
      return {status:method.status, headers:method.headers, data:headers};
    }};
  }
  function namespaceToPath2(namespace) {
    return namespace.join("");
  }
  function parseDecimalType(type) {
    return (type = type.match(DECIMAL_REGEX)) ? {precision:parseInt(type[1], 10), scale:parseInt(type[2], 10)} : null;
  }
  function parseFixedType(type) {
    return (type = type.match(FIXED_REGEX)) ? {length:parseInt(type[1], 10)} : null;
  }
  var IcebergError = class extends Error {
    constructor(message, opts) {
      super(message);
      this.name = "IcebergError";
      this.status = opts.status;
      this.icebergType = opts.icebergType;
      this.icebergCode = opts.icebergCode;
      this.details = opts.details;
      this.isCommitStateUnknown = opts.icebergType === "CommitStateUnknownException" || [500, 502, 504].includes(opts.status) && opts.icebergType?.includes("CommitState") === !0;
    }
    isNotFound() {
      return this.status === 404;
    }
    isConflict() {
      return this.status === 409;
    }
    isAuthenticationTimeout() {
      return this.status === 419;
    }
  }, NamespaceOperations = class {
    constructor(client, prefix = "") {
      this.client = client;
      this.prefix = prefix;
    }
    async listNamespaces(parent) {
      parent = parent ? {parent:parent.namespace.join("")} : void 0;
      return (await this.client.request({method:"GET", path:`${this.prefix}/namespaces`, query:parent})).data.namespaces.map(ns => ({namespace:ns}));
    }
    async createNamespace(id, metadata) {
      return (await this.client.request({method:"POST", path:`${this.prefix}/namespaces`, body:{namespace:id.namespace, properties:metadata?.properties}})).data;
    }
    async dropNamespace(id) {
      await this.client.request({method:"DELETE", path:`${this.prefix}/namespaces/${id.namespace.join("")}`});
    }
    async loadNamespaceMetadata(id) {
      return {properties:(await this.client.request({method:"GET", path:`${this.prefix}/namespaces/${id.namespace.join("")}`})).data.properties};
    }
    async namespaceExists(id) {
      try {
        return await this.client.request({method:"HEAD", path:`${this.prefix}/namespaces/${id.namespace.join("")}`}), !0;
      } catch (error) {
        if (error instanceof IcebergError && error.status === 404) {
          return !1;
        }
        throw error;
      }
    }
    async createNamespaceIfNotExists(id, metadata) {
      try {
        return await this.createNamespace(id, metadata);
      } catch (error) {
        if (!(error instanceof IcebergError && error.status === 409)) {
          throw error;
        }
      }
    }
  }, TableOperations = class {
    constructor(client, prefix = "", accessDelegation) {
      this.client = client;
      this.prefix = prefix;
      this.accessDelegation = accessDelegation;
    }
    async listTables(namespace) {
      return (await this.client.request({method:"GET", path:`${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`})).data.identifiers;
    }
    async createTable(namespace, request) {
      const headers = {};
      this.accessDelegation && (headers["X-Iceberg-Access-Delegation"] = this.accessDelegation);
      return (await this.client.request({method:"POST", path:`${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`, body:request, headers})).data.metadata;
    }
    async updateTable(id, request) {
      id = await this.client.request({method:"POST", path:`${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`, body:request});
      return {"metadata-location":id.data["metadata-location"], metadata:id.data.metadata};
    }
    async dropTable(id, options) {
      await this.client.request({method:"DELETE", path:`${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`, query:{purgeRequested:String(options?.purge ?? !1)}});
    }
    async loadTable(id) {
      const headers = {};
      this.accessDelegation && (headers["X-Iceberg-Access-Delegation"] = this.accessDelegation);
      return (await this.client.request({method:"GET", path:`${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`, headers})).data.metadata;
    }
    async tableExists(id) {
      const headers = {};
      this.accessDelegation && (headers["X-Iceberg-Access-Delegation"] = this.accessDelegation);
      try {
        return await this.client.request({method:"HEAD", path:`${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`, headers}), !0;
      } catch (error) {
        if (error instanceof IcebergError && error.status === 404) {
          return !1;
        }
        throw error;
      }
    }
    async createTableIfNotExists(namespace, request) {
      try {
        return await this.createTable(namespace, request);
      } catch (error) {
        if (error instanceof IcebergError && error.status === 409) {
          return await this.loadTable({namespace:namespace.namespace, name:request.name});
        }
        throw error;
      }
    }
  };
  require = class {
    constructor(options) {
      let prefix = "v1";
      options.catalogName && (prefix += `/${options.catalogName}`);
      const baseUrl = options.baseUrl.endsWith("/") ? options.baseUrl : `${options.baseUrl}/`;
      this.client = createFetchClient({baseUrl, auth:options.auth, fetchImpl:options.fetch});
      this.accessDelegation = options.accessDelegation?.join(",");
      this.namespaceOps = new NamespaceOperations(this.client, prefix);
      this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);
    }
    async listNamespaces(parent) {
      return this.namespaceOps.listNamespaces(parent);
    }
    async createNamespace(id, metadata) {
      return this.namespaceOps.createNamespace(id, metadata);
    }
    async dropNamespace(id) {
      await this.namespaceOps.dropNamespace(id);
    }
    async loadNamespaceMetadata(id) {
      return this.namespaceOps.loadNamespaceMetadata(id);
    }
    async listTables(namespace) {
      return this.tableOps.listTables(namespace);
    }
    async createTable(namespace, request) {
      return this.tableOps.createTable(namespace, request);
    }
    async updateTable(id, request) {
      return this.tableOps.updateTable(id, request);
    }
    async dropTable(id, options) {
      await this.tableOps.dropTable(id, options);
    }
    async loadTable(id) {
      return this.tableOps.loadTable(id);
    }
    async namespaceExists(id) {
      return this.namespaceOps.namespaceExists(id);
    }
    async tableExists(id) {
      return this.tableOps.tableExists(id);
    }
    async createNamespaceIfNotExists(id, metadata) {
      return this.namespaceOps.createNamespaceIfNotExists(id, metadata);
    }
    async createTableIfNotExists(namespace, request) {
      return this.tableOps.createTableIfNotExists(namespace, request);
    }
  };
  var DECIMAL_REGEX = /^decimal\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)$/, FIXED_REGEX = /^fixed\s*\[\s*(\d+)\s*\]$/;
  exports.IcebergError = IcebergError;
  exports.IcebergRestCatalog = require;
  exports.getCurrentSchema = function(metadata) {
    return metadata.schemas.find(s => s["schema-id"] === metadata["current-schema-id"]);
  };
  exports.isDecimalType = function(type) {
    return DECIMAL_REGEX.test(type);
  };
  exports.isFixedType = function(type) {
    return FIXED_REGEX.test(type);
  };
  exports.parseDecimalType = parseDecimalType;
  exports.parseFixedType = parseFixedType;
  exports.typesEqual = function(a, b) {
    var decimalA = parseDecimalType(a), decimalB = parseDecimalType(b);
    if (decimalA && decimalB) {
      return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;
    }
    decimalA = parseFixedType(a);
    decimalB = parseFixedType(b);
    return decimalA && decimalB ? decimalA.length === decimalB.length : a === b;
  };
};

//# sourceMappingURL=module$node_modules$iceberg_js$dist$index_cjs.js.map
