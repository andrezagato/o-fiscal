shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$webauthn = function(require, module, exports) {
  function browserSupportsWebAuthn() {
    var _a, _b;
    return !!((0,helpers_1.isBrowser)() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === "function" && typeof((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === "function");
  }
  async function createCredential(options) {
    try {
      const response = await navigator.credentials.create(options);
      return response ? response instanceof PublicKeyCredential ? {data:response, error:null} : {data:null, error:new webauthn_errors_1.WebAuthnUnknownError("Browser returned unexpected credential type", response)} : {data:null, error:new webauthn_errors_1.WebAuthnUnknownError("Empty credential response", response)};
    } catch (err) {
      return {data:null, error:(0,webauthn_errors_1.identifyRegistrationError)({error:err, options})};
    }
  }
  async function getCredential(options) {
    try {
      const response = await navigator.credentials.get(options);
      return response ? response instanceof PublicKeyCredential ? {data:response, error:null} : {data:null, error:new webauthn_errors_1.WebAuthnUnknownError("Browser returned unexpected credential type", response)} : {data:null, error:new webauthn_errors_1.WebAuthnUnknownError("Empty credential response", response)};
    } catch (err) {
      return {data:null, error:(0,webauthn_errors_1.identifyAuthenticationError)({error:err, options})};
    }
  }
  function deepMerge(...sources) {
    const result = {};
    for (const source of sources) {
      if (source) {
        for (const key in source) {
          if (sources = source[key], sources !== void 0) {
            if (Array.isArray(sources)) {
              result[key] = sources;
            } else if (sources instanceof ArrayBuffer || ArrayBuffer.isView(sources)) {
              result[key] = sources;
            } else if (sources === null || typeof sources !== "object" || Array.isArray(sources)) {
              result[key] = sources;
            } else {
              const existing = result[key];
              existing === null || typeof existing !== "object" || Array.isArray(existing) ? result[key] = deepMerge(sources) : result[key] = deepMerge(existing, sources);
            }
          }
        }
      }
    }
    return result;
  }
  function mergeCredentialCreationOptions(baseOptions, overrides) {
    return deepMerge(exports.DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});
  }
  function mergeCredentialRequestOptions(baseOptions, overrides) {
    return deepMerge(exports.DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.WebAuthnApi = exports.DEFAULT_REQUEST_OPTIONS = exports.DEFAULT_CREATION_OPTIONS = exports.webAuthnAbortService = exports.WebAuthnAbortService = exports.identifyAuthenticationError = exports.identifyRegistrationError = exports.isWebAuthnError = exports.WebAuthnError = void 0;
  exports.deserializeCredentialCreationOptions = function(options) {
    if (!options) {
      throw Error("Credential creation options are required");
    }
    if (typeof PublicKeyCredential !== "undefined" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === "function") {
      return PublicKeyCredential.parseCreationOptionsFromJSON(options);
    }
    const {challenge:challengeStr, user:userOpts, excludeCredentials} = options;
    options = tslib_1.__rest(options, ["challenge", "user", "excludeCredentials"]);
    var challenge = (0,base64url_1.base64UrlToUint8Array)(challengeStr).buffer, user = Object.assign(Object.assign({}, userOpts), {id:(0,base64url_1.base64UrlToUint8Array)(userOpts.id).buffer});
    options = Object.assign(Object.assign({}, options), {challenge, user});
    if (excludeCredentials && excludeCredentials.length > 0) {
      for (options.excludeCredentials = Array(excludeCredentials.length), challenge = 0; challenge < excludeCredentials.length; challenge++) {
        user = excludeCredentials[challenge], options.excludeCredentials[challenge] = Object.assign(Object.assign({}, user), {id:(0,base64url_1.base64UrlToUint8Array)(user.id).buffer, type:user.type || "public-key", transports:user.transports});
      }
    }
    return options;
  };
  exports.deserializeCredentialRequestOptions = function(options) {
    if (!options) {
      throw Error("Credential request options are required");
    }
    if (typeof PublicKeyCredential !== "undefined" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === "function") {
      return PublicKeyCredential.parseRequestOptionsFromJSON(options);
    }
    const {challenge:challengeStr, allowCredentials} = options;
    options = tslib_1.__rest(options, ["challenge", "allowCredentials"]);
    var challenge = (0,base64url_1.base64UrlToUint8Array)(challengeStr).buffer;
    options = Object.assign(Object.assign({}, options), {challenge});
    if (allowCredentials && allowCredentials.length > 0) {
      for (options.allowCredentials = Array(allowCredentials.length), challenge = 0; challenge < allowCredentials.length; challenge++) {
        const cred = allowCredentials[challenge];
        options.allowCredentials[challenge] = Object.assign(Object.assign({}, cred), {id:(0,base64url_1.base64UrlToUint8Array)(cred.id).buffer, type:cred.type || "public-key", transports:cred.transports});
      }
    }
    return options;
  };
  exports.serializeCredentialCreationResponse = function(credential) {
    var _a;
    return "toJSON" in credential && typeof credential.toJSON === "function" ? credential.toJSON() : {id:credential.id, rawId:credential.id, response:{attestationObject:(0,base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)), clientDataJSON:(0,base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON))}, type:"public-key", clientExtensionResults:credential.getClientExtensionResults(), authenticatorAttachment:(_a = credential.authenticatorAttachment) !== 
    null && _a !== void 0 ? _a : void 0};
  };
  exports.serializeCredentialRequestResponse = function(credential) {
    var _a;
    if ("toJSON" in credential && typeof credential.toJSON === "function") {
      return credential.toJSON();
    }
    const clientExtensionResults = credential.getClientExtensionResults(), assertionResponse = credential.response;
    return {id:credential.id, rawId:credential.id, response:{authenticatorData:(0,base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)), clientDataJSON:(0,base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)), signature:(0,base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)), userHandle:assertionResponse.userHandle ? (0,base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle)) : void 0}, type:"public-key", 
    clientExtensionResults, authenticatorAttachment:(_a = credential.authenticatorAttachment) !== null && _a !== void 0 ? _a : void 0};
  };
  exports.isValidDomain = function(hostname) {
    return hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname);
  };
  exports.createCredential = createCredential;
  exports.getCredential = getCredential;
  exports.mergeCredentialCreationOptions = mergeCredentialCreationOptions;
  exports.mergeCredentialRequestOptions = mergeCredentialRequestOptions;
  const tslib_1 = require("module$node_modules$tslib$tslib"), base64url_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$base64url"), errors_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$errors"), helpers_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$helpers"), webauthn_errors_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$webauthn_errors");
  Object.defineProperty(exports, "identifyAuthenticationError", {enumerable:!0, get:function() {
    return webauthn_errors_1.identifyAuthenticationError;
  }});
  Object.defineProperty(exports, "identifyRegistrationError", {enumerable:!0, get:function() {
    return webauthn_errors_1.identifyRegistrationError;
  }});
  Object.defineProperty(exports, "isWebAuthnError", {enumerable:!0, get:function() {
    return webauthn_errors_1.isWebAuthnError;
  }});
  Object.defineProperty(exports, "WebAuthnError", {enumerable:!0, get:function() {
    return webauthn_errors_1.WebAuthnError;
  }});
  class WebAuthnAbortService {
    createNewAbortSignal() {
      if (this.controller) {
        var abortError = Error("Cancelling existing WebAuthn API call for new one");
        abortError.name = "AbortError";
        this.controller.abort(abortError);
      }
      this.controller = abortError = new AbortController();
      return abortError.signal;
    }
    cancelCeremony() {
      if (this.controller) {
        const abortError = Error("Manually cancelling existing WebAuthn API call");
        abortError.name = "AbortError";
        this.controller.abort(abortError);
        this.controller = void 0;
      }
    }
  }
  exports.WebAuthnAbortService = WebAuthnAbortService;
  exports.webAuthnAbortService = new WebAuthnAbortService();
  exports.DEFAULT_CREATION_OPTIONS = {hints:["security-key"], authenticatorSelection:{authenticatorAttachment:"cross-platform", requireResidentKey:!1, userVerification:"preferred", residentKey:"discouraged"}, attestation:"direct"};
  exports.DEFAULT_REQUEST_OPTIONS = {userVerification:"preferred", hints:["security-key"], attestation:"direct"};
  class WebAuthnApi {
    constructor(client) {
      this.client = client;
      this.enroll = this._enroll.bind(this);
      this.challenge = this._challenge.bind(this);
      this.verify = this._verify.bind(this);
      this.authenticate = this._authenticate.bind(this);
      this.register = this._register.bind(this);
    }
    async _enroll(params) {
      return this.client.mfa.enroll(Object.assign(Object.assign({}, params), {factorType:"webauthn"}));
    }
    async _challenge({factorId, webauthn, friendlyName, signal}, overrides) {
      var _a;
      try {
        const {data:challengeResponse, error:challengeError} = await this.client.mfa.challenge({factorId, webauthn});
        if (!challengeResponse) {
          return {data:null, error:challengeError};
        }
        const abortSignal = signal !== null && signal !== void 0 ? signal : exports.webAuthnAbortService.createNewAbortSignal();
        if (challengeResponse.webauthn.type === "create") {
          const {user} = challengeResponse.webauthn.credential_options.publicKey;
          if (!user.name) {
            if (friendlyName) {
              user.name = `${user.id}:${friendlyName}`;
            } else {
              const userData = (await this.client.getUser()).data.user, fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || "User";
              user.name = `${user.id}:${fallbackName}`;
            }
          }
          user.displayName || (user.displayName = user.name);
        }
        switch(challengeResponse.webauthn.type) {
          case "create":
            const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create), {data, error} = await createCredential({publicKey:options, signal:abortSignal});
            return data ? {data:{factorId, challengeId:challengeResponse.id, webauthn:{type:challengeResponse.webauthn.type, credential_response:data}}, error:null} : {data:null, error};
          case "request":
            const options$jscomp$0 = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request), {data:data$jscomp$0, error:error$jscomp$0} = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {publicKey:options$jscomp$0, signal:abortSignal}));
            return data$jscomp$0 ? {data:{factorId, challengeId:challengeResponse.id, webauthn:{type:challengeResponse.webauthn.type, credential_response:data$jscomp$0}}, error:null} : {data:null, error:error$jscomp$0};
        }
      } catch (error) {
        return (0,errors_1.isAuthError)(error) ? {data:null, error} : {data:null, error:new errors_1.AuthUnknownError("Unexpected error in challenge", error)};
      }
    }
    async _verify({challengeId, factorId, webauthn}) {
      return this.client.mfa.verify({factorId, challengeId, webauthn});
    }
    async _authenticate({factorId, webauthn:{rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal} = {}}, overrides) {
      if (!rpId) {
        return {data:null, error:new errors_1.AuthError("rpId is required for WebAuthn authentication")};
      }
      try {
        if (!browserSupportsWebAuthn()) {
          return {data:null, error:new errors_1.AuthUnknownError("Browser does not support WebAuthn", null)};
        }
        const {data:challengeResponse, error:challengeError} = await this.challenge({factorId, webauthn:{rpId, rpOrigins}, signal}, {request:overrides});
        if (!challengeResponse) {
          return {data:null, error:challengeError};
        }
        ({webauthn:signal} = challengeResponse);
        return this._verify({factorId, challengeId:challengeResponse.challengeId, webauthn:{type:signal.type, rpId, rpOrigins, credential_response:signal.credential_response}});
      } catch (error) {
        return (0,errors_1.isAuthError)(error) ? {data:null, error} : {data:null, error:new errors_1.AuthUnknownError("Unexpected error in authenticate", error)};
      }
    }
    async _register({friendlyName, webauthn:{rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal} = {}}, overrides) {
      if (!rpId) {
        return {data:null, error:new errors_1.AuthError("rpId is required for WebAuthn registration")};
      }
      try {
        if (!browserSupportsWebAuthn()) {
          return {data:null, error:new errors_1.AuthUnknownError("Browser does not support WebAuthn", null)};
        }
        const {data:factor, error:enrollError} = await this._enroll({friendlyName});
        if (!factor) {
          return await this.client.mfa.listFactors().then(factors => {
            var _a;
            return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find(v => v.factor_type === "webauthn" && v.friendly_name === friendlyName && v.status !== "unverified");
          }).then(factor => factor ? this.client.mfa.unenroll({factorId:factor === null || factor === void 0 ? void 0 : factor.id}) : void 0), {data:null, error:enrollError};
        }
        const {data:challengeResponse, error:challengeError} = await this._challenge({factorId:factor.id, friendlyName:factor.friendly_name, webauthn:{rpId, rpOrigins}, signal}, {create:overrides});
        return challengeResponse ? this._verify({factorId:factor.id, challengeId:challengeResponse.challengeId, webauthn:{rpId, rpOrigins, type:challengeResponse.webauthn.type, credential_response:challengeResponse.webauthn.credential_response}}) : {data:null, error:challengeError};
      } catch (error) {
        return (0,errors_1.isAuthError)(error) ? {data:null, error} : {data:null, error:new errors_1.AuthUnknownError("Unexpected error in register", error)};
      }
    }
  }
  exports.WebAuthnApi = WebAuthnApi;
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$lib$webauthn.js.map
