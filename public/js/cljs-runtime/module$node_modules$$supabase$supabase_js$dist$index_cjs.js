shadow$provide.module$node_modules$$supabase$supabase_js$dist$index_cjs = function(require, module, exports) {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
      return typeof o$1;
    } : function(o$1) {
      return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
    }, _typeof(o);
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r$1) {
        return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
      }));
      t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e$jscomp$0) {
    for (var r = 1; r < arguments.length; r++) {
      var t$jscomp$0 = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t$jscomp$0), !0).forEach(function(r$1) {
        var r, t = t$jscomp$0[r$1];
        a: {
          if ("object" == _typeof(r$1) && r$1) {
            var e = r$1[Symbol.toPrimitive];
            if (void 0 !== e) {
              r$1 = e.call(r$1, "string");
              if ("object" != _typeof(r$1)) {
                break a;
              }
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            r$1 = String(r$1);
          }
        }
        (r = "symbol" == _typeof(r$1) ? r$1 : r$1 + "") in e$jscomp$0 ? Object.defineProperty(e$jscomp$0, r, {value:t, enumerable:!0, configurable:!0, writable:!0}) : e$jscomp$0[r] = t;
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$jscomp$0, Object.getOwnPropertyDescriptors(t$jscomp$0)) : ownKeys(Object(t$jscomp$0)).forEach(function(r$1) {
        Object.defineProperty(e$jscomp$0, r$1, Object.getOwnPropertyDescriptor(t$jscomp$0, r$1));
      });
    }
    return e$jscomp$0;
  }
  function applySettingDefaults(options, defaults) {
    var _DEFAULT_GLOBAL_OPTIO, _globalOptions$header;
    const {db:dbOptions, auth:authOptions, realtime:realtimeOptions, global:globalOptions} = options, {db:DEFAULT_DB_OPTIONS$1, auth:DEFAULT_AUTH_OPTIONS$1, realtime:DEFAULT_REALTIME_OPTIONS$1, global:DEFAULT_GLOBAL_OPTIONS$1} = defaults;
    defaults = {db:_objectSpread2(_objectSpread2({}, DEFAULT_DB_OPTIONS$1), dbOptions), auth:_objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS$1), authOptions), realtime:_objectSpread2(_objectSpread2({}, DEFAULT_REALTIME_OPTIONS$1), realtimeOptions), storage:{}, global:_objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_GLOBAL_OPTIONS$1), globalOptions), {}, {headers:_objectSpread2(_objectSpread2({}, (_DEFAULT_GLOBAL_OPTIO = DEFAULT_GLOBAL_OPTIONS$1 === null || DEFAULT_GLOBAL_OPTIONS$1 === 
    void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS$1.headers) !== null && _DEFAULT_GLOBAL_OPTIO !== void 0 ? _DEFAULT_GLOBAL_OPTIO : {}), (_globalOptions$header = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _globalOptions$header !== void 0 ? _globalOptions$header : {})}), accessToken:async() => ""};
    options.accessToken ? defaults.accessToken = options.accessToken : delete defaults.accessToken;
    return defaults;
  }
  function validateSupabaseUrl(supabaseUrl) {
    supabaseUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();
    if (!supabaseUrl) {
      throw Error("supabaseUrl is required.");
    }
    if (!supabaseUrl.match(/^https?:\/\//i)) {
      throw Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
    }
    try {
      return new URL(supabaseUrl.endsWith("/") ? supabaseUrl : supabaseUrl + "/");
    } catch (_unused) {
      throw Error("Invalid supabaseUrl: Provided URL is malformed.");
    }
  }
  let __supabase_functions_js = require("module$node_modules$$supabase$functions_js$dist$main$index"), __supabase_postgrest_js = require("module$node_modules$$supabase$postgrest_js$dist$index_cjs"), __supabase_realtime_js = require("module$node_modules$$supabase$realtime_js$dist$main$index"), __supabase_storage_js = require("module$node_modules$$supabase$storage_js$dist$index_cjs"), __supabase_auth_js = require("module$node_modules$$supabase$auth_js$dist$main$index");
  require = "";
  require = typeof Deno !== "undefined" ? "deno" : typeof document !== "undefined" ? "web" : typeof navigator !== "undefined" && navigator.product === "ReactNative" ? "react-native" : "node";
  const DEFAULT_GLOBAL_OPTIONS = {headers:{"X-Client-Info":`supabase-js-${require}/${"2.97.0"}`}}, DEFAULT_DB_OPTIONS = {schema:"public"}, DEFAULT_AUTH_OPTIONS = {autoRefreshToken:!0, persistSession:!0, detectSessionInUrl:!0, flowType:"implicit"}, DEFAULT_REALTIME_OPTIONS = {}, resolveFetch = customFetch => customFetch ? (...args) => customFetch(...args) : (...args) => fetch(...args), fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
    const fetch$1 = resolveFetch(customFetch), HeadersConstructor = Headers;
    return async(input, init) => {
      var _await$getAccessToken;
      const accessToken = (_await$getAccessToken = await getAccessToken()) !== null && _await$getAccessToken !== void 0 ? _await$getAccessToken : supabaseKey;
      _await$getAccessToken = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
      _await$getAccessToken.has("apikey") || _await$getAccessToken.set("apikey", supabaseKey);
      _await$getAccessToken.has("Authorization") || _await$getAccessToken.set("Authorization", `Bearer ${accessToken}`);
      return fetch$1(input, _objectSpread2(_objectSpread2({}, init), {}, {headers:_await$getAccessToken}));
    };
  };
  var SupabaseAuthClient = class extends __supabase_auth_js.AuthClient {
    constructor(options) {
      super(options);
    }
  }, SupabaseClient = class {
    constructor(supabaseUrl, supabaseKey, options) {
      var _settings$auth$storag, _settings$global$head;
      this.supabaseUrl = supabaseUrl;
      this.supabaseKey = supabaseKey;
      supabaseUrl = validateSupabaseUrl(supabaseUrl);
      if (!supabaseKey) {
        throw Error("supabaseKey is required.");
      }
      this.realtimeUrl = new URL("realtime/v1", supabaseUrl);
      this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws");
      this.authUrl = new URL("auth/v1", supabaseUrl);
      this.storageUrl = new URL("storage/v1", supabaseUrl);
      this.functionsUrl = new URL("functions/v1", supabaseUrl);
      var defaultStorageKey = `sb-${supabaseUrl.hostname.split(".")[0]}-auth-token`;
      defaultStorageKey = {db:DEFAULT_DB_OPTIONS, realtime:DEFAULT_REALTIME_OPTIONS, auth:_objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS), {}, {storageKey:defaultStorageKey}), global:DEFAULT_GLOBAL_OPTIONS};
      defaultStorageKey = applySettingDefaults(options !== null && options !== void 0 ? options : {}, defaultStorageKey);
      this.storageKey = (_settings$auth$storag = defaultStorageKey.auth.storageKey) !== null && _settings$auth$storag !== void 0 ? _settings$auth$storag : "";
      this.headers = (_settings$global$head = defaultStorageKey.global.headers) !== null && _settings$global$head !== void 0 ? _settings$global$head : {};
      if (defaultStorageKey.accessToken) {
        this.accessToken = defaultStorageKey.accessToken, this.auth = new Proxy({}, {get:(_, prop) => {
          throw Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
        }});
      } else {
        var _settings$auth;
        this.auth = this._initSupabaseAuthClient((_settings$auth = defaultStorageKey.auth) !== null && _settings$auth !== void 0 ? _settings$auth : {}, this.headers, defaultStorageKey.global.fetch);
      }
      this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), defaultStorageKey.global.fetch);
      this.realtime = this._initRealtimeClient(_objectSpread2({headers:this.headers, accessToken:this._getAccessToken.bind(this)}, defaultStorageKey.realtime));
      this.accessToken && Promise.resolve(this.accessToken()).then(token => this.realtime.setAuth(token)).catch(e => console.warn("Failed to set initial Realtime auth token:", e));
      this.rest = new __supabase_postgrest_js.PostgrestClient((new URL("rest/v1", supabaseUrl)).href, {headers:this.headers, schema:defaultStorageKey.db.schema, fetch:this.fetch, timeout:defaultStorageKey.db.timeout, urlLengthLimit:defaultStorageKey.db.urlLengthLimit});
      this.storage = new __supabase_storage_js.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);
      defaultStorageKey.accessToken || this._listenForAuthEvents();
    }
    get functions() {
      return new __supabase_functions_js.FunctionsClient(this.functionsUrl.href, {headers:this.headers, customFetch:this.fetch});
    }
    from(relation) {
      return this.rest.from(relation);
    }
    schema(schema) {
      return this.rest.schema(schema);
    }
    rpc(fn, args = {}, options = {head:!1, get:!1, count:void 0}) {
      return this.rest.rpc(fn, args, options);
    }
    channel(name, opts = {config:{}}) {
      return this.realtime.channel(name, opts);
    }
    getChannels() {
      return this.realtime.getChannels();
    }
    removeChannel(channel) {
      return this.realtime.removeChannel(channel);
    }
    removeAllChannels() {
      return this.realtime.removeAllChannels();
    }
    async _getAccessToken() {
      var _data$session$access_, _data$session;
      if (this.accessToken) {
        return await this.accessToken();
      }
      const {data} = await this.auth.getSession();
      return (_data$session$access_ = (_data$session = data.session) === null || _data$session === void 0 ? void 0 : _data$session.access_token) !== null && _data$session$access_ !== void 0 ? _data$session$access_ : this.supabaseKey;
    }
    _initSupabaseAuthClient({autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError}, headers, fetch$1) {
      return new SupabaseAuthClient({url:this.authUrl.href, headers:_objectSpread2(_objectSpread2({}, {Authorization:`Bearer ${this.supabaseKey}`, apikey:`${this.supabaseKey}`}), headers), storageKey, autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, flowType, lock, debug, throwOnError, fetch:fetch$1, hasCustomAuthorizationHeader:Object.keys(this.headers).some(key => key.toLowerCase() === "authorization")});
    }
    _initRealtimeClient(options) {
      return new __supabase_realtime_js.RealtimeClient(this.realtimeUrl.href, _objectSpread2(_objectSpread2({}, options), {}, {params:_objectSpread2(_objectSpread2({}, {apikey:this.supabaseKey}), options === null || options === void 0 ? void 0 : options.params)}));
    }
    _listenForAuthEvents() {
      return this.auth.onAuthStateChange((event, session) => {
        this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
      });
    }
    _handleTokenChanged(event, source, token) {
      event !== "TOKEN_REFRESHED" && event !== "SIGNED_IN" || this.changedAccessToken === token ? event === "SIGNED_OUT" && (this.realtime.setAuth(), source == "STORAGE" && this.auth.signOut(), this.changedAccessToken = void 0) : (this.changedAccessToken = token, this.realtime.setAuth(token));
    }
  };
  (function() {
    if (typeof window !== "undefined") {
      return !1;
    }
    var _process = globalThis.process;
    if (!_process) {
      return !1;
    }
    _process = _process.version;
    return _process === void 0 || _process === null ? !1 : (_process = _process.match(/^v(\d+)\./)) ? parseInt(_process[1], 10) <= 18 : !1;
  })() && console.warn("⚠️  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
  Object.defineProperty(exports, "FunctionRegion", {enumerable:!0, get:function() {
    return __supabase_functions_js.FunctionRegion;
  }});
  Object.defineProperty(exports, "FunctionsError", {enumerable:!0, get:function() {
    return __supabase_functions_js.FunctionsError;
  }});
  Object.defineProperty(exports, "FunctionsFetchError", {enumerable:!0, get:function() {
    return __supabase_functions_js.FunctionsFetchError;
  }});
  Object.defineProperty(exports, "FunctionsHttpError", {enumerable:!0, get:function() {
    return __supabase_functions_js.FunctionsHttpError;
  }});
  Object.defineProperty(exports, "FunctionsRelayError", {enumerable:!0, get:function() {
    return __supabase_functions_js.FunctionsRelayError;
  }});
  Object.defineProperty(exports, "PostgrestError", {enumerable:!0, get:function() {
    return __supabase_postgrest_js.PostgrestError;
  }});
  exports.SupabaseClient = SupabaseClient;
  exports.createClient = (supabaseUrl, supabaseKey, options) => new SupabaseClient(supabaseUrl, supabaseKey, options);
  Object.keys(__supabase_auth_js).forEach(function(k) {
    k === "default" || Object.prototype.hasOwnProperty.call(exports, k) || Object.defineProperty(exports, k, {enumerable:!0, get:function() {
      return __supabase_auth_js[k];
    }});
  });
  Object.keys(__supabase_realtime_js).forEach(function(k) {
    k === "default" || Object.prototype.hasOwnProperty.call(exports, k) || Object.defineProperty(exports, k, {enumerable:!0, get:function() {
      return __supabase_realtime_js[k];
    }});
  });
};

//# sourceMappingURL=module$node_modules$$supabase$supabase_js$dist$index_cjs.js.map
