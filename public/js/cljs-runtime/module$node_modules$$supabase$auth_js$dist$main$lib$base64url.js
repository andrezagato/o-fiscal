shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$base64url = function(require, module, exports) {
  function byteToBase64URL(byte, state, emit) {
    if (byte !== null) {
      for (state.queue = state.queue << 8 | byte, state.queuedBits += 8; state.queuedBits >= 6;) {
        emit(TO_BASE64URL[state.queue >> state.queuedBits - 6 & 63]), state.queuedBits -= 6;
      }
    } else if (state.queuedBits > 0) {
      for (state.queue <<= 6 - state.queuedBits, state.queuedBits = 6; state.queuedBits >= 6;) {
        emit(TO_BASE64URL[state.queue >> state.queuedBits - 6 & 63]), state.queuedBits -= 6;
      }
    }
  }
  function byteFromBase64URL(charCode, state, emit) {
    const bits = FROM_BASE64URL[charCode];
    if (bits > -1) {
      for (state.queue = state.queue << 6 | bits, state.queuedBits += 6; state.queuedBits >= 8;) {
        emit(state.queue >> state.queuedBits - 8 & 255), state.queuedBits -= 8;
      }
    } else if (bits !== -2) {
      throw Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
    }
  }
  function codepointToUTF8(codepoint, emit) {
    if (codepoint <= 127) {
      emit(codepoint);
    } else if (codepoint <= 2047) {
      emit(192 | codepoint >> 6), emit(128 | codepoint & 63);
    } else {
      if (codepoint <= 65535) {
        emit(224 | codepoint >> 12), emit(128 | codepoint >> 6 & 63), emit(128 | codepoint & 63);
      } else {
        if (codepoint <= 1114111) {
          emit(240 | codepoint >> 18), emit(128 | codepoint >> 12 & 63), emit(128 | codepoint >> 6 & 63), emit(128 | codepoint & 63);
        } else {
          throw Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
        }
      }
    }
  }
  function stringToUTF8(str, emit) {
    for (let i = 0; i < str.length; i += 1) {
      var codepoint = str.charCodeAt(i);
      codepoint > 55295 && codepoint <= 56319 && (codepoint = (codepoint - 55296) * 1024 & 65535, codepoint = (str.charCodeAt(i + 1) - 56320 & 65535 | codepoint) + 65536, i += 1);
      codepointToUTF8(codepoint, emit);
    }
  }
  function stringFromUTF8(byte, state, emit) {
    if (state.utf8seq === 0) {
      if (byte <= 127) {
        emit(byte);
      } else {
        for (emit = 1; emit < 6; emit += 1) {
          if ((byte >> 7 - emit & 1) === 0) {
            state.utf8seq = emit;
            break;
          }
        }
        if (state.utf8seq === 2) {
          state.codepoint = byte & 31;
        } else if (state.utf8seq === 3) {
          state.codepoint = byte & 15;
        } else if (state.utf8seq === 4) {
          state.codepoint = byte & 7;
        } else {
          throw Error("Invalid UTF-8 sequence");
        }
        --state.utf8seq;
      }
    } else if (state.utf8seq > 0) {
      if (byte <= 127) {
        throw Error("Invalid UTF-8 sequence");
      }
      state.codepoint = state.codepoint << 6 | byte & 63;
      --state.utf8seq;
      state.utf8seq === 0 && emit(state.codepoint);
    }
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.byteToBase64URL = byteToBase64URL;
  exports.byteFromBase64URL = byteFromBase64URL;
  exports.stringToBase64URL = function(str) {
    const base64 = [], emitter = char => {
      base64.push(char);
    }, state = {queue:0, queuedBits:0};
    stringToUTF8(str, byte => {
      byteToBase64URL(byte, state, emitter);
    });
    byteToBase64URL(null, state, emitter);
    return base64.join("");
  };
  exports.stringFromBase64URL = function(str) {
    const conv = [], utf8Emit = codepoint => {
      conv.push(String.fromCodePoint(codepoint));
    }, utf8State = {utf8seq:0, codepoint:0}, b64State = {queue:0, queuedBits:0}, byteEmit = byte => {
      stringFromUTF8(byte, utf8State, utf8Emit);
    };
    for (let i = 0; i < str.length; i += 1) {
      byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);
    }
    return conv.join("");
  };
  exports.codepointToUTF8 = codepointToUTF8;
  exports.stringToUTF8 = stringToUTF8;
  exports.stringFromUTF8 = stringFromUTF8;
  exports.base64UrlToUint8Array = function(str) {
    const result = [], state = {queue:0, queuedBits:0}, onByte = byte => {
      result.push(byte);
    };
    for (let i = 0; i < str.length; i += 1) {
      byteFromBase64URL(str.charCodeAt(i), state, onByte);
    }
    return new Uint8Array(result);
  };
  exports.stringToUint8Array = function(str) {
    const result = [];
    stringToUTF8(str, byte => result.push(byte));
    return new Uint8Array(result);
  };
  exports.bytesToBase64URL = function(bytes) {
    const result = [], state = {queue:0, queuedBits:0}, onChar = char => {
      result.push(char);
    };
    bytes.forEach(byte => byteToBase64URL(byte, state, onChar));
    byteToBase64URL(null, state, onChar);
    return result.join("");
  };
  const TO_BASE64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""), IGNORE_BASE64URL = [" ", "\t", "\n", "\r", "\x3d"], FROM_BASE64URL = (() => {
    const charMap = Array(128);
    for (var i = 0; i < charMap.length; i += 1) {
      charMap[i] = -1;
    }
    for (i = 0; i < IGNORE_BASE64URL.length; i += 1) {
      charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;
    }
    for (i = 0; i < TO_BASE64URL.length; i += 1) {
      charMap[TO_BASE64URL[i].charCodeAt(0)] = i;
    }
    return charMap;
  })();
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$lib$base64url.js.map
