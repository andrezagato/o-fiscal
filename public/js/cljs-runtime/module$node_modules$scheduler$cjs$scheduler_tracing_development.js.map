{
"version":3,
"file":"module$node_modules$scheduler$cjs$scheduler_tracing_development.js",
"lineCount":200,
"mappings":"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",
"sources":["node_modules/scheduler/cjs/scheduler-tracing.development.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$scheduler$cjs$scheduler_tracing_development\"] = function(require,module,exports) {\n/** @license React v0.20.2\r\n * scheduler-tracing.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n'use strict';\r\n\r\nvar DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.\r\n\r\nvar interactionIDCounter = 0;\r\nvar threadIDCounter = 0; // Set of currently traced interactions.\r\n// Interactions \"stack\"\u2013\r\n// Meaning that newly traced interactions are appended to the previously active set.\r\n// When an interaction goes out of scope, the previous set (if any) is restored.\r\n\r\nexports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.\r\n\r\nexports.__subscriberRef = null;\r\n\r\n{\r\n  exports.__interactionsRef = {\r\n    current: new Set()\r\n  };\r\n  exports.__subscriberRef = {\r\n    current: null\r\n  };\r\n}\r\nfunction unstable_clear(callback) {\r\n\r\n  var prevInteractions = exports.__interactionsRef.current;\r\n  exports.__interactionsRef.current = new Set();\r\n\r\n  try {\r\n    return callback();\r\n  } finally {\r\n    exports.__interactionsRef.current = prevInteractions;\r\n  }\r\n}\r\nfunction unstable_getCurrent() {\r\n  {\r\n    return exports.__interactionsRef.current;\r\n  }\r\n}\r\nfunction unstable_getThreadID() {\r\n  return ++threadIDCounter;\r\n}\r\nfunction unstable_trace(name, timestamp, callback) {\r\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\r\n\r\n  var interaction = {\r\n    __count: 1,\r\n    id: interactionIDCounter++,\r\n    name: name,\r\n    timestamp: timestamp\r\n  };\r\n  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.\r\n  // To do that, clone the current interactions.\r\n  // The previous set will be restored upon completion.\r\n\r\n  var interactions = new Set(prevInteractions);\r\n  interactions.add(interaction);\r\n  exports.__interactionsRef.current = interactions;\r\n  var subscriber = exports.__subscriberRef.current;\r\n  var returnValue;\r\n\r\n  try {\r\n    if (subscriber !== null) {\r\n      subscriber.onInteractionTraced(interaction);\r\n    }\r\n  } finally {\r\n    try {\r\n      if (subscriber !== null) {\r\n        subscriber.onWorkStarted(interactions, threadID);\r\n      }\r\n    } finally {\r\n      try {\r\n        returnValue = callback();\r\n      } finally {\r\n        exports.__interactionsRef.current = prevInteractions;\r\n\r\n        try {\r\n          if (subscriber !== null) {\r\n            subscriber.onWorkStopped(interactions, threadID);\r\n          }\r\n        } finally {\r\n          interaction.__count--; // If no async work was scheduled for this interaction,\r\n          // Notify subscribers that it's completed.\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return returnValue;\r\n}\r\nfunction unstable_wrap(callback) {\r\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\r\n\r\n  var wrappedInteractions = exports.__interactionsRef.current;\r\n  var subscriber = exports.__subscriberRef.current;\r\n\r\n  if (subscriber !== null) {\r\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\r\n  } // Update the pending async work count for the current interactions.\r\n  // Update after calling subscribers in case of error.\r\n\r\n\r\n  wrappedInteractions.forEach(function (interaction) {\r\n    interaction.__count++;\r\n  });\r\n  var hasRun = false;\r\n\r\n  function wrapped() {\r\n    var prevInteractions = exports.__interactionsRef.current;\r\n    exports.__interactionsRef.current = wrappedInteractions;\r\n    subscriber = exports.__subscriberRef.current;\r\n\r\n    try {\r\n      var returnValue;\r\n\r\n      try {\r\n        if (subscriber !== null) {\r\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\r\n        }\r\n      } finally {\r\n        try {\r\n          returnValue = callback.apply(undefined, arguments);\r\n        } finally {\r\n          exports.__interactionsRef.current = prevInteractions;\r\n\r\n          if (subscriber !== null) {\r\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\r\n          }\r\n        }\r\n      }\r\n\r\n      return returnValue;\r\n    } finally {\r\n      if (!hasRun) {\r\n        // We only expect a wrapped function to be executed once,\r\n        // But in the event that it's executed more than once\u2013\r\n        // Only decrement the outstanding interaction counts once.\r\n        hasRun = true; // Update pending async counts for all wrapped interactions.\r\n        // If this was the last scheduled async work for any of them,\r\n        // Mark them as completed.\r\n\r\n        wrappedInteractions.forEach(function (interaction) {\r\n          interaction.__count--;\r\n\r\n          if (subscriber !== null && interaction.__count === 0) {\r\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  wrapped.cancel = function cancel() {\r\n    subscriber = exports.__subscriberRef.current;\r\n\r\n    try {\r\n      if (subscriber !== null) {\r\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\r\n      }\r\n    } finally {\r\n      // Update pending async counts for all wrapped interactions.\r\n      // If this was the last scheduled async work for any of them,\r\n      // Mark them as completed.\r\n      wrappedInteractions.forEach(function (interaction) {\r\n        interaction.__count--;\r\n\r\n        if (subscriber && interaction.__count === 0) {\r\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  return wrapped;\r\n}\r\n\r\nvar subscribers = null;\r\n\r\n{\r\n  subscribers = new Set();\r\n}\r\n\r\nfunction unstable_subscribe(subscriber) {\r\n  {\r\n    subscribers.add(subscriber);\r\n\r\n    if (subscribers.size === 1) {\r\n      exports.__subscriberRef.current = {\r\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\r\n        onInteractionTraced: onInteractionTraced,\r\n        onWorkCanceled: onWorkCanceled,\r\n        onWorkScheduled: onWorkScheduled,\r\n        onWorkStarted: onWorkStarted,\r\n        onWorkStopped: onWorkStopped\r\n      };\r\n    }\r\n  }\r\n}\r\nfunction unstable_unsubscribe(subscriber) {\r\n  {\r\n    subscribers.delete(subscriber);\r\n\r\n    if (subscribers.size === 0) {\r\n      exports.__subscriberRef.current = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction onInteractionTraced(interaction) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onInteractionTraced(interaction);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onInteractionScheduledWorkCompleted(interaction) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkScheduled(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkScheduled(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkStarted(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkStarted(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkStopped(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkStopped(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nfunction onWorkCanceled(interactions, threadID) {\r\n  var didCatchError = false;\r\n  var caughtError = null;\r\n  subscribers.forEach(function (subscriber) {\r\n    try {\r\n      subscriber.onWorkCanceled(interactions, threadID);\r\n    } catch (error) {\r\n      if (!didCatchError) {\r\n        didCatchError = true;\r\n        caughtError = error;\r\n      }\r\n    }\r\n  });\r\n\r\n  if (didCatchError) {\r\n    throw caughtError;\r\n  }\r\n}\r\n\r\nexports.unstable_clear = unstable_clear;\r\nexports.unstable_getCurrent = unstable_getCurrent;\r\nexports.unstable_getThreadID = unstable_getThreadID;\r\nexports.unstable_subscribe = unstable_subscribe;\r\nexports.unstable_trace = unstable_trace;\r\nexports.unstable_unsubscribe = unstable_unsubscribe;\r\nexports.unstable_wrap = unstable_wrap;\r\n  })();\r\n}\r\n\n};"],
"names":["shadow$provide","require","module","exports","onInteractionTraced","interaction","didCatchError","caughtError","subscribers","forEach","subscriber","error","onInteractionScheduledWorkCompleted","onWorkScheduled","interactions","threadID","onWorkStarted","onWorkStopped","onWorkCanceled","interactionIDCounter","threadIDCounter","__interactionsRef","__subscriberRef","current","Set","unstable_clear","callback","prevInteractions","unstable_getCurrent","unstable_getThreadID","unstable_subscribe","add","size","unstable_trace","name","timestamp","arguments","length","undefined","DEFAULT_THREAD_ID","__count","id","returnValue","unstable_unsubscribe","delete","unstable_wrap","wrapped","wrappedInteractions","apply","hasRun","cancel","wrapped.cancel"]
}
