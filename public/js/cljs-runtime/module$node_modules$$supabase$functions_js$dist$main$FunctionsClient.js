shadow$provide.module$node_modules$$supabase$functions_js$dist$main$FunctionsClient = function(require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.FunctionsClient = void 0;
  const tslib_1 = require("module$node_modules$tslib$tslib"), helper_1 = require("module$node_modules$$supabase$functions_js$dist$main$helper"), types_1 = require("module$node_modules$$supabase$functions_js$dist$main$types");
  class FunctionsClient {
    constructor(url, {headers = {}, customFetch, region = types_1.FunctionRegion.Any} = {}) {
      this.url = url;
      this.headers = headers;
      this.region = region;
      this.fetch = (0,helper_1.resolveFetch)(customFetch);
    }
    setAuth(token) {
      this.headers.Authorization = `Bearer ${token}`;
    }
    invoke(functionName_1) {
      return tslib_1.__awaiter(this, arguments, void 0, function*(functionName, options = {}) {
        var _a;
        let timeoutId, timeoutController;
        try {
          const {headers, method, body:functionArgs, signal, timeout} = options;
          let _headers = {};
          ({region:options} = options);
          options || (options = this.region);
          const url = new URL(`${this.url}/${functionName}`);
          options && options !== "any" && (_headers["x-region"] = options, url.searchParams.set("forceFunctionRegion", options));
          let body;
          functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers) ? typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer ? (_headers["Content-Type"] = "application/octet-stream", body = functionArgs) : typeof functionArgs === "string" ? (_headers["Content-Type"] = "text/plain", body = functionArgs) : typeof FormData !== "undefined" && functionArgs instanceof FormData ? body = functionArgs : (_headers["Content-Type"] = 
          "application/json", body = JSON.stringify(functionArgs)) : body = !functionArgs || typeof functionArgs === "string" || typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer || typeof FormData !== "undefined" && functionArgs instanceof FormData ? functionArgs : JSON.stringify(functionArgs);
          functionName = signal;
          timeout && (timeoutController = new AbortController(), timeoutId = setTimeout(() => timeoutController.abort(), timeout), signal ? (functionName = timeoutController.signal, signal.addEventListener("abort", () => timeoutController.abort())) : functionName = timeoutController.signal);
          const response = yield this.fetch(url.toString(), {method:method || "POST", headers:Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers), body, signal:functionName}).catch(fetchError => {
            throw new types_1.FunctionsFetchError(fetchError);
          }), isRelayError = response.headers.get("x-relay-error");
          if (isRelayError && isRelayError === "true") {
            throw new types_1.FunctionsRelayError(response);
          }
          if (!response.ok) {
            throw new types_1.FunctionsHttpError(response);
          }
          let responseType = ((_a = response.headers.get("Content-Type")) !== null && _a !== void 0 ? _a : "text/plain").split(";")[0].trim();
          return {data:responseType === "application/json" ? yield response.json() : responseType === "application/octet-stream" || responseType === "application/pdf" ? yield response.blob() : responseType === "text/event-stream" ? response : responseType === "multipart/form-data" ? yield response.formData() : yield response.text(), error:null, response};
        } catch (error) {
          return {data:null, error, response:error instanceof types_1.FunctionsHttpError || error instanceof types_1.FunctionsRelayError ? error.context : void 0};
        } finally {
          timeoutId && clearTimeout(timeoutId);
        }
      });
    }
  }
  exports.FunctionsClient = FunctionsClient;
};

//# sourceMappingURL=module$node_modules$$supabase$functions_js$dist$main$FunctionsClient.js.map
