shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$helpers = function(require, module, exports) {
  function dec2hex(dec) {
    return ("0" + dec.toString(16)).substr(-2);
  }
  function generatePKCEVerifier() {
    var array = new Uint32Array(56);
    if (typeof crypto === "undefined") {
      array = "";
      for (let i = 0; i < 56; i++) {
        array += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~".charAt(Math.floor(Math.random() * 66));
      }
      return array;
    }
    crypto.getRandomValues(array);
    return Array.from(array, dec2hex).join("");
  }
  async function sha256(randomString) {
    randomString = (new TextEncoder()).encode(randomString);
    randomString = await crypto.subtle.digest("SHA-256", randomString);
    randomString = new Uint8Array(randomString);
    return Array.from(randomString).map(c => String.fromCharCode(c)).join("");
  }
  async function generatePKCEChallenge(verifier) {
    if (typeof crypto === "undefined" || typeof crypto.subtle === "undefined" || typeof TextEncoder === "undefined") {
      return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), verifier;
    }
    verifier = await sha256(verifier);
    return btoa(verifier).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.Deferred = exports.removeItemAsync = exports.getItemAsync = exports.setItemAsync = exports.looksLikeFetchResponse = exports.resolveFetch = exports.supportsLocalStorage = exports.isBrowser = void 0;
  exports.expiresAt = function(expiresIn) {
    return Math.round(Date.now() / 1000) + expiresIn;
  };
  exports.generateCallbackId = function() {
    return Symbol("auth-callback");
  };
  exports.parseParametersFromURL = function(href) {
    const result = {};
    href = new URL(href);
    if (href.hash && href.hash[0] === "#") {
      try {
        (new URLSearchParams(href.hash.substring(1))).forEach((value, key) => {
          result[key] = value;
        });
      } catch (e) {
      }
    }
    href.searchParams.forEach((value, key) => {
      result[key] = value;
    });
    return result;
  };
  exports.decodeJWT = function(token) {
    token = token.split(".");
    if (token.length !== 3) {
      throw new errors_1.AuthInvalidJwtError("Invalid JWT structure");
    }
    for (let i = 0; i < token.length; i++) {
      if (!constants_1.BASE64URL_REGEX.test(token[i])) {
        throw new errors_1.AuthInvalidJwtError("JWT not in base64url format");
      }
    }
    return {header:JSON.parse((0,base64url_1.stringFromBase64URL)(token[0])), payload:JSON.parse((0,base64url_1.stringFromBase64URL)(token[1])), signature:(0,base64url_1.base64UrlToUint8Array)(token[2]), raw:{header:token[0], payload:token[1]}};
  };
  exports.sleep = async function(time) {
    return await new Promise(accept => {
      setTimeout(() => accept(null), time);
    });
  };
  exports.retryable = function(fn, isRetryable) {
    return new Promise((accept, reject) => {
      (async() => {
        for (let attempt = 0; attempt < Infinity; attempt++) {
          try {
            const result = await fn(attempt);
            if (!isRetryable(attempt, null, result)) {
              accept(result);
              break;
            }
          } catch (e) {
            if (!isRetryable(attempt, e)) {
              reject(e);
              break;
            }
          }
        }
      })();
    });
  };
  exports.generatePKCEVerifier = generatePKCEVerifier;
  exports.generatePKCEChallenge = generatePKCEChallenge;
  exports.getCodeChallengeAndMethod = async function(storage, storageKey, isPasswordRecovery = !1) {
    const codeVerifier = generatePKCEVerifier();
    let storedCodeVerifier = codeVerifier;
    isPasswordRecovery && (storedCodeVerifier += "/PASSWORD_RECOVERY");
    await (0,exports.setItemAsync)(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
    storage = await generatePKCEChallenge(codeVerifier);
    return [storage, codeVerifier === storage ? "plain" : "s256"];
  };
  exports.parseResponseAPIVersion = function(response) {
    response = response.headers.get(constants_1.API_VERSION_HEADER_NAME);
    if (!response || !response.match(API_VERSION_REGEX)) {
      return null;
    }
    try {
      return new Date(`${response}T00:00:00.0Z`);
    } catch (e) {
      return null;
    }
  };
  exports.validateExp = function(exp) {
    if (!exp) {
      throw Error("Missing exp claim");
    }
    const timeNow = Math.floor(Date.now() / 1000);
    if (exp <= timeNow) {
      throw Error("JWT has expired");
    }
  };
  exports.getAlgorithm = function(alg) {
    switch(alg) {
      case "RS256":
        return {name:"RSASSA-PKCS1-v1_5", hash:{name:"SHA-256"}};
      case "ES256":
        return {name:"ECDSA", namedCurve:"P-256", hash:{name:"SHA-256"}};
      default:
        throw Error("Invalid alg claim");
    }
  };
  exports.validateUUID = function(str) {
    if (!UUID_REGEX.test(str)) {
      throw Error("@supabase/auth-js: Expected parameter to be UUID but is not");
    }
  };
  exports.userNotAvailableProxy = function() {
    return new Proxy({}, {get:(target, prop) => {
      if (prop === "__isUserNotAvailableProxy") {
        return !0;
      }
      if (typeof prop === "symbol" && (target = prop.toString(), target === "Symbol(Symbol.toPrimitive)" || target === "Symbol(Symbol.toStringTag)" || target === "Symbol(util.inspect.custom)")) {
        return;
      }
      throw Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${prop}" property of the session object is not supported. Please use getUser() instead.`);
    }, set:(_target, prop) => {
      throw Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    }, deleteProperty:(_target, prop) => {
      throw Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    }});
  };
  exports.insecureUserWarningProxy = function(user, suppressWarningRef) {
    return new Proxy(user, {get:(target, prop, receiver) => {
      if (prop === "__isInsecureUserWarningProxy") {
        return !0;
      }
      if (typeof prop === "symbol") {
        const sProp = prop.toString();
        if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)" || sProp === "Symbol(nodejs.util.inspect.custom)") {
          return Reflect.get(target, prop, receiver);
        }
      }
      suppressWarningRef.value || typeof prop !== "string" || (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."), suppressWarningRef.value = !0);
      return Reflect.get(target, prop, receiver);
    }});
  };
  exports.deepClone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
  };
  const constants_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$constants"), errors_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$errors"), base64url_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$base64url");
  exports.isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
  var JSCompiler_object_inline_tested_1335 = !1, JSCompiler_object_inline_writable_1336 = !1;
  exports.supportsLocalStorage = () => {
    if (!(0,exports.isBrowser)()) {
      return !1;
    }
    try {
      if (typeof globalThis.localStorage !== "object") {
        return !1;
      }
    } catch (e) {
      return !1;
    }
    if (JSCompiler_object_inline_tested_1335) {
      return JSCompiler_object_inline_writable_1336;
    }
    const randomKey = `lswt-${Math.random()}${Math.random()}`;
    try {
      globalThis.localStorage.setItem(randomKey, randomKey), globalThis.localStorage.removeItem(randomKey), JSCompiler_object_inline_writable_1336 = JSCompiler_object_inline_tested_1335 = !0;
    } catch (e) {
      JSCompiler_object_inline_tested_1335 = !0, JSCompiler_object_inline_writable_1336 = !1;
    }
    return JSCompiler_object_inline_writable_1336;
  };
  exports.resolveFetch = customFetch => customFetch ? (...args) => customFetch(...args) : (...args) => fetch(...args);
  exports.looksLikeFetchResponse = maybeResponse => typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
  exports.setItemAsync = async(storage, key, data) => {
    await storage.setItem(key, JSON.stringify(data));
  };
  exports.getItemAsync = async(storage, key) => {
    storage = await storage.getItem(key);
    if (!storage) {
      return null;
    }
    try {
      return JSON.parse(storage);
    } catch (_a) {
      return storage;
    }
  };
  exports.removeItemAsync = async(storage, key) => {
    await storage.removeItem(key);
  };
  class Deferred {
    constructor() {
      this.promise = new Deferred.promiseConstructor((res, rej) => {
        this.resolve = res;
        this.reject = rej;
      });
    }
  }
  exports.Deferred = Deferred;
  Deferred.promiseConstructor = Promise;
  const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i, UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$lib$helpers.js.map
