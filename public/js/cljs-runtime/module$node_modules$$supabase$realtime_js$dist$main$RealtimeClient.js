shadow$provide.module$node_modules$$supabase$realtime_js$dist$main$RealtimeClient = function(require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  module = require("module$node_modules$tslib$tslib");
  const websocket_factory_1 = module.__importDefault(require("module$node_modules$$supabase$realtime_js$dist$main$lib$websocket_factory")), constants_1 = require("module$node_modules$$supabase$realtime_js$dist$main$lib$constants"), serializer_1 = module.__importDefault(require("module$node_modules$$supabase$realtime_js$dist$main$lib$serializer")), timer_1 = module.__importDefault(require("module$node_modules$$supabase$realtime_js$dist$main$lib$timer")), transformers_1 = require("module$node_modules$$supabase$realtime_js$dist$main$lib$transformers"), 
  RealtimeChannel_1 = module.__importDefault(require("module$node_modules$$supabase$realtime_js$dist$main$RealtimeChannel")), noop = () => {
  }, RECONNECT_INTERVALS = [1000, 2000, 5000, 10000];
  class RealtimeClient {
    constructor(endPoint, options) {
      var _a;
      this.apiKey = this.accessTokenValue = null;
      this._manuallySetToken = !1;
      this.channels = [];
      this.httpEndpoint = this.endPoint = "";
      this.headers = {};
      this.params = {};
      this.timeout = constants_1.DEFAULT_TIMEOUT;
      this.transport = null;
      this.heartbeatIntervalMs = 25000;
      this.heartbeatTimer = void 0;
      this.pendingHeartbeatRef = null;
      this.heartbeatCallback = noop;
      this.ref = 0;
      this.reconnectTimer = null;
      this.vsn = constants_1.DEFAULT_VSN;
      this.logger = noop;
      this.conn = null;
      this.sendBuffer = [];
      this.serializer = new serializer_1.default();
      this.stateChangeCallbacks = {open:[], close:[], error:[], message:[]};
      this.accessToken = null;
      this._connectionState = "disconnected";
      this._wasManualDisconnect = !1;
      this._heartbeatSentAt = this._authPromise = null;
      this._resolveFetch = customFetch => customFetch ? (...args) => customFetch(...args) : (...args) => fetch(...args);
      if ((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 || !_a.apikey) {
        throw Error("API key is required to connect to Realtime");
      }
      this.apiKey = options.params.apikey;
      this.endPoint = `${endPoint}/${constants_1.TRANSPORTS.websocket}`;
      this.httpEndpoint = (0,transformers_1.httpEndpointURL)(endPoint);
      this._initializeOptions(options);
      this._setupReconnectionTimer();
      this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
    }
    connect() {
      if (!(this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected())) {
        this._setConnectionState("connecting");
        this.accessToken && !this._authPromise && this._setAuthSafely("connect");
        if (this.transport) {
          this.conn = new this.transport(this.endpointURL());
        } else {
          try {
            this.conn = websocket_factory_1.default.createWebSocket(this.endpointURL());
          } catch (error) {
            this._setConnectionState("disconnected");
            const errorMessage = error.message;
            if (errorMessage.includes("Node.js")) {
              throw Error(`${errorMessage}\n\n` + 'To use Realtime in Node.js, you need to provide a WebSocket implementation:\n\nOption 1: Use Node.js 22+ which has native WebSocket support\nOption 2: Install and provide the "ws" package:\n\n  npm install ws\n\n  import ws from "ws"\n  const client \x3d new RealtimeClient(url, {\n    ...options,\n    transport: ws\n  })');
            }
            throw Error(`WebSocket not available: ${errorMessage}`);
          }
        }
        this._setupConnectionHandlers();
      }
    }
    endpointURL() {
      return this._appendParams(this.endPoint, Object.assign({}, this.params, {vsn:this.vsn}));
    }
    disconnect(code, reason) {
      if (!this.isDisconnecting()) {
        if (this._setConnectionState("disconnecting", !0), this.conn) {
          const fallbackTimer = setTimeout(() => {
            this._setConnectionState("disconnected");
          }, 100);
          this.conn.onclose = () => {
            clearTimeout(fallbackTimer);
            this._setConnectionState("disconnected");
          };
          typeof this.conn.close === "function" && (code ? this.conn.close(code, reason !== null && reason !== void 0 ? reason : "") : this.conn.close());
          this._teardownConnection();
        } else {
          this._setConnectionState("disconnected");
        }
      }
    }
    getChannels() {
      return this.channels;
    }
    async removeChannel(channel) {
      channel = await channel.unsubscribe();
      this.channels.length === 0 && this.disconnect();
      return channel;
    }
    async removeAllChannels() {
      const values_1 = await Promise.all(this.channels.map(channel => channel.unsubscribe()));
      this.channels = [];
      this.disconnect();
      return values_1;
    }
    log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    connectionState() {
      switch(this.conn && this.conn.readyState) {
        case constants_1.SOCKET_STATES.connecting:
          return constants_1.CONNECTION_STATE.Connecting;
        case constants_1.SOCKET_STATES.open:
          return constants_1.CONNECTION_STATE.Open;
        case constants_1.SOCKET_STATES.closing:
          return constants_1.CONNECTION_STATE.Closing;
        default:
          return constants_1.CONNECTION_STATE.Closed;
      }
    }
    isConnected() {
      return this.connectionState() === constants_1.CONNECTION_STATE.Open;
    }
    isConnecting() {
      return this._connectionState === "connecting";
    }
    isDisconnecting() {
      return this._connectionState === "disconnecting";
    }
    channel(topic, params = {config:{}}) {
      const realtimeTopic = `realtime:${topic}`, exists = this.getChannels().find(c => c.topic === realtimeTopic);
      if (exists) {
        return exists;
      }
      topic = new RealtimeChannel_1.default(`realtime:${topic}`, params, this);
      this.channels.push(topic);
      return topic;
    }
    push(data) {
      const {topic, event, payload, ref} = data, callback = () => {
        this.encode(data, result => {
          var _a;
          (_a = this.conn) === null || _a === void 0 || _a.send(result);
        });
      };
      this.log("push", `${topic} ${event} (${ref})`, payload);
      this.isConnected() ? callback() : this.sendBuffer.push(callback);
    }
    async setAuth(token = null) {
      this._authPromise = this._performAuth(token);
      try {
        await this._authPromise;
      } finally {
        this._authPromise = null;
      }
    }
    _isManualToken() {
      return this._manuallySetToken;
    }
    async sendHeartbeat() {
      var _a;
      if (this.isConnected()) {
        if (this.pendingHeartbeatRef) {
          this._heartbeatSentAt = this.pendingHeartbeatRef = null;
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
          try {
            this.heartbeatCallback("timeout");
          } catch (e) {
            this.log("error", "error in heartbeat callback", e);
          }
          this._wasManualDisconnect = !1;
          (_a = this.conn) === null || _a === void 0 || _a.close(constants_1.WS_CLOSE_NORMAL, "heartbeat timeout");
          setTimeout(() => {
            var _a;
            this.isConnected() || (_a = this.reconnectTimer) === null || _a === void 0 || _a.scheduleTimeout();
          }, 100);
        } else {
          this._heartbeatSentAt = Date.now();
          this.pendingHeartbeatRef = this._makeRef();
          this.push({topic:"phoenix", event:"heartbeat", payload:{}, ref:this.pendingHeartbeatRef});
          try {
            this.heartbeatCallback("sent");
          } catch (e) {
            this.log("error", "error in heartbeat callback", e);
          }
          this._setAuthSafely("heartbeat");
        }
      } else {
        try {
          this.heartbeatCallback("disconnected");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
      }
    }
    onHeartbeat(callback) {
      this.heartbeatCallback = callback;
    }
    flushSendBuffer() {
      this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(callback => callback()), this.sendBuffer = []);
    }
    _makeRef() {
      let newRef = this.ref + 1;
      this.ref = newRef === this.ref ? 0 : newRef;
      return this.ref.toString();
    }
    _leaveOpenTopic(topic) {
      let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));
      dupChannel && (this.log("transport", `leaving duplicate topic "${topic}"`), dupChannel.unsubscribe());
    }
    _remove(channel) {
      this.channels = this.channels.filter(c => c.topic !== channel.topic);
    }
    _onConnMessage(rawMessage) {
      this.decode(rawMessage.data, msg => {
        if (msg.topic === "phoenix" && msg.event === "phx_reply" && msg.ref && msg.ref === this.pendingHeartbeatRef) {
          const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : void 0;
          try {
            this.heartbeatCallback(msg.payload.status === "ok" ? "ok" : "error", latency);
          } catch (e) {
            this.log("error", "error in heartbeat callback", e);
          }
          this.pendingHeartbeatRef = this._heartbeatSentAt = null;
        }
        const {topic, event, payload, ref} = msg;
        this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref ? `(${ref})` : ""}`.trim(), payload);
        this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));
        this._triggerStateCallbacks("message", msg);
      });
    }
    _clearTimer(timer) {
      var _a;
      timer === "heartbeat" && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer), this.heartbeatTimer = void 0) : timer === "reconnect" && ((_a = this.reconnectTimer) === null || _a === void 0 || _a.reset());
    }
    _clearAllTimers() {
      this._clearTimer("heartbeat");
      this._clearTimer("reconnect");
    }
    _setupConnectionHandlers() {
      this.conn && ("binaryType" in this.conn && (this.conn.binaryType = "arraybuffer"), this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = error => this._onConnError(error), this.conn.onmessage = event => this._onConnMessage(event), this.conn.onclose = event => this._onConnClose(event), this.conn.readyState === constants_1.SOCKET_STATES.open && this._onConnOpen());
    }
    _teardownConnection() {
      if (this.conn) {
        if (this.conn.readyState === constants_1.SOCKET_STATES.open || this.conn.readyState === constants_1.SOCKET_STATES.connecting) {
          try {
            this.conn.close();
          } catch (e) {
            this.log("error", "Error closing connection", e);
          }
        }
        this.conn.onopen = null;
        this.conn.onerror = null;
        this.conn.onmessage = null;
        this.conn = this.conn.onclose = null;
      }
      this._clearAllTimers();
      this._terminateWorker();
      this.channels.forEach(channel => channel.teardown());
    }
    _onConnOpen() {
      this._setConnectionState("connected");
      this.log("transport", `connected to ${this.endpointURL()}`);
      (this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve())).then(() => {
        this.flushSendBuffer();
      }).catch(e => {
        this.log("error", "error waiting for auth on connect", e);
        this.flushSendBuffer();
      });
      this._clearTimer("reconnect");
      this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat();
      this._triggerStateCallbacks("open");
    }
    _startHeartbeat() {
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    _startWorkerHeartbeat() {
      this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
      const objectUrl = this._workerObjectUrl(this.workerUrl);
      this.workerRef = new Worker(objectUrl);
      this.workerRef.onerror = error => {
        this.log("worker", "worker error", error.message);
        this._terminateWorker();
      };
      this.workerRef.onmessage = event => {
        event.data.event === "keepAlive" && this.sendHeartbeat();
      };
      this.workerRef.postMessage({event:"start", interval:this.heartbeatIntervalMs});
    }
    _terminateWorker() {
      this.workerRef && (this.log("worker", "terminating worker"), this.workerRef.terminate(), this.workerRef = void 0);
    }
    _onConnClose(event) {
      var _a;
      this._setConnectionState("disconnected");
      this.log("transport", "close", event);
      this._triggerChanError();
      this._clearTimer("heartbeat");
      this._wasManualDisconnect || (_a = this.reconnectTimer) === null || _a === void 0 || _a.scheduleTimeout();
      this._triggerStateCallbacks("close", event);
    }
    _onConnError(error) {
      this._setConnectionState("disconnected");
      this.log("transport", `${error}`);
      this._triggerChanError();
      this._triggerStateCallbacks("error", error);
      try {
        this.heartbeatCallback("error");
      } catch (e) {
        this.log("error", "error in heartbeat callback", e);
      }
    }
    _triggerChanError() {
      this.channels.forEach(channel => channel._trigger(constants_1.CHANNEL_EVENTS.error));
    }
    _appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      const prefix = url.match(/\?/) ? "\x26" : "?";
      params = new URLSearchParams(params);
      return `${url}${prefix}${params}`;
    }
    _workerObjectUrl(url) {
      url || (url = new Blob(['\n  addEventListener("message", (e) \x3d\x3e {\n    if (e.data.event \x3d\x3d\x3d "start") {\n      setInterval(() \x3d\x3e postMessage({ event: "keepAlive" }), e.data.interval);\n    }\n  });'], {type:"application/javascript"}), url = URL.createObjectURL(url));
      return url;
    }
    _setConnectionState(state, manual = !1) {
      this._connectionState = state;
      state === "connecting" ? this._wasManualDisconnect = !1 : state === "disconnecting" && (this._wasManualDisconnect = manual);
    }
    async _performAuth(token = null) {
      let tokenToSend, isManualToken = !1;
      if (token) {
        tokenToSend = token, isManualToken = !0;
      } else if (this.accessToken) {
        try {
          tokenToSend = await this.accessToken();
        } catch (e) {
          this.log("error", "Error fetching access token from callback", e), tokenToSend = this.accessTokenValue;
        }
      } else {
        tokenToSend = this.accessTokenValue;
      }
      isManualToken ? this._manuallySetToken = !0 : this.accessToken && (this._manuallySetToken = !1);
      this.accessTokenValue != tokenToSend && (this.accessTokenValue = tokenToSend, this.channels.forEach(channel => {
        const payload = {access_token:tokenToSend, version:constants_1.DEFAULT_VERSION};
        tokenToSend && channel.updateJoinPayload(payload);
        channel.joinedOnce && channel._isJoined() && channel._push(constants_1.CHANNEL_EVENTS.access_token, {access_token:tokenToSend});
      }));
    }
    async _waitForAuthIfNeeded() {
      this._authPromise && await this._authPromise;
    }
    _setAuthSafely(context = "general") {
      this._isManualToken() || this.setAuth().catch(e => {
        this.log("error", `Error setting auth in ${context}`, e);
      });
    }
    _triggerStateCallbacks(event, data) {
      try {
        this.stateChangeCallbacks[event].forEach(callback => {
          try {
            callback(data);
          } catch (e) {
            this.log("error", `error in ${event} callback`, e);
          }
        });
      } catch (e) {
        this.log("error", `error triggering ${event} callbacks`, e);
      }
    }
    _setupReconnectionTimer() {
      this.reconnectTimer = new timer_1.default(async() => {
        setTimeout(async() => {
          await this._waitForAuthIfNeeded();
          this.isConnected() || this.connect();
        }, 10);
      }, this.reconnectAfterMs);
    }
    _initializeOptions(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;
      this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_TIMEOUT;
      this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : 25000;
      this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : !1;
      this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;
      this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;
      this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : constants_1.DEFAULT_VSN;
      if (options === null || options === void 0 ? 0 : options.params) {
        this.params = options.params;
      }
      if (options === null || options === void 0 ? 0 : options.logger) {
        this.logger = options.logger;
      }
      if ((options === null || options === void 0 ? 0 : options.logLevel) || (options === null || options === void 0 ? 0 : options.log_level)) {
        this.logLevel = options.logLevel || options.log_level, this.params = Object.assign(Object.assign({}, this.params), {log_level:this.logLevel});
      }
      this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : tries => RECONNECT_INTERVALS[tries - 1] || 10000;
      switch(this.vsn) {
        case constants_1.VSN_1_0_0:
          this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : (payload, callback) => callback(JSON.stringify(payload));
          this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : (payload, callback) => callback(JSON.parse(payload));
          break;
        case constants_1.VSN_2_0_0:
          this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);
          this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);
          break;
        default:
          throw Error(`Unsupported serializer version: ${this.vsn}`);
      }
      if (this.worker) {
        if (typeof window !== "undefined" && !window.Worker) {
          throw Error("Web Worker is not supported");
        }
        this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
      }
    }
  }
  exports.default = RealtimeClient;
};

//# sourceMappingURL=module$node_modules$$supabase$realtime_js$dist$main$RealtimeClient.js.map
