shadow$provide.module$node_modules$$supabase$auth_js$dist$main$GoTrueAdminApi = function(require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  const tslib_1 = require("module$node_modules$tslib$tslib"), fetch_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$fetch"), helpers_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$helpers"), types_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$types"), errors_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$errors");
  class GoTrueAdminApi {
    constructor({url = "", headers = {}, fetch}) {
      this.url = url;
      this.headers = headers;
      this.fetch = (0,helpers_1.resolveFetch)(fetch);
      this.mfa = {listFactors:this._listFactors.bind(this), deleteFactor:this._deleteFactor.bind(this)};
      this.oauth = {listClients:this._listOAuthClients.bind(this), createClient:this._createOAuthClient.bind(this), getClient:this._getOAuthClient.bind(this), updateClient:this._updateOAuthClient.bind(this), deleteClient:this._deleteOAuthClient.bind(this), regenerateClientSecret:this._regenerateOAuthClientSecret.bind(this)};
    }
    async signOut(jwt, scope = types_1.SIGN_OUT_SCOPES[0]) {
      if (types_1.SIGN_OUT_SCOPES.indexOf(scope) < 0) {
        throw Error(`@supabase/auth-js: Parameter scope must be one of ${types_1.SIGN_OUT_SCOPES.join(", ")}`);
      }
      try {
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {headers:this.headers, jwt, noResolveJson:!0}), {data:null, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async inviteUserByEmail(email, options = {}) {
      try {
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/invite`, {body:{email, data:options.data}, headers:this.headers, redirectTo:options.redirectTo, xform:fetch_1._userResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    async generateLink(params) {
      try {
        const {options} = params, rest = tslib_1.__rest(params, ["options"]), body = Object.assign(Object.assign({}, rest), options);
        "newEmail" in rest && (body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail, delete body.newEmail);
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/admin/generate_link`, {body, headers:this.headers, xform:fetch_1._generateLinkResponse, redirectTo:options === null || options === void 0 ? void 0 : options.redirectTo});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{properties:null, user:null}, error};
        }
        throw error;
      }
    }
    async createUser(attributes) {
      try {
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/admin/users`, {body:attributes, headers:this.headers, xform:fetch_1._userResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    async listUsers(params) {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = {nextPage:null, lastPage:0, total:0}, response = await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/admin/users`, {headers:this.headers, noResolveJson:!0, query:{page:(_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "", per_page:(_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== 
        null && _d !== void 0 ? _d : ""}, xform:fetch_1._noResolveJsonResponse});
        if (response.error) {
          throw response.error;
        }
        const users = await response.json(), total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0, links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
        links.length > 0 && (links.forEach(link => {
          const page = parseInt(link.split(";")[0].split("\x3d")[1].substring(0, 1));
          link = JSON.parse(link.split(";")[1].split("\x3d")[1]);
          pagination[`${link}Page`] = page;
        }), pagination.total = parseInt(total));
        return {data:Object.assign(Object.assign({}, users), pagination), error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{users:[]}, error};
        }
        throw error;
      }
    }
    async getUserById(uid) {
      (0,helpers_1.validateUUID)(uid);
      try {
        return await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {headers:this.headers, xform:fetch_1._userResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    async updateUserById(uid, attributes) {
      (0,helpers_1.validateUUID)(uid);
      try {
        return await (0,fetch_1._request)(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {body:attributes, headers:this.headers, xform:fetch_1._userResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    async deleteUser(id, shouldSoftDelete = !1) {
      (0,helpers_1.validateUUID)(id);
      try {
        return await (0,fetch_1._request)(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {headers:this.headers, body:{should_soft_delete:shouldSoftDelete}, xform:fetch_1._userResponse});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{user:null}, error};
        }
        throw error;
      }
    }
    async _listFactors(params) {
      (0,helpers_1.validateUUID)(params.userId);
      try {
        const {data, error} = await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {headers:this.headers, xform:factors => ({data:{factors}, error:null})});
        return {data, error};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async _deleteFactor(params) {
      (0,helpers_1.validateUUID)(params.userId);
      (0,helpers_1.validateUUID)(params.id);
      try {
        return {data:await (0,fetch_1._request)(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {headers:this.headers}), error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async _listOAuthClients(params) {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = {nextPage:null, lastPage:0, total:0}, response = await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {headers:this.headers, noResolveJson:!0, query:{page:(_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "", per_page:(_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== 
        null && _d !== void 0 ? _d : ""}, xform:fetch_1._noResolveJsonResponse});
        if (response.error) {
          throw response.error;
        }
        const clients = await response.json(), total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0, links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
        links.length > 0 && (links.forEach(link => {
          const page = parseInt(link.split(";")[0].split("\x3d")[1].substring(0, 1));
          link = JSON.parse(link.split(";")[1].split("\x3d")[1]);
          pagination[`${link}Page`] = page;
        }), pagination.total = parseInt(total));
        return {data:Object.assign(Object.assign({}, clients), pagination), error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:{clients:[]}, error};
        }
        throw error;
      }
    }
    async _createOAuthClient(params) {
      try {
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {body:params, headers:this.headers, xform:client => ({data:client, error:null})});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async _getOAuthClient(clientId) {
      try {
        return await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/admin/oauth/clients/${clientId}`, {headers:this.headers, xform:client => ({data:client, error:null})});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async _updateOAuthClient(clientId, params) {
      try {
        return await (0,fetch_1._request)(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${clientId}`, {body:params, headers:this.headers, xform:client => ({data:client, error:null})});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async _deleteOAuthClient(clientId) {
      try {
        return await (0,fetch_1._request)(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${clientId}`, {headers:this.headers, noResolveJson:!0}), {data:null, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
    async _regenerateOAuthClientSecret(clientId) {
      try {
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {headers:this.headers, xform:client => ({data:client, error:null})});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
  }
  exports.default = GoTrueAdminApi;
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$GoTrueAdminApi.js.map
