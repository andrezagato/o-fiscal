shadow$provide.module$node_modules$$supabase$storage_js$dist$index_cjs = function(require, module, exports) {
  function isStorageError(error) {
    return typeof error === "object" && error !== null && "__isStorageError" in error;
  }
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
      return typeof o$1;
    } : function(o$1) {
      return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
    }, _typeof(o);
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r$1) {
        return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
      }));
      t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e$jscomp$0) {
    for (var r = 1; r < arguments.length; r++) {
      var t$jscomp$0 = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t$jscomp$0), !0).forEach(function(r$1) {
        var r, t = t$jscomp$0[r$1];
        a: {
          if ("object" == _typeof(r$1) && r$1) {
            var e = r$1[Symbol.toPrimitive];
            if (void 0 !== e) {
              r$1 = e.call(r$1, "string");
              if ("object" != _typeof(r$1)) {
                break a;
              }
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            r$1 = String(r$1);
          }
        }
        (r = "symbol" == _typeof(r$1) ? r$1 : r$1 + "") in e$jscomp$0 ? Object.defineProperty(e$jscomp$0, r, {value:t, enumerable:!0, configurable:!0, writable:!0}) : e$jscomp$0[r] = t;
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$jscomp$0, Object.getOwnPropertyDescriptors(t$jscomp$0)) : ownKeys(Object(t$jscomp$0)).forEach(function(r$1) {
        Object.defineProperty(e$jscomp$0, r$1, Object.getOwnPropertyDescriptor(t$jscomp$0, r$1));
      });
    }
    return e$jscomp$0;
  }
  async function _handleRequest(fetcher, method, url, options, parameters, body, namespace) {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams(method, options, parameters, body)).then(result => {
        if (!result.ok) {
          throw result;
        }
        if (options === null || options === void 0 ? 0 : options.noResolveJson) {
          return result;
        }
        if (namespace === "vectors") {
          const contentType = result.headers.get("content-type");
          if (result.headers.get("content-length") === "0" || result.status === 204 || !contentType || !contentType.includes("application/json")) {
            return {};
          }
        }
        return result.json();
      }).then(data => resolve(data)).catch(error => handleError(error, reject, options, namespace));
    });
  }
  function createFetchApi(namespace = "storage") {
    return {get:async(fetcher, url, options, parameters) => _handleRequest(fetcher, "GET", url, options, parameters, void 0, namespace), post:async(fetcher, url, body, options, parameters) => _handleRequest(fetcher, "POST", url, options, parameters, body, namespace), put:async(fetcher, url, body, options, parameters) => _handleRequest(fetcher, "PUT", url, options, parameters, body, namespace), head:async(fetcher, url, options, parameters) => _handleRequest(fetcher, "HEAD", url, _objectSpread2(_objectSpread2({}, 
    options), {}, {noResolveJson:!0}), parameters, void 0, namespace), remove:async(fetcher, url, body, options, parameters) => _handleRequest(fetcher, "DELETE", url, options, parameters, body, namespace)};
  }
  var Buffer = require("module$node_modules$buffer$index").Buffer;
  let iceberg_js = require("module$node_modules$iceberg_js$dist$index_cjs");
  var StorageError = class extends Error {
    constructor(message, namespace = "storage", status, statusCode) {
      super(message);
      this.__isStorageError = !0;
      this.namespace = namespace;
      this.name = namespace === "vectors" ? "StorageVectorsError" : "StorageError";
      this.status = status;
      this.statusCode = statusCode;
    }
  }, StorageApiError = class extends StorageError {
    constructor(message, status, statusCode, namespace = "storage") {
      super(message, namespace, status, statusCode);
      this.name = namespace === "vectors" ? "StorageVectorsApiError" : "StorageApiError";
      this.status = status;
      this.statusCode = statusCode;
    }
    toJSON() {
      return {name:this.name, message:this.message, status:this.status, statusCode:this.statusCode};
    }
  }, StorageUnknownError = class extends StorageError {
    constructor(message, originalError, namespace = "storage") {
      super(message, namespace);
      this.name = namespace === "vectors" ? "StorageVectorsUnknownError" : "StorageUnknownError";
      this.originalError = originalError;
    }
  };
  require = class extends StorageError {
    constructor(message) {
      super(message, "vectors");
    }
  };
  module = class extends StorageApiError {
    constructor(message, status, statusCode) {
      super(message, status, statusCode, "vectors");
    }
  };
  var StorageVectorsUnknownError = class extends StorageUnknownError {
    constructor(message, originalError) {
      super(message, originalError, "vectors");
    }
  };
  let StorageVectorsErrorCode = function(StorageVectorsErrorCode$1) {
    StorageVectorsErrorCode$1.InternalError = "InternalError";
    StorageVectorsErrorCode$1.S3VectorConflictException = "S3VectorConflictException";
    StorageVectorsErrorCode$1.S3VectorNotFoundException = "S3VectorNotFoundException";
    StorageVectorsErrorCode$1.S3VectorBucketNotEmpty = "S3VectorBucketNotEmpty";
    StorageVectorsErrorCode$1.S3VectorMaxBucketsExceeded = "S3VectorMaxBucketsExceeded";
    StorageVectorsErrorCode$1.S3VectorMaxIndexesExceeded = "S3VectorMaxIndexesExceeded";
    return StorageVectorsErrorCode$1;
  }({});
  const resolveFetch = customFetch => customFetch ? (...args) => customFetch(...args) : (...args) => fetch(...args), recursiveToCamel = item => {
    if (Array.isArray(item)) {
      return item.map(el => recursiveToCamel(el));
    }
    if (typeof item === "function" || item !== Object(item)) {
      return item;
    }
    const result = {};
    Object.entries(item).forEach(([key, value]) => {
      key = key.replace(/([-_][a-z])/gi, c => c.toUpperCase().replace(/[-_]/g, ""));
      result[key] = recursiveToCamel(value);
    });
    return result;
  }, isValidBucketName = bucketName => !bucketName || typeof bucketName !== "string" || bucketName.length === 0 || bucketName.length > 100 || bucketName.trim() !== bucketName || bucketName.includes("/") || bucketName.includes("\\") ? !1 : /^[\w!.\*'() &$@=;:+,?-]+$/.test(bucketName), _getErrorMessage = err => {
    var _err$error;
    return err.msg || err.message || err.error_description || (typeof err.error === "string" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);
  }, handleError = async(error, reject, options, namespace) => {
    if (error && typeof error === "object" && "status" in error && "ok" in error && typeof error.status === "number" && (options === null || options === void 0 || !options.noResolveJson)) {
      const status = error.status || 500;
      typeof error.json === "function" ? error.json().then(err => {
        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + "";
        reject(new StorageApiError(_getErrorMessage(err), status, statusCode, namespace));
      }).catch(() => {
        reject(new StorageApiError(error.statusText || `HTTP ${status} error`, status, status + "", namespace));
      }) : reject(new StorageApiError(error.statusText || `HTTP ${status} error`, status, status + "", namespace));
    } else {
      reject(new StorageUnknownError(_getErrorMessage(error), error, namespace));
    }
  }, _getRequestParams = (method, options, parameters, body) => {
    const params = {method, headers:(options === null || options === void 0 ? void 0 : options.headers) || {}};
    if (method === "GET" || method === "HEAD" || !body) {
      return _objectSpread2(_objectSpread2({}, params), parameters);
    }
    typeof body !== "object" || body === null ? method = !1 : (method = Object.getPrototypeOf(body), method = (method === null || method === Object.prototype || Object.getPrototypeOf(method) === null) && !(Symbol.toStringTag in body) && !(Symbol.iterator in body));
    method ? (params.headers = _objectSpread2({"Content-Type":"application/json"}, options === null || options === void 0 ? void 0 : options.headers), params.body = JSON.stringify(body)) : params.body = body;
    if (options === null || options === void 0 ? 0 : options.duplex) {
      params.duplex = options.duplex;
    }
    return _objectSpread2(_objectSpread2({}, params), parameters);
  };
  var defaultApi = createFetchApi("storage");
  const {get, post, put, head, remove} = defaultApi, vectorsApi = createFetchApi("vectors");
  var BaseApiClient = class {
    constructor(url, headers = {}, fetch$1, namespace = "storage") {
      this.shouldThrowOnError = !1;
      this.url = url;
      this.headers = headers;
      this.fetch = resolveFetch(fetch$1);
      this.namespace = namespace;
    }
    throwOnError() {
      this.shouldThrowOnError = !0;
      return this;
    }
    setHeader(name, value) {
      this.headers = _objectSpread2(_objectSpread2({}, this.headers), {}, {[name]:value});
      return this;
    }
    async handleOperation(operation) {
      try {
        return {data:await operation(), error:null};
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
  }, StreamDownloadBuilder = class {
    constructor(downloadFn, shouldThrowOnError) {
      this.downloadFn = downloadFn;
      this.shouldThrowOnError = shouldThrowOnError;
    }
    then(onfulfilled, onrejected) {
      return this.execute().then(onfulfilled, onrejected);
    }
    async execute() {
      try {
        return {data:(await this.downloadFn()).body, error:null};
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
  };
  let _Symbol$toStringTag;
  _Symbol$toStringTag = Symbol.toStringTag;
  var BlobDownloadBuilder = class {
    constructor(downloadFn, shouldThrowOnError) {
      this.downloadFn = downloadFn;
      this.shouldThrowOnError = shouldThrowOnError;
      this[_Symbol$toStringTag] = "BlobDownloadBuilder";
      this.promise = null;
    }
    asStream() {
      return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);
    }
    then(onfulfilled, onrejected) {
      return this.getPromise().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
      return this.getPromise().catch(onrejected);
    }
    finally(onfinally) {
      return this.getPromise().finally(onfinally);
    }
    getPromise() {
      this.promise || (this.promise = this.execute());
      return this.promise;
    }
    async execute() {
      try {
        return {data:await (await this.downloadFn()).blob(), error:null};
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return {data:null, error};
        }
        throw error;
      }
    }
  };
  const DEFAULT_SEARCH_OPTIONS = {limit:100, offset:0, sortBy:{column:"name", order:"asc"}}, DEFAULT_FILE_OPTIONS = {cacheControl:"3600", contentType:"text/plain;charset\x3dUTF-8", upsert:!1};
  var StorageFileApi = class extends BaseApiClient {
    constructor(url, headers = {}, bucketId, fetch$1) {
      super(url, headers, fetch$1, "storage");
      this.bucketId = bucketId;
    }
    async uploadOrUpdate(method, path, fileBody, fileOptions) {
      var _this = this;
      return _this.handleOperation(async() => {
        const options = _objectSpread2(_objectSpread2({}, DEFAULT_FILE_OPTIONS), fileOptions);
        let headers = _objectSpread2(_objectSpread2({}, _this.headers), method === "POST" && {"x-upsert":String(options.upsert)});
        var metadata = options.metadata;
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          var body = new FormData();
          body.append("cacheControl", options.cacheControl);
          metadata && body.append("metadata", _this.encodeMetadata(metadata));
          body.append("", fileBody);
        } else {
          typeof FormData !== "undefined" && fileBody instanceof FormData ? (body = fileBody, body.has("cacheControl") || body.append("cacheControl", options.cacheControl), metadata && !body.has("metadata") && body.append("metadata", _this.encodeMetadata(metadata))) : (body = fileBody, headers["cache-control"] = `max-age=${options.cacheControl}`, headers["content-type"] = options.contentType, metadata && (headers["x-metadata"] = _this.toBase64(_this.encodeMetadata(metadata))), (typeof ReadableStream !== 
          "undefined" && body instanceof ReadableStream || body && typeof body === "object" && "pipe" in body && typeof body.pipe === "function") && !options.duplex && (options.duplex = "half"));
        }
        if (fileOptions === null || fileOptions === void 0 ? 0 : fileOptions.headers) {
          headers = _objectSpread2(_objectSpread2({}, headers), fileOptions.headers);
        }
        metadata = _this._removeEmptyFolders(path);
        const _path = _this._getFinalPath(metadata);
        body = await (method == "PUT" ? put : post)(_this.fetch, `${_this.url}/object/${_path}`, body, _objectSpread2({headers}, (options === null || options === void 0 ? 0 : options.duplex) ? {duplex:options.duplex} : {}));
        return {path:metadata, id:body.Id, fullPath:body.Key};
      });
    }
    async upload(path, fileBody, fileOptions) {
      return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
    }
    async uploadToSignedUrl(path, token, fileBody, fileOptions) {
      var _this3 = this;
      const cleanPath = _this3._removeEmptyFolders(path);
      path = _this3._getFinalPath(cleanPath);
      const url = new URL(_this3.url + `/object/upload/sign/${path}`);
      url.searchParams.set("token", token);
      return _this3.handleOperation(async() => {
        let body;
        const options = _objectSpread2({upsert:DEFAULT_FILE_OPTIONS.upsert}, fileOptions), headers = _objectSpread2(_objectSpread2({}, _this3.headers), {"x-upsert":String(options.upsert)});
        typeof Blob !== "undefined" && fileBody instanceof Blob ? (body = new FormData(), body.append("cacheControl", options.cacheControl), body.append("", fileBody)) : typeof FormData !== "undefined" && fileBody instanceof FormData ? (body = fileBody, body.append("cacheControl", options.cacheControl)) : (body = fileBody, headers["cache-control"] = `max-age=${options.cacheControl}`, headers["content-type"] = options.contentType);
        return {path:cleanPath, fullPath:(await put(_this3.fetch, url.toString(), body, {headers})).Key};
      });
    }
    async createSignedUploadUrl(path, options) {
      var _this4 = this;
      return _this4.handleOperation(async() => {
        var _path = _this4._getFinalPath(path), headers = _objectSpread2({}, _this4.headers);
        if (options === null || options === void 0 ? 0 : options.upsert) {
          headers["x-upsert"] = "true";
        }
        _path = await post(_this4.fetch, `${_this4.url}/object/upload/sign/${_path}`, {}, {headers});
        _path = new URL(_this4.url + _path.url);
        headers = _path.searchParams.get("token");
        if (!headers) {
          throw new StorageError("No token returned by API");
        }
        return {signedUrl:_path.toString(), path, token:headers};
      });
    }
    async update(path, fileBody, fileOptions) {
      return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
    }
    async move(fromPath, toPath, options) {
      var _this6 = this;
      return _this6.handleOperation(async() => await post(_this6.fetch, `${_this6.url}/object/move`, {bucketId:_this6.bucketId, sourceKey:fromPath, destinationKey:toPath, destinationBucket:options === null || options === void 0 ? void 0 : options.destinationBucket}, {headers:_this6.headers}));
    }
    async copy(fromPath, toPath, options) {
      var _this7 = this;
      return _this7.handleOperation(async() => ({path:(await post(_this7.fetch, `${_this7.url}/object/copy`, {bucketId:_this7.bucketId, sourceKey:fromPath, destinationKey:toPath, destinationBucket:options === null || options === void 0 ? void 0 : options.destinationBucket}, {headers:_this7.headers})).Key}));
    }
    async createSignedUrl(path, expiresIn, options) {
      var _this8 = this;
      return _this8.handleOperation(async() => {
        var _path = _this8._getFinalPath(path);
        _path = await post(_this8.fetch, `${_this8.url}/object/sign/${_path}`, _objectSpread2({expiresIn}, (options === null || options === void 0 ? 0 : options.transform) ? {transform:options.transform} : {}), {headers:_this8.headers});
        return {signedUrl:encodeURI(`${_this8.url}${_path.signedURL}${(options === null || options === void 0 ? 0 : options.download) ? `&download=${options.download === !0 ? "" : options.download}` : ""}`)};
      });
    }
    async createSignedUrls(paths, expiresIn, options) {
      var _this9 = this;
      return _this9.handleOperation(async() => {
        const data = await post(_this9.fetch, `${_this9.url}/object/sign/${_this9.bucketId}`, {expiresIn, paths}, {headers:_this9.headers}), downloadQueryParam = (options === null || options === void 0 ? 0 : options.download) ? `&download=${options.download === !0 ? "" : options.download}` : "";
        return data.map(datum => _objectSpread2(_objectSpread2({}, datum), {}, {signedUrl:datum.signedURL ? encodeURI(`${_this9.url}${datum.signedURL}${downloadQueryParam}`) : null}));
      });
    }
    download(path, options, parameters) {
      const renderPath = typeof(options === null || options === void 0 ? void 0 : options.transform) !== "undefined" ? "render/image/authenticated" : "object", queryString = (options = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {})) ? `?${options}` : "", _path = this._getFinalPath(path);
      return new BlobDownloadBuilder(() => get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {headers:this.headers, noResolveJson:!0}, parameters), this.shouldThrowOnError);
    }
    async info(path) {
      var _this10 = this;
      const _path = _this10._getFinalPath(path);
      return _this10.handleOperation(async() => recursiveToCamel(await get(_this10.fetch, `${_this10.url}/object/info/${_path}`, {headers:_this10.headers})));
    }
    async exists(path) {
      path = this._getFinalPath(path);
      try {
        return await head(this.fetch, `${this.url}/object/${path}`, {headers:this.headers}), {data:!0, error:null};
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error) && error instanceof StorageUnknownError && (path = error.originalError, [400, 404].includes(path === null || path === void 0 ? void 0 : path.status))) {
          return {data:!1, error};
        }
        throw error;
      }
    }
    getPublicUrl(path, options) {
      path = this._getFinalPath(path);
      const _queryString = [];
      var downloadQueryParam = (options === null || options === void 0 ? 0 : options.download) ? `download=${options.download === !0 ? "" : options.download}` : "";
      downloadQueryParam !== "" && _queryString.push(downloadQueryParam);
      downloadQueryParam = typeof(options === null || options === void 0 ? void 0 : options.transform) !== "undefined" ? "render/image" : "object";
      options = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      options !== "" && _queryString.push(options);
      options = _queryString.join("\x26");
      options !== "" && (options = `?${options}`);
      return {data:{publicUrl:encodeURI(`${this.url}/${downloadQueryParam}/public/${path}${options}`)}};
    }
    async remove(paths) {
      var _this12 = this;
      return _this12.handleOperation(async() => await remove(_this12.fetch, `${_this12.url}/object/${_this12.bucketId}`, {prefixes:paths}, {headers:_this12.headers}));
    }
    async list(path, options, parameters) {
      var _this13 = this;
      return _this13.handleOperation(async() => {
        const body = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SEARCH_OPTIONS), options), {}, {prefix:path || ""});
        return await post(_this13.fetch, `${_this13.url}/object/list/${_this13.bucketId}`, body, {headers:_this13.headers}, parameters);
      });
    }
    async listV2(options, parameters) {
      var _this14 = this;
      return _this14.handleOperation(async() => {
        const body = _objectSpread2({}, options);
        return await post(_this14.fetch, `${_this14.url}/object/list-v2/${_this14.bucketId}`, body, {headers:_this14.headers}, parameters);
      });
    }
    encodeMetadata(metadata) {
      return JSON.stringify(metadata);
    }
    toBase64(data) {
      return typeof Buffer !== "undefined" ? Buffer.from(data).toString("base64") : btoa(data);
    }
    _getFinalPath(path) {
      return `${this.bucketId}/${path.replace(/^\/+/, "")}`;
    }
    _removeEmptyFolders(path) {
      return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
    }
    transformOptsToQueryString(transform) {
      const params = [];
      transform.width && params.push(`width=${transform.width}`);
      transform.height && params.push(`height=${transform.height}`);
      transform.resize && params.push(`resize=${transform.resize}`);
      transform.format && params.push(`format=${transform.format}`);
      transform.quality && params.push(`quality=${transform.quality}`);
      return params.join("\x26");
    }
  };
  const DEFAULT_HEADERS = {"X-Client-Info":"storage-js/2.97.0"};
  var StorageBucketApi = class extends BaseApiClient {
    constructor(url, headers = {}, fetch$1, opts) {
      url = new URL(url);
      (opts === null || opts === void 0 ? 0 : opts.useNewHostname) && /supabase\.(co|in|red)$/.test(url.hostname) && !url.hostname.includes("storage.supabase.") && (url.hostname = url.hostname.replace("supabase.", "storage.supabase."));
      opts = url.href.replace(/\/$/, "");
      headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);
      super(opts, headers, fetch$1, "storage");
    }
    async listBuckets(options) {
      var _this = this;
      return _this.handleOperation(async() => {
        const queryString = _this.listBucketOptionsToQueryString(options);
        return await get(_this.fetch, `${_this.url}/bucket${queryString}`, {headers:_this.headers});
      });
    }
    async getBucket(id) {
      var _this2 = this;
      return _this2.handleOperation(async() => await get(_this2.fetch, `${_this2.url}/bucket/${id}`, {headers:_this2.headers}));
    }
    async createBucket(id, options = {public:!1}) {
      var _this3 = this;
      return _this3.handleOperation(async() => await post(_this3.fetch, `${_this3.url}/bucket`, {id, name:id, type:options.type, public:options.public, file_size_limit:options.fileSizeLimit, allowed_mime_types:options.allowedMimeTypes}, {headers:_this3.headers}));
    }
    async updateBucket(id, options) {
      var _this4 = this;
      return _this4.handleOperation(async() => await put(_this4.fetch, `${_this4.url}/bucket/${id}`, {id, name:id, public:options.public, file_size_limit:options.fileSizeLimit, allowed_mime_types:options.allowedMimeTypes}, {headers:_this4.headers}));
    }
    async emptyBucket(id) {
      var _this5 = this;
      return _this5.handleOperation(async() => await post(_this5.fetch, `${_this5.url}/bucket/${id}/empty`, {}, {headers:_this5.headers}));
    }
    async deleteBucket(id) {
      var _this6 = this;
      return _this6.handleOperation(async() => await remove(_this6.fetch, `${_this6.url}/bucket/${id}`, {}, {headers:_this6.headers}));
    }
    listBucketOptionsToQueryString(options) {
      const params = {};
      options && ("limit" in options && (params.limit = String(options.limit)), "offset" in options && (params.offset = String(options.offset)), options.search && (params.search = options.search), options.sortColumn && (params.sortColumn = options.sortColumn), options.sortOrder && (params.sortOrder = options.sortOrder));
      return Object.keys(params).length > 0 ? "?" + (new URLSearchParams(params)).toString() : "";
    }
  }, StorageAnalyticsClient = class extends BaseApiClient {
    constructor(url, headers = {}, fetch$1) {
      url = url.replace(/\/$/, "");
      headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);
      super(url, headers, fetch$1, "storage");
    }
    async createBucket(name) {
      var _this = this;
      return _this.handleOperation(async() => await post(_this.fetch, `${_this.url}/bucket`, {name}, {headers:_this.headers}));
    }
    async listBuckets(options) {
      var _this2 = this;
      return _this2.handleOperation(async() => {
        var queryParams = new URLSearchParams();
        (options === null || options === void 0 ? void 0 : options.limit) !== void 0 && queryParams.set("limit", options.limit.toString());
        (options === null || options === void 0 ? void 0 : options.offset) !== void 0 && queryParams.set("offset", options.offset.toString());
        (options === null || options === void 0 ? 0 : options.sortColumn) && queryParams.set("sortColumn", options.sortColumn);
        (options === null || options === void 0 ? 0 : options.sortOrder) && queryParams.set("sortOrder", options.sortOrder);
        (options === null || options === void 0 ? 0 : options.search) && queryParams.set("search", options.search);
        queryParams = queryParams.toString();
        return await get(_this2.fetch, queryParams ? `${_this2.url}/bucket?${queryParams}` : `${_this2.url}/bucket`, {headers:_this2.headers});
      });
    }
    async deleteBucket(bucketName) {
      var _this3 = this;
      return _this3.handleOperation(async() => await remove(_this3.fetch, `${_this3.url}/bucket/${bucketName}`, {}, {headers:_this3.headers}));
    }
    from(bucketName) {
      var _this4 = this;
      if (!isValidBucketName(bucketName)) {
        throw new StorageError("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");
      }
      bucketName = new iceberg_js.IcebergRestCatalog({baseUrl:this.url, catalogName:bucketName, auth:{type:"custom", getHeaders:async() => _this4.headers}, fetch:this.fetch});
      const shouldThrowOnError = this.shouldThrowOnError;
      return new Proxy(bucketName, {get(target, prop) {
        const value = target[prop];
        return typeof value !== "function" ? value : async(...args) => {
          try {
            return {data:await value.apply(target, args), error:null};
          } catch (error) {
            if (shouldThrowOnError) {
              throw error;
            }
            return {data:null, error};
          }
        };
      }});
    }
  };
  defaultApi = class extends BaseApiClient {
    constructor(url, headers = {}, fetch$1) {
      url = url.replace(/\/$/, "");
      headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, {"Content-Type":"application/json"}, headers);
      super(url, headers, fetch$1, "vectors");
    }
    async createIndex(options) {
      var _this = this;
      return _this.handleOperation(async() => await vectorsApi.post(_this.fetch, `${_this.url}/CreateIndex`, options, {headers:_this.headers}) || {});
    }
    async getIndex(vectorBucketName, indexName) {
      var _this2 = this;
      return _this2.handleOperation(async() => await vectorsApi.post(_this2.fetch, `${_this2.url}/GetIndex`, {vectorBucketName, indexName}, {headers:_this2.headers}));
    }
    async listIndexes(options) {
      var _this3 = this;
      return _this3.handleOperation(async() => await vectorsApi.post(_this3.fetch, `${_this3.url}/ListIndexes`, options, {headers:_this3.headers}));
    }
    async deleteIndex(vectorBucketName, indexName) {
      var _this4 = this;
      return _this4.handleOperation(async() => await vectorsApi.post(_this4.fetch, `${_this4.url}/DeleteIndex`, {vectorBucketName, indexName}, {headers:_this4.headers}) || {});
    }
  };
  var VectorDataApi = class extends BaseApiClient {
    constructor(url, headers = {}, fetch$1) {
      url = url.replace(/\/$/, "");
      headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, {"Content-Type":"application/json"}, headers);
      super(url, headers, fetch$1, "vectors");
    }
    async putVectors(options) {
      var _this = this;
      if (options.vectors.length < 1 || options.vectors.length > 500) {
        throw Error("Vector batch size must be between 1 and 500 items");
      }
      return _this.handleOperation(async() => await vectorsApi.post(_this.fetch, `${_this.url}/PutVectors`, options, {headers:_this.headers}) || {});
    }
    async getVectors(options) {
      var _this2 = this;
      return _this2.handleOperation(async() => await vectorsApi.post(_this2.fetch, `${_this2.url}/GetVectors`, options, {headers:_this2.headers}));
    }
    async listVectors(options) {
      var _this3 = this;
      if (options.segmentCount !== void 0) {
        if (options.segmentCount < 1 || options.segmentCount > 16) {
          throw Error("segmentCount must be between 1 and 16");
        }
        if (options.segmentIndex !== void 0 && (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount)) {
          throw Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);
        }
      }
      return _this3.handleOperation(async() => await vectorsApi.post(_this3.fetch, `${_this3.url}/ListVectors`, options, {headers:_this3.headers}));
    }
    async queryVectors(options) {
      var _this4 = this;
      return _this4.handleOperation(async() => await vectorsApi.post(_this4.fetch, `${_this4.url}/QueryVectors`, options, {headers:_this4.headers}));
    }
    async deleteVectors(options) {
      var _this5 = this;
      if (options.keys.length < 1 || options.keys.length > 500) {
        throw Error("Keys batch size must be between 1 and 500 items");
      }
      return _this5.handleOperation(async() => await vectorsApi.post(_this5.fetch, `${_this5.url}/DeleteVectors`, options, {headers:_this5.headers}) || {});
    }
  };
  BaseApiClient = class extends BaseApiClient {
    constructor(url, headers = {}, fetch$1) {
      url = url.replace(/\/$/, "");
      headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, {"Content-Type":"application/json"}, headers);
      super(url, headers, fetch$1, "vectors");
    }
    async createBucket(vectorBucketName) {
      var _this = this;
      return _this.handleOperation(async() => await vectorsApi.post(_this.fetch, `${_this.url}/CreateVectorBucket`, {vectorBucketName}, {headers:_this.headers}) || {});
    }
    async getBucket(vectorBucketName) {
      var _this2 = this;
      return _this2.handleOperation(async() => await vectorsApi.post(_this2.fetch, `${_this2.url}/GetVectorBucket`, {vectorBucketName}, {headers:_this2.headers}));
    }
    async listBuckets(options = {}) {
      var _this3 = this;
      return _this3.handleOperation(async() => await vectorsApi.post(_this3.fetch, `${_this3.url}/ListVectorBuckets`, options, {headers:_this3.headers}));
    }
    async deleteBucket(vectorBucketName) {
      var _this4 = this;
      return _this4.handleOperation(async() => await vectorsApi.post(_this4.fetch, `${_this4.url}/DeleteVectorBucket`, {vectorBucketName}, {headers:_this4.headers}) || {});
    }
  };
  var StorageVectorsClient = class extends BaseApiClient {
    constructor(url, options = {}) {
      super(url, options.headers || {}, options.fetch);
    }
    from(vectorBucketName) {
      return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);
    }
    async createBucket(vectorBucketName) {
      return (() => super.createBucket)().call(this, vectorBucketName);
    }
    async getBucket(vectorBucketName) {
      return (() => super.getBucket)().call(this, vectorBucketName);
    }
    async listBuckets(options = {}) {
      return (() => super.listBuckets)().call(this, options);
    }
    async deleteBucket(vectorBucketName) {
      return (() => super.deleteBucket)().call(this, vectorBucketName);
    }
  }, VectorBucketScope = class extends defaultApi {
    constructor(url, headers, vectorBucketName, fetch$1) {
      super(url, headers, fetch$1);
      this.vectorBucketName = vectorBucketName;
    }
    async createIndex(options) {
      return (() => super.createIndex)().call(this, _objectSpread2(_objectSpread2({}, options), {}, {vectorBucketName:this.vectorBucketName}));
    }
    async listIndexes(options = {}) {
      return (() => super.listIndexes)().call(this, _objectSpread2(_objectSpread2({}, options), {}, {vectorBucketName:this.vectorBucketName}));
    }
    async getIndex(indexName) {
      return (() => super.getIndex)().call(this, this.vectorBucketName, indexName);
    }
    async deleteIndex(indexName) {
      return (() => super.deleteIndex)().call(this, this.vectorBucketName, indexName);
    }
    index(indexName) {
      return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);
    }
  }, VectorIndexScope = class extends VectorDataApi {
    constructor(url, headers, vectorBucketName, indexName, fetch$1) {
      super(url, headers, fetch$1);
      this.vectorBucketName = vectorBucketName;
      this.indexName = indexName;
    }
    async putVectors(options) {
      return (() => super.putVectors)().call(this, _objectSpread2(_objectSpread2({}, options), {}, {vectorBucketName:this.vectorBucketName, indexName:this.indexName}));
    }
    async getVectors(options) {
      return (() => super.getVectors)().call(this, _objectSpread2(_objectSpread2({}, options), {}, {vectorBucketName:this.vectorBucketName, indexName:this.indexName}));
    }
    async listVectors(options = {}) {
      return (() => super.listVectors)().call(this, _objectSpread2(_objectSpread2({}, options), {}, {vectorBucketName:this.vectorBucketName, indexName:this.indexName}));
    }
    async queryVectors(options) {
      return (() => super.queryVectors)().call(this, _objectSpread2(_objectSpread2({}, options), {}, {vectorBucketName:this.vectorBucketName, indexName:this.indexName}));
    }
    async deleteVectors(options) {
      return (() => super.deleteVectors)().call(this, _objectSpread2(_objectSpread2({}, options), {}, {vectorBucketName:this.vectorBucketName, indexName:this.indexName}));
    }
  };
  StorageBucketApi = class extends StorageBucketApi {
    constructor(url, headers = {}, fetch$1, opts) {
      super(url, headers, fetch$1, opts);
    }
    from(id) {
      return new StorageFileApi(this.url, this.headers, id, this.fetch);
    }
    get vectors() {
      return new StorageVectorsClient(this.url + "/vector", {headers:this.headers, fetch:this.fetch});
    }
    get analytics() {
      return new StorageAnalyticsClient(this.url + "/iceberg", this.headers, this.fetch);
    }
  };
  exports.StorageAnalyticsClient = StorageAnalyticsClient;
  exports.StorageApiError = StorageApiError;
  exports.StorageClient = StorageBucketApi;
  exports.StorageError = StorageError;
  exports.StorageUnknownError = StorageUnknownError;
  exports.StorageVectorsApiError = module;
  exports.StorageVectorsClient = StorageVectorsClient;
  exports.StorageVectorsError = require;
  exports.StorageVectorsErrorCode = StorageVectorsErrorCode;
  exports.StorageVectorsUnknownError = StorageVectorsUnknownError;
  exports.VectorBucketApi = BaseApiClient;
  exports.VectorBucketScope = VectorBucketScope;
  exports.VectorDataApi = VectorDataApi;
  exports.VectorIndexApi = defaultApi;
  exports.VectorIndexScope = VectorIndexScope;
  exports.isStorageError = isStorageError;
  exports.isStorageVectorsError = function(error) {
    return isStorageError(error) && error.namespace === "vectors";
  };
};

//# sourceMappingURL=module$node_modules$$supabase$storage_js$dist$index_cjs.js.map
