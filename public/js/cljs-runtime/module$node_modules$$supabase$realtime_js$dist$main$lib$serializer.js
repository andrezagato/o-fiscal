shadow$provide.module$node_modules$$supabase$realtime_js$dist$main$lib$serializer = function(require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  class Serializer {
    constructor(allowedMetadataKeys) {
      this.HEADER_LENGTH = 1;
      this.USER_BROADCAST_PUSH_META_LENGTH = 6;
      this.KINDS = {userBroadcastPush:3, userBroadcast:4};
      this.BINARY_ENCODING = 0;
      this.JSON_ENCODING = 1;
      this.BROADCAST_EVENT = "broadcast";
      this.allowedMetadataKeys = [];
      this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];
    }
    encode(msg, callback) {
      return msg.event !== this.BROADCAST_EVENT || msg.payload instanceof ArrayBuffer || typeof msg.payload.event !== "string" ? callback(JSON.stringify([msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload])) : callback(this._binaryEncodeUserBroadcastPush(msg));
    }
    _binaryEncodeUserBroadcastPush(message) {
      var _a;
      return this._isArrayBuffer((_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) ? this._encodeBinaryUserBroadcastPush(message) : this._encodeJsonUserBroadcastPush(message);
    }
    _encodeBinaryUserBroadcastPush(message) {
      var _a, _b;
      const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);
      return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);
    }
    _encodeJsonUserBroadcastPush(message) {
      var _a, _b;
      const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};
      _a = (new TextEncoder()).encode(JSON.stringify(userPayload)).buffer;
      return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, _a);
    }
    _encodeUserBroadcastPush(message, encodingType, encodedPayload) {
      var _a, _b;
      const topic = message.topic, ref = (_a = message.ref) !== null && _a !== void 0 ? _a : "";
      _a = (_b = message.join_ref) !== null && _b !== void 0 ? _b : "";
      _b = message.payload.event;
      message = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};
      const metadata = Object.keys(message).length === 0 ? "" : JSON.stringify(message);
      if (_a.length > 255) {
        throw Error(`joinRef length ${_a.length} exceeds maximum of 255`);
      }
      if (ref.length > 255) {
        throw Error(`ref length ${ref.length} exceeds maximum of 255`);
      }
      if (topic.length > 255) {
        throw Error(`topic length ${topic.length} exceeds maximum of 255`);
      }
      if (_b.length > 255) {
        throw Error(`userEvent length ${_b.length} exceeds maximum of 255`);
      }
      if (metadata.length > 255) {
        throw Error(`metadata length ${metadata.length} exceeds maximum of 255`);
      }
      message = new ArrayBuffer(this.HEADER_LENGTH + (this.USER_BROADCAST_PUSH_META_LENGTH + _a.length + ref.length + topic.length + _b.length + metadata.length));
      let view = new DataView(message), offset = 0;
      view.setUint8(offset++, this.KINDS.userBroadcastPush);
      view.setUint8(offset++, _a.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, _b.length);
      view.setUint8(offset++, metadata.length);
      view.setUint8(offset++, encodingType);
      Array.from(_a, char => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, char => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, char => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(_b, char => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(metadata, char => view.setUint8(offset++, char.charCodeAt(0)));
      encodingType = new Uint8Array(message.byteLength + encodedPayload.byteLength);
      encodingType.set(new Uint8Array(message), 0);
      encodingType.set(new Uint8Array(encodedPayload), message.byteLength);
      return encodingType.buffer;
    }
    decode(rawPayload, callback) {
      if (this._isArrayBuffer(rawPayload)) {
        return rawPayload = this._binaryDecode(rawPayload), callback(rawPayload);
      }
      if (typeof rawPayload === "string") {
        rawPayload = JSON.parse(rawPayload);
        const [join_ref, ref, topic, event, payload] = rawPayload;
        return callback({join_ref, ref, topic, event, payload});
      }
      return callback({});
    }
    _binaryDecode(buffer) {
      const view = new DataView(buffer), kind = view.getUint8(0), decoder = new TextDecoder();
      switch(kind) {
        case this.KINDS.userBroadcast:
          return this._decodeUserBroadcast(buffer, view, decoder);
      }
    }
    _decodeUserBroadcast(buffer, view, decoder) {
      var topicSize = view.getUint8(1), userEventSize = view.getUint8(2);
      const metadataSize = view.getUint8(3), payloadEncoding = view.getUint8(4);
      let offset = this.HEADER_LENGTH + 4;
      view = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset += topicSize;
      topicSize = decoder.decode(buffer.slice(offset, offset + userEventSize));
      offset += userEventSize;
      userEventSize = decoder.decode(buffer.slice(offset, offset + metadataSize));
      buffer = buffer.slice(offset + metadataSize, buffer.byteLength);
      decoder = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(buffer)) : buffer;
      decoder = {type:this.BROADCAST_EVENT, event:topicSize, payload:decoder};
      metadataSize > 0 && (decoder.meta = JSON.parse(userEventSize));
      return {join_ref:null, ref:null, topic:view, event:this.BROADCAST_EVENT, payload:decoder};
    }
    _isArrayBuffer(buffer) {
      var _a;
      return buffer instanceof ArrayBuffer || ((_a = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a === void 0 ? void 0 : _a.name) === "ArrayBuffer";
    }
    _pick(obj, keys) {
      return obj && typeof obj === "object" ? Object.fromEntries(Object.entries(obj).filter(([key]) => keys.includes(key))) : {};
    }
  }
  exports.default = Serializer;
};

//# sourceMappingURL=module$node_modules$$supabase$realtime_js$dist$main$lib$serializer.js.map
