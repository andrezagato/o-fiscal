shadow$provide.module$node_modules$$supabase$postgrest_js$dist$index_cjs = function(require, module, exports) {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
      return typeof o$1;
    } : function(o$1) {
      return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
    }, _typeof(o);
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r$1) {
        return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
      }));
      t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e$jscomp$0) {
    for (var r = 1; r < arguments.length; r++) {
      var t$jscomp$0 = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t$jscomp$0), !0).forEach(function(r$1) {
        var r, t = t$jscomp$0[r$1];
        a: {
          if ("object" == _typeof(r$1) && r$1) {
            var e = r$1[Symbol.toPrimitive];
            if (void 0 !== e) {
              r$1 = e.call(r$1, "string");
              if ("object" != _typeof(r$1)) {
                break a;
              }
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            r$1 = String(r$1);
          }
        }
        (r = "symbol" == _typeof(r$1) ? r$1 : r$1 + "") in e$jscomp$0 ? Object.defineProperty(e$jscomp$0, r, {value:t, enumerable:!0, configurable:!0, writable:!0}) : e$jscomp$0[r] = t;
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$jscomp$0, Object.getOwnPropertyDescriptors(t$jscomp$0)) : ownKeys(Object(t$jscomp$0)).forEach(function(r$1) {
        Object.defineProperty(e$jscomp$0, r$1, Object.getOwnPropertyDescriptor(t$jscomp$0, r$1));
      });
    }
    return e$jscomp$0;
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  var PostgrestError = class extends Error {
    constructor(context) {
      super(context.message);
      this.name = "PostgrestError";
      this.details = context.details;
      this.hint = context.hint;
      this.code = context.code;
    }
  };
  require = class {
    constructor(builder) {
      var _builder$shouldThrowO, _builder$isMaybeSingl, _builder$urlLengthLim;
      this.shouldThrowOnError = !1;
      this.method = builder.method;
      this.url = builder.url;
      this.headers = new Headers(builder.headers);
      this.schema = builder.schema;
      this.body = builder.body;
      this.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : !1;
      this.signal = builder.signal;
      this.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : !1;
      this.urlLengthLimit = (_builder$urlLengthLim = builder.urlLengthLimit) !== null && _builder$urlLengthLim !== void 0 ? _builder$urlLengthLim : 8e3;
      this.fetch = builder.fetch ? builder.fetch : fetch;
    }
    throwOnError() {
      this.shouldThrowOnError = !0;
      return this;
    }
    setHeader(name, value) {
      this.headers = new Headers(this.headers);
      this.headers.set(name, value);
      return this;
    }
    then(onfulfilled, onrejected) {
      var _this = this;
      this.schema !== void 0 && (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema));
      this.method !== "GET" && this.method !== "HEAD" && this.headers.set("Content-Type", "application/json");
      var _fetch = this.fetch;
      _fetch = _fetch(this.url.toString(), {method:this.method, headers:this.headers, body:JSON.stringify(this.body), signal:this.signal}).then(async res$1 => {
        let error = null, data = null, count = null, status = res$1.status, statusText = res$1.statusText;
        if (res$1.ok) {
          var _this$headers$get2, _res$headers$get;
          if (_this.method !== "HEAD") {
            var _this$headers$get, body = await res$1.text();
            body !== "" && (data = _this.headers.get("Accept") === "text/csv" ? body : _this.headers.get("Accept") && ((_this$headers$get = _this.headers.get("Accept")) === null || _this$headers$get === void 0 ? 0 : _this$headers$get.includes("application/vnd.pgrst.plan+text")) ? body : JSON.parse(body));
          }
          _this$headers$get = (_this$headers$get2 = _this.headers.get("Prefer")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);
          res$1 = (_res$headers$get = res$1.headers.get("content-range")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split("/");
          _this$headers$get && res$1 && res$1.length > 1 && (count = parseInt(res$1[1]));
          _this.isMaybeSingle && _this.method === "GET" && Array.isArray(data) && (data.length > 1 ? (error = {code:"PGRST116", details:`Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`, hint:null, message:"JSON object requested, multiple (or no) rows returned"}, count = data = null, status = 406, statusText = "Not Acceptable") : data = data.length === 1 ? data[0] : null);
        } else {
          _res$headers$get = await res$1.text();
          try {
            error = JSON.parse(_res$headers$get), Array.isArray(error) && res$1.status === 404 && (data = [], error = null, status = 200, statusText = "OK");
          } catch (_unused) {
            res$1.status === 404 && _res$headers$get === "" ? (status = 204, statusText = "No Content") : error = {message:_res$headers$get};
          }
          error && _this.isMaybeSingle && (error === null || error === void 0 || (body = error.details) === null || body === void 0 ? 0 : body.includes("0 rows")) && (error = null, status = 200, statusText = "OK");
          if (error && _this.shouldThrowOnError) {
            throw new PostgrestError(error);
          }
        }
        return {error, data, count, status, statusText};
      });
      this.shouldThrowOnError || (_fetch = _fetch.catch(fetchError => {
        var _fetchError$name2, errorDetails;
        let hint = "", code = "";
        const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;
        if (cause) {
          var _cause$message, _fetchError$name, _cause$name, causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : "";
          _cause$message = (errorDetails = cause === null || cause === void 0 ? void 0 : cause.code) !== null && errorDetails !== void 0 ? errorDetails : "";
          errorDetails = `${(_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;
          errorDetails += `\n\nCaused by: ${(_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : "Error"}: ${causeMessage}`;
          _cause$message && (errorDetails += ` (${_cause$message})`);
          if (cause === null || cause === void 0 ? 0 : cause.stack) {
            errorDetails += `\n${cause.stack}`;
          }
        } else {
          errorDetails = (causeMessage = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && causeMessage !== void 0 ? causeMessage : "";
        }
        _fetchError$name = this.url.toString().length;
        if ((fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) === "AbortError" || (fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) === "ABORT_ERR") {
          code = "", hint = "Request was aborted (timeout or manual cancellation)", _fetchError$name > this.urlLengthLimit && (hint += `. Note: Your request URL is ${_fetchError$name} characters, which may exceed server limits. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [many IDs])), consider using an RPC function to pass values server-side.`);
        } else if ((cause === null || cause === void 0 ? void 0 : cause.name) === "HeadersOverflowError" || (cause === null || cause === void 0 ? void 0 : cause.code) === "UND_ERR_HEADERS_OVERFLOW") {
          code = "", hint = "HTTP headers exceeded server limits (typically 16KB)", _fetchError$name > this.urlLengthLimit && (hint += `. Your request URL is ${_fetchError$name} characters. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [200+ IDs])), consider using an RPC function instead.`);
        }
        return {error:{message:`${(_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`, details:errorDetails, hint, code}, data:null, count:null, status:0, statusText:""};
      }));
      return _fetch.then(onfulfilled, onrejected);
    }
    returns() {
      return this;
    }
    overrideTypes() {
      return this;
    }
  };
  module = class extends require {
    select(columns) {
      let quoted = !1;
      columns = (columns !== null && columns !== void 0 ? columns : "*").split("").map(c => {
        if (/\s/.test(c) && !quoted) {
          return "";
        }
        c === '"' && (quoted = !quoted);
        return c;
      }).join("");
      this.url.searchParams.set("select", columns);
      this.headers.append("Prefer", "return\x3drepresentation");
      return this;
    }
    order(column, {ascending = !0, nullsFirst, foreignTable, referencedTable = foreignTable} = {}) {
      foreignTable = referencedTable ? `${referencedTable}.order` : "order";
      referencedTable = this.url.searchParams.get(foreignTable);
      this.url.searchParams.set(foreignTable, `${referencedTable ? `${referencedTable},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
      return this;
    }
    limit(count, {foreignTable, referencedTable = foreignTable} = {}) {
      this.url.searchParams.set(typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`, `${count}`);
      return this;
    }
    range(from, to, {foreignTable, referencedTable = foreignTable} = {}) {
      foreignTable = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
      this.url.searchParams.set(typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`, `${from}`);
      this.url.searchParams.set(foreignTable, `${to - from + 1}`);
      return this;
    }
    abortSignal(signal) {
      this.signal = signal;
      return this;
    }
    single() {
      this.headers.set("Accept", "application/vnd.pgrst.object+json");
      return this;
    }
    maybeSingle() {
      this.method === "GET" ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json");
      this.isMaybeSingle = !0;
      return this;
    }
    csv() {
      this.headers.set("Accept", "text/csv");
      return this;
    }
    geojson() {
      this.headers.set("Accept", "application/geo+json");
      return this;
    }
    explain({analyze = !1, verbose = !1, settings = !1, buffers = !1, wal = !1, format = "text"} = {}) {
      var _this$headers$get;
      analyze = [analyze ? "analyze" : null, verbose ? "verbose" : null, settings ? "settings" : null, buffers ? "buffers" : null, wal ? "wal" : null].filter(Boolean).join("|");
      verbose = (_this$headers$get = this.headers.get("Accept")) !== null && _this$headers$get !== void 0 ? _this$headers$get : "application/json";
      this.headers.set("Accept", `application/vnd.pgrst.plan+${format}; for="${verbose}"; options=${analyze};`);
      return this;
    }
    rollback() {
      this.headers.append("Prefer", "tx\x3drollback");
      return this;
    }
    returns() {
      return this;
    }
    maxAffected(value) {
      this.headers.append("Prefer", "handling\x3dstrict");
      this.headers.append("Prefer", `max-affected=${value}`);
      return this;
    }
  };
  const PostgrestReservedCharsRegexp = RegExp("[,()]");
  var PostgrestFilterBuilder = class extends module {
    eq(column, value) {
      this.url.searchParams.append(column, `eq.${value}`);
      return this;
    }
    neq(column, value) {
      this.url.searchParams.append(column, `neq.${value}`);
      return this;
    }
    gt(column, value) {
      this.url.searchParams.append(column, `gt.${value}`);
      return this;
    }
    gte(column, value) {
      this.url.searchParams.append(column, `gte.${value}`);
      return this;
    }
    lt(column, value) {
      this.url.searchParams.append(column, `lt.${value}`);
      return this;
    }
    lte(column, value) {
      this.url.searchParams.append(column, `lte.${value}`);
      return this;
    }
    like(column, pattern) {
      this.url.searchParams.append(column, `like.${pattern}`);
      return this;
    }
    likeAllOf(column, patterns) {
      this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
      return this;
    }
    likeAnyOf(column, patterns) {
      this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
      return this;
    }
    ilike(column, pattern) {
      this.url.searchParams.append(column, `ilike.${pattern}`);
      return this;
    }
    ilikeAllOf(column, patterns) {
      this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
      return this;
    }
    ilikeAnyOf(column, patterns) {
      this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
      return this;
    }
    regexMatch(column, pattern) {
      this.url.searchParams.append(column, `match.${pattern}`);
      return this;
    }
    regexIMatch(column, pattern) {
      this.url.searchParams.append(column, `imatch.${pattern}`);
      return this;
    }
    is(column, value) {
      this.url.searchParams.append(column, `is.${value}`);
      return this;
    }
    isDistinct(column, value) {
      this.url.searchParams.append(column, `isdistinct.${value}`);
      return this;
    }
    in(column, values) {
      values = Array.from(new Set(values)).map(s => typeof s === "string" && PostgrestReservedCharsRegexp.test(s) ? `"${s}"` : `${s}`).join(",");
      this.url.searchParams.append(column, `in.(${values})`);
      return this;
    }
    notIn(column, values) {
      values = Array.from(new Set(values)).map(s => typeof s === "string" && PostgrestReservedCharsRegexp.test(s) ? `"${s}"` : `${s}`).join(",");
      this.url.searchParams.append(column, `not.in.(${values})`);
      return this;
    }
    contains(column, value) {
      typeof value === "string" ? this.url.searchParams.append(column, `cs.${value}`) : Array.isArray(value) ? this.url.searchParams.append(column, `cs.{${value.join(",")}}`) : this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
      return this;
    }
    containedBy(column, value) {
      typeof value === "string" ? this.url.searchParams.append(column, `cd.${value}`) : Array.isArray(value) ? this.url.searchParams.append(column, `cd.{${value.join(",")}}`) : this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
      return this;
    }
    rangeGt(column, range) {
      this.url.searchParams.append(column, `sr.${range}`);
      return this;
    }
    rangeGte(column, range) {
      this.url.searchParams.append(column, `nxl.${range}`);
      return this;
    }
    rangeLt(column, range) {
      this.url.searchParams.append(column, `sl.${range}`);
      return this;
    }
    rangeLte(column, range) {
      this.url.searchParams.append(column, `nxr.${range}`);
      return this;
    }
    rangeAdjacent(column, range) {
      this.url.searchParams.append(column, `adj.${range}`);
      return this;
    }
    overlaps(column, value) {
      typeof value === "string" ? this.url.searchParams.append(column, `ov.${value}`) : this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
      return this;
    }
    textSearch(column, query, {config, type} = {}) {
      let typePart = "";
      type === "plain" ? typePart = "pl" : type === "phrase" ? typePart = "ph" : type === "websearch" && (typePart = "w");
      this.url.searchParams.append(column, `${typePart}fts${config === void 0 ? "" : `(${config})`}.${query}`);
      return this;
    }
    match(query) {
      Object.entries(query).forEach(([column, value]) => {
        this.url.searchParams.append(column, `eq.${value}`);
      });
      return this;
    }
    not(column, operator, value) {
      this.url.searchParams.append(column, `not.${operator}.${value}`);
      return this;
    }
    or(filters, {foreignTable, referencedTable = foreignTable} = {}) {
      this.url.searchParams.append(referencedTable ? `${referencedTable}.or` : "or", `(${filters})`);
      return this;
    }
    filter(column, operator, value) {
      this.url.searchParams.append(column, `${operator}.${value}`);
      return this;
    }
  }, PostgrestQueryBuilder = class {
    constructor(url, {headers = {}, schema, fetch:fetch$1, urlLengthLimit = 8e3}) {
      this.url = url;
      this.headers = new Headers(headers);
      this.schema = schema;
      this.fetch = fetch$1;
      this.urlLengthLimit = urlLengthLimit;
    }
    cloneRequestState() {
      return {url:new URL(this.url.toString()), headers:new Headers(this.headers)};
    }
    select(columns, options) {
      const {head = !1, count} = options !== null && options !== void 0 ? options : {};
      options = head ? "HEAD" : "GET";
      let quoted = !1;
      columns = (columns !== null && columns !== void 0 ? columns : "*").split("").map(c => {
        if (/\s/.test(c) && !quoted) {
          return "";
        }
        c === '"' && (quoted = !quoted);
        return c;
      }).join("");
      const {url, headers} = this.cloneRequestState();
      url.searchParams.set("select", columns);
      count && headers.append("Prefer", `count=${count}`);
      return new PostgrestFilterBuilder({method:options, url, headers, schema:this.schema, fetch:this.fetch, urlLengthLimit:this.urlLengthLimit});
    }
    insert(values, {count, defaultToNull = !0} = {}) {
      var _this$fetch;
      const {url, headers} = this.cloneRequestState();
      count && headers.append("Prefer", `count=${count}`);
      defaultToNull || headers.append("Prefer", "missing\x3ddefault");
      Array.isArray(values) && (count = values.reduce((acc, x) => acc.concat(Object.keys(x)), []), count.length > 0 && (count = [...(new Set(count))].map(column => `"${column}"`), url.searchParams.set("columns", count.join(","))));
      return new PostgrestFilterBuilder({method:"POST", url, headers, schema:this.schema, body:values, fetch:(_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch, urlLengthLimit:this.urlLengthLimit});
    }
    upsert(values, {onConflict, ignoreDuplicates = !1, count, defaultToNull = !0} = {}) {
      var _this$fetch2;
      const {url, headers} = this.cloneRequestState();
      headers.append("Prefer", `resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`);
      onConflict !== void 0 && url.searchParams.set("on_conflict", onConflict);
      count && headers.append("Prefer", `count=${count}`);
      defaultToNull || headers.append("Prefer", "missing\x3ddefault");
      Array.isArray(values) && (onConflict = values.reduce((acc, x) => acc.concat(Object.keys(x)), []), onConflict.length > 0 && (onConflict = [...(new Set(onConflict))].map(column => `"${column}"`), url.searchParams.set("columns", onConflict.join(","))));
      return new PostgrestFilterBuilder({method:"POST", url, headers, schema:this.schema, body:values, fetch:(_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch, urlLengthLimit:this.urlLengthLimit});
    }
    update(values, {count} = {}) {
      var _this$fetch3;
      const {url, headers} = this.cloneRequestState();
      count && headers.append("Prefer", `count=${count}`);
      return new PostgrestFilterBuilder({method:"PATCH", url, headers, schema:this.schema, body:values, fetch:(_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch, urlLengthLimit:this.urlLengthLimit});
    }
    delete({count} = {}) {
      var _this$fetch4;
      const {url, headers} = this.cloneRequestState();
      count && headers.append("Prefer", `count=${count}`);
      return new PostgrestFilterBuilder({method:"DELETE", url, headers, schema:this.schema, fetch:(_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch, urlLengthLimit:this.urlLengthLimit});
    }
  }, PostgrestClient = class PostgrestClient {
    constructor(url, {headers = {}, schema, fetch:fetch$1, timeout, urlLengthLimit = 8e3} = {}) {
      this.url = url;
      this.headers = new Headers(headers);
      this.schemaName = schema;
      this.urlLengthLimit = urlLengthLimit;
      const originalFetch = fetch$1 !== null && fetch$1 !== void 0 ? fetch$1 : globalThis.fetch;
      this.fetch = timeout !== void 0 && timeout > 0 ? (input, init) => {
        const controller = new AbortController(), timeoutId = setTimeout(() => controller.abort(), timeout), existingSignal = init === null || init === void 0 ? void 0 : init.signal;
        if (existingSignal) {
          if (existingSignal.aborted) {
            return clearTimeout(timeoutId), originalFetch(input, init);
          }
          const abortHandler = () => {
            clearTimeout(timeoutId);
            controller.abort();
          };
          existingSignal.addEventListener("abort", abortHandler, {once:!0});
          return originalFetch(input, _objectSpread2(_objectSpread2({}, init), {}, {signal:controller.signal})).finally(() => {
            clearTimeout(timeoutId);
            existingSignal.removeEventListener("abort", abortHandler);
          });
        }
        return originalFetch(input, _objectSpread2(_objectSpread2({}, init), {}, {signal:controller.signal})).finally(() => clearTimeout(timeoutId));
      } : originalFetch;
    }
    from(relation) {
      if (!relation || typeof relation !== "string" || relation.trim() === "") {
        throw Error("Invalid relation name: relation must be a non-empty string.");
      }
      return new PostgrestQueryBuilder(new URL(`${this.url}/${relation}`), {headers:new Headers(this.headers), schema:this.schemaName, fetch:this.fetch, urlLengthLimit:this.urlLengthLimit});
    }
    schema(schema) {
      return new PostgrestClient(this.url, {headers:this.headers, schema, fetch:this.fetch, urlLengthLimit:this.urlLengthLimit});
    }
    rpc(fn, args = {}, {head = !1, get = !1, count} = {}) {
      var _this$fetch;
      const url = new URL(`${this.url}/rpc/${fn}`);
      let body;
      const _isObject = v => v !== null && typeof v === "object" && (!Array.isArray(v) || v.some(_isObject));
      (fn = head && Object.values(args).some(_isObject)) ? (head = "POST", body = args) : head || get ? (head = head ? "HEAD" : "GET", Object.entries(args).filter(([, value]) => value !== void 0).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name, value]) => {
        url.searchParams.append(name, value);
      })) : (head = "POST", body = args);
      args = new Headers(this.headers);
      fn ? args.set("Prefer", count ? `count=${count},return=minimal` : "return\x3dminimal") : count && args.set("Prefer", `count=${count}`);
      return new PostgrestFilterBuilder({method:head, url, headers:args, schema:this.schemaName, body, fetch:(_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch, urlLengthLimit:this.urlLengthLimit});
    }
  }, src_default = {PostgrestClient, PostgrestQueryBuilder, PostgrestFilterBuilder, PostgrestTransformBuilder:module, PostgrestBuilder:require, PostgrestError};
  exports.PostgrestBuilder = require;
  exports.PostgrestClient = PostgrestClient;
  exports.PostgrestError = PostgrestError;
  exports.PostgrestFilterBuilder = PostgrestFilterBuilder;
  exports.PostgrestQueryBuilder = PostgrestQueryBuilder;
  exports.PostgrestTransformBuilder = module;
  exports.default = src_default;
};

//# sourceMappingURL=module$node_modules$$supabase$postgrest_js$dist$index_cjs.js.map
