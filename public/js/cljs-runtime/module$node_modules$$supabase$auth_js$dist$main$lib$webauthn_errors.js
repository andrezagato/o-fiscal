shadow$provide.module$node_modules$$supabase$auth_js$dist$main$lib$webauthn_errors = function(require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.WebAuthnUnknownError = exports.WebAuthnError = void 0;
  exports.isWebAuthnError = function(error) {
    return typeof error === "object" && error !== null && "__isWebAuthnError" in error;
  };
  exports.identifyRegistrationError = function({error, options}) {
    var _a, _b, _c;
    const {publicKey} = options;
    if (!publicKey) {
      throw Error("options was missing required publicKey property");
    }
    if (error.name === "AbortError") {
      if (options.signal instanceof AbortSignal) {
        return new WebAuthnError({message:"Registration ceremony was sent an abort signal", code:"ERROR_CEREMONY_ABORTED", cause:error});
      }
    } else if (error.name === "ConstraintError") {
      if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === !0) {
        return new WebAuthnError({message:"Discoverable credentials were required but no available authenticator supported it", code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT", cause:error});
      }
      if (options.mediation === "conditional" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === "required") {
        return new WebAuthnError({message:"User verification was required during automatic registration but it could not be performed", code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE", cause:error});
      }
      if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === "required") {
        return new WebAuthnError({message:"User verification was required but no available authenticator supported it", code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT", cause:error});
      }
    } else {
      if (error.name === "InvalidStateError") {
        return new WebAuthnError({message:"The authenticator was previously registered", code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED", cause:error});
      }
      if (error.name === "NotAllowedError") {
        return new WebAuthnError({message:error.message, code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY", cause:error});
      }
      if (error.name === "NotSupportedError") {
        return publicKey.pubKeyCredParams.filter(param => param.type === "public-key").length === 0 ? new WebAuthnError({message:'No entry in pubKeyCredParams was of type "public-key"', code:"ERROR_MALFORMED_PUBKEYCREDPARAMS", cause:error}) : new WebAuthnError({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms", code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG", cause:error});
      }
      if (error.name === "SecurityError") {
        options = window.location.hostname;
        if (!(0,webauthn_1.isValidDomain)(options)) {
          return new WebAuthnError({message:`${window.location.hostname} is an invalid domain`, code:"ERROR_INVALID_DOMAIN", cause:error});
        }
        if (publicKey.rp.id !== options) {
          return new WebAuthnError({message:`The RP ID "${publicKey.rp.id}" is invalid for this domain`, code:"ERROR_INVALID_RP_ID", cause:error});
        }
      } else if (error.name === "TypeError") {
        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
          return new WebAuthnError({message:"User ID was not between 1 and 64 characters", code:"ERROR_INVALID_USER_ID_LENGTH", cause:error});
        }
      } else if (error.name === "UnknownError") {
        return new WebAuthnError({message:"The authenticator was unable to process the specified options, or could not create a new credential", code:"ERROR_AUTHENTICATOR_GENERAL_ERROR", cause:error});
      }
    }
    return new WebAuthnError({message:"a Non-Webauthn related error has occurred", code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY", cause:error});
  };
  exports.identifyAuthenticationError = function({error, options}) {
    const {publicKey} = options;
    if (!publicKey) {
      throw Error("options was missing required publicKey property");
    }
    if (error.name === "AbortError") {
      if (options.signal instanceof AbortSignal) {
        return new WebAuthnError({message:"Authentication ceremony was sent an abort signal", code:"ERROR_CEREMONY_ABORTED", cause:error});
      }
    } else {
      if (error.name === "NotAllowedError") {
        return new WebAuthnError({message:error.message, code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY", cause:error});
      }
      if (error.name === "SecurityError") {
        options = window.location.hostname;
        if (!(0,webauthn_1.isValidDomain)(options)) {
          return new WebAuthnError({message:`${window.location.hostname} is an invalid domain`, code:"ERROR_INVALID_DOMAIN", cause:error});
        }
        if (publicKey.rpId !== options) {
          return new WebAuthnError({message:`The RP ID "${publicKey.rpId}" is invalid for this domain`, code:"ERROR_INVALID_RP_ID", cause:error});
        }
      } else if (error.name === "UnknownError") {
        return new WebAuthnError({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature", code:"ERROR_AUTHENTICATOR_GENERAL_ERROR", cause:error});
      }
    }
    return new WebAuthnError({message:"a Non-Webauthn related error has occurred", code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY", cause:error});
  };
  const webauthn_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$webauthn");
  class WebAuthnError extends Error {
    constructor({message, code, cause, name}) {
      var _a;
      super(message, {cause});
      this.__isWebAuthnError = !0;
      this.name = (_a = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : void 0) !== null && _a !== void 0 ? _a : "Unknown Error";
      this.code = code;
    }
  }
  exports.WebAuthnError = WebAuthnError;
  class WebAuthnUnknownError extends WebAuthnError {
    constructor(message, originalError) {
      super({code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY", cause:originalError, message});
      this.name = "WebAuthnUnknownError";
      this.originalError = originalError;
    }
  }
  exports.WebAuthnUnknownError = WebAuthnUnknownError;
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$lib$webauthn_errors.js.map
