{
"version":3,
"file":"module$node_modules$iceberg_js$dist$index_cjs.js",
"lineCount":213,
"mappings":"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",
"sources":["node_modules/iceberg-js/dist/index.cjs"],
"sourcesContent":["shadow$provide[\"module$node_modules$iceberg_js$dist$index_cjs\"] = function(require,module,exports) {\n'use strict';\n\n// src/errors/IcebergError.ts\nvar IcebergError = class extends Error {\n  constructor(message, opts) {\n    super(message);\n    this.name = \"IcebergError\";\n    this.status = opts.status;\n    this.icebergType = opts.icebergType;\n    this.icebergCode = opts.icebergCode;\n    this.details = opts.details;\n    this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [500, 502, 504].includes(opts.status) && opts.icebergType?.includes(\"CommitState\") === true;\n  }\n  /**\n   * Returns true if the error is a 404 Not Found error.\n   */\n  isNotFound() {\n    return this.status === 404;\n  }\n  /**\n   * Returns true if the error is a 409 Conflict error.\n   */\n  isConflict() {\n    return this.status === 409;\n  }\n  /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */\n  isAuthenticationTimeout() {\n    return this.status === 419;\n  }\n};\n\n// src/utils/url.ts\nfunction buildUrl(baseUrl, path, query) {\n  const url = new URL(path, baseUrl);\n  if (query) {\n    for (const [key, value] of Object.entries(query)) {\n      if (value !== void 0) {\n        url.searchParams.set(key, value);\n      }\n    }\n  }\n  return url.toString();\n}\n\n// src/http/createFetchClient.ts\nasync function buildAuthHeaders(auth) {\n  if (!auth || auth.type === \"none\") {\n    return {};\n  }\n  if (auth.type === \"bearer\") {\n    return { Authorization: `Bearer ${auth.token}` };\n  }\n  if (auth.type === \"header\") {\n    return { [auth.name]: auth.value };\n  }\n  if (auth.type === \"custom\") {\n    return await auth.getHeaders();\n  }\n  return {};\n}\nfunction createFetchClient(options) {\n  const fetchFn = options.fetchImpl ?? globalThis.fetch;\n  return {\n    async request({\n      method,\n      path,\n      query,\n      body,\n      headers\n    }) {\n      const url = buildUrl(options.baseUrl, path, query);\n      const authHeaders = await buildAuthHeaders(options.auth);\n      const res = await fetchFn(url, {\n        method,\n        headers: {\n          ...body ? { \"Content-Type\": \"application/json\" } : {},\n          ...authHeaders,\n          ...headers\n        },\n        body: body ? JSON.stringify(body) : void 0\n      });\n      const text = await res.text();\n      const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\n      const data = isJson && text ? JSON.parse(text) : text;\n      if (!res.ok) {\n        const errBody = isJson ? data : void 0;\n        const errorDetail = errBody?.error;\n        throw new IcebergError(\n          errorDetail?.message ?? `Request failed with status ${res.status}`,\n          {\n            status: res.status,\n            icebergType: errorDetail?.type,\n            icebergCode: errorDetail?.code,\n            details: errBody\n          }\n        );\n      }\n      return { status: res.status, headers: res.headers, data };\n    }\n  };\n}\n\n// src/catalog/namespaces.ts\nfunction namespaceToPath(namespace) {\n  return namespace.join(\"\u001f\");\n}\nvar NamespaceOperations = class {\n  constructor(client, prefix = \"\") {\n    this.client = client;\n    this.prefix = prefix;\n  }\n  async listNamespaces(parent) {\n    const query = parent ? { parent: namespaceToPath(parent.namespace) } : void 0;\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces`,\n      query\n    });\n    return response.data.namespaces.map((ns) => ({ namespace: ns }));\n  }\n  async createNamespace(id, metadata) {\n    const request = {\n      namespace: id.namespace,\n      properties: metadata?.properties\n    };\n    const response = await this.client.request({\n      method: \"POST\",\n      path: `${this.prefix}/namespaces`,\n      body: request\n    });\n    return response.data;\n  }\n  async dropNamespace(id) {\n    await this.client.request({\n      method: \"DELETE\",\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n    });\n  }\n  async loadNamespaceMetadata(id) {\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n    });\n    return {\n      properties: response.data.properties\n    };\n  }\n  async namespaceExists(id) {\n    try {\n      await this.client.request({\n        method: \"HEAD\",\n        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n      });\n      return true;\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false;\n      }\n      throw error;\n    }\n  }\n  async createNamespaceIfNotExists(id, metadata) {\n    try {\n      return await this.createNamespace(id, metadata);\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return;\n      }\n      throw error;\n    }\n  }\n};\n\n// src/catalog/tables.ts\nfunction namespaceToPath2(namespace) {\n  return namespace.join(\"\u001f\");\n}\nvar TableOperations = class {\n  constructor(client, prefix = \"\", accessDelegation) {\n    this.client = client;\n    this.prefix = prefix;\n    this.accessDelegation = accessDelegation;\n  }\n  async listTables(namespace) {\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`\n    });\n    return response.data.identifiers;\n  }\n  async createTable(namespace, request) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    const response = await this.client.request({\n      method: \"POST\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,\n      body: request,\n      headers\n    });\n    return response.data.metadata;\n  }\n  async updateTable(id, request) {\n    const response = await this.client.request({\n      method: \"POST\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n      body: request\n    });\n    return {\n      \"metadata-location\": response.data[\"metadata-location\"],\n      metadata: response.data.metadata\n    };\n  }\n  async dropTable(id, options) {\n    await this.client.request({\n      method: \"DELETE\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n      query: { purgeRequested: String(options?.purge ?? false) }\n    });\n  }\n  async loadTable(id) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n      headers\n    });\n    return response.data.metadata;\n  }\n  async tableExists(id) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    try {\n      await this.client.request({\n        method: \"HEAD\",\n        path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n        headers\n      });\n      return true;\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false;\n      }\n      throw error;\n    }\n  }\n  async createTableIfNotExists(namespace, request) {\n    try {\n      return await this.createTable(namespace, request);\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return await this.loadTable({ namespace: namespace.namespace, name: request.name });\n      }\n      throw error;\n    }\n  }\n};\n\n// src/catalog/IcebergRestCatalog.ts\nvar IcebergRestCatalog = class {\n  /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */\n  constructor(options) {\n    let prefix = \"v1\";\n    if (options.catalogName) {\n      prefix += `/${options.catalogName}`;\n    }\n    const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : `${options.baseUrl}/`;\n    this.client = createFetchClient({\n      baseUrl,\n      auth: options.auth,\n      fetchImpl: options.fetch\n    });\n    this.accessDelegation = options.accessDelegation?.join(\",\");\n    this.namespaceOps = new NamespaceOperations(this.client, prefix);\n    this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\n  }\n  /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */\n  async listNamespaces(parent) {\n    return this.namespaceOps.listNamespaces(parent);\n  }\n  /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */\n  async createNamespace(id, metadata) {\n    return this.namespaceOps.createNamespace(id, metadata);\n  }\n  /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */\n  async dropNamespace(id) {\n    await this.namespaceOps.dropNamespace(id);\n  }\n  /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */\n  async loadNamespaceMetadata(id) {\n    return this.namespaceOps.loadNamespaceMetadata(id);\n  }\n  /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */\n  async listTables(namespace) {\n    return this.tableOps.listTables(namespace);\n  }\n  /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTable(namespace, request) {\n    return this.tableOps.createTable(namespace, request);\n  }\n  /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */\n  async updateTable(id, request) {\n    return this.tableOps.updateTable(id, request);\n  }\n  /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */\n  async dropTable(id, options) {\n    await this.tableOps.dropTable(id, options);\n  }\n  /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */\n  async loadTable(id) {\n    return this.tableOps.loadTable(id);\n  }\n  /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async namespaceExists(id) {\n    return this.namespaceOps.namespaceExists(id);\n  }\n  /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async tableExists(id) {\n    return this.tableOps.tableExists(id);\n  }\n  /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */\n  async createNamespaceIfNotExists(id, metadata) {\n    return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\n  }\n  /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTableIfNotExists(namespace, request) {\n    return this.tableOps.createTableIfNotExists(namespace, request);\n  }\n};\n\n// src/catalog/types.ts\nvar DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\nvar FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;\nfunction parseDecimalType(type) {\n  const match = type.match(DECIMAL_REGEX);\n  if (!match) return null;\n  return {\n    precision: parseInt(match[1], 10),\n    scale: parseInt(match[2], 10)\n  };\n}\nfunction parseFixedType(type) {\n  const match = type.match(FIXED_REGEX);\n  if (!match) return null;\n  return {\n    length: parseInt(match[1], 10)\n  };\n}\nfunction isDecimalType(type) {\n  return DECIMAL_REGEX.test(type);\n}\nfunction isFixedType(type) {\n  return FIXED_REGEX.test(type);\n}\nfunction typesEqual(a, b) {\n  const decimalA = parseDecimalType(a);\n  const decimalB = parseDecimalType(b);\n  if (decimalA && decimalB) {\n    return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\n  }\n  const fixedA = parseFixedType(a);\n  const fixedB = parseFixedType(b);\n  if (fixedA && fixedB) {\n    return fixedA.length === fixedB.length;\n  }\n  return a === b;\n}\nfunction getCurrentSchema(metadata) {\n  return metadata.schemas.find((s) => s[\"schema-id\"] === metadata[\"current-schema-id\"]);\n}\n\nexports.IcebergError = IcebergError;\nexports.IcebergRestCatalog = IcebergRestCatalog;\nexports.getCurrentSchema = getCurrentSchema;\nexports.isDecimalType = isDecimalType;\nexports.isFixedType = isFixedType;\nexports.parseDecimalType = parseDecimalType;\nexports.parseFixedType = parseFixedType;\nexports.typesEqual = typesEqual;\n//# sourceMappingURL=index.cjs.map\n//# sourceMappingURL=index.cjs.map\n};"],
"names":["shadow$provide","require","module","exports","buildAuthHeaders","auth","type","Authorization","token","name","value","getHeaders","createFetchClient","options","fetchFn","fetchImpl","globalThis","fetch","request","method","path","query","body","headers","url","URL","baseUrl","key","Object","entries","searchParams","set","toString","authHeaders","res","JSON","stringify","text","data","isJson","includes","get","parse","ok","errBody","errorDetail","error","IcebergError","message","status","icebergType","icebergCode","code","details","namespaceToPath2","namespace","join","parseDecimalType","match","DECIMAL_REGEX","precision","parseInt","scale","parseFixedType","FIXED_REGEX","length","Error","constructor","opts","isCommitStateUnknown","isNotFound","isConflict","isAuthenticationTimeout","NamespaceOperations","client","prefix","listNamespaces","parent","response","namespaces","map","ns","createNamespace","id","metadata","properties","dropNamespace","loadNamespaceMetadata","namespaceExists","createNamespaceIfNotExists","TableOperations","accessDelegation","listTables","identifiers","createTable","updateTable","dropTable","purgeRequested","String","purge","loadTable","tableExists","createTableIfNotExists","IcebergRestCatalog","catalogName","endsWith","namespaceOps","tableOps","getCurrentSchema","schemas","find","s","isDecimalType","test","isFixedType","typesEqual","a","b","decimalA","decimalB","fixedA","fixedB"]
}
