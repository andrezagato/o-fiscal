shadow$provide.module$node_modules$$supabase$auth_js$dist$main$GoTrueClient = function(require, module, exports) {
  async function lockNoOp(name, acquireTimeout, fn) {
    return await fn();
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  const GoTrueAdminApi_1 = require("module$node_modules$tslib$tslib").__importDefault(require("module$node_modules$$supabase$auth_js$dist$main$GoTrueAdminApi")), constants_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$constants"), errors_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$errors"), fetch_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$fetch"), helpers_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$helpers"), local_storage_1 = 
  require("module$node_modules$$supabase$auth_js$dist$main$lib$local_storage"), locks_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$locks");
  module = require("module$node_modules$$supabase$auth_js$dist$main$lib$polyfills");
  const version_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$version"), base64url_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$base64url"), ethereum_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$web3$ethereum"), webauthn_1 = require("module$node_modules$$supabase$auth_js$dist$main$lib$webauthn");
  (0,module.polyfillGlobalThis)();
  const DEFAULT_OPTIONS = {url:constants_1.GOTRUE_URL, storageKey:constants_1.STORAGE_KEY, autoRefreshToken:!0, persistSession:!0, detectSessionInUrl:!0, headers:constants_1.DEFAULT_HEADERS, flowType:"implicit", debug:!1, hasCustomAuthorizationHeader:!1, throwOnError:!1, lockAcquireTimeout:10000, skipAutoInitialize:!1}, GLOBAL_JWKS = {};
  class GoTrueClient {
    get jwks() {
      var _a, _b;
      return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.jwks) !== null && _b !== void 0 ? _b : {keys:[]};
    }
    set jwks(value) {
      GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {jwks:value});
    }
    get jwks_cached_at() {
      var _a, _b;
      return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
    }
    set jwks_cached_at(value) {
      GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {cachedAt:value});
    }
    constructor(options) {
      var _a, _b, _c;
      this.memoryStorage = this.userStorage = null;
      this.stateChangeEmitters = new Map();
      this.initializePromise = this.refreshingDeferred = this.visibilityChangedCallback = this.autoRefreshTickTimeout = this.autoRefreshTicker = null;
      this.detectSessionInUrl = !0;
      this.lockAcquired = this.suppressGetSessionWarning = this.hasCustomAuthorizationHeader = !1;
      this.pendingInLock = [];
      this.broadcastChannel = null;
      this.logger = console.log;
      options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
      this.storageKey = options.storageKey;
      this.instanceID = (_a = GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a !== void 0 ? _a : 0;
      GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;
      this.logDebugMessages = !!options.debug;
      typeof options.debug === "function" && (this.logger = options.debug);
      this.instanceID > 0 && (0,helpers_1.isBrowser)() && (_a = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`, console.warn(_a), this.logDebugMessages && console.trace(_a));
      this.persistSession = options.persistSession;
      this.autoRefreshToken = options.autoRefreshToken;
      this.admin = new GoTrueAdminApi_1.default({url:options.url, headers:options.headers, fetch:options.fetch});
      this.url = options.url;
      this.headers = options.headers;
      this.fetch = (0,helpers_1.resolveFetch)(options.fetch);
      this.lock = options.lock || lockNoOp;
      this.detectSessionInUrl = options.detectSessionInUrl;
      this.flowType = options.flowType;
      this.hasCustomAuthorizationHeader = options.hasCustomAuthorizationHeader;
      this.throwOnError = options.throwOnError;
      this.lockAcquireTimeout = options.lockAcquireTimeout;
      options.lock ? this.lock = options.lock : this.persistSession && (0,helpers_1.isBrowser)() && ((_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? 0 : _b.locks) ? this.lock = locks_1.navigatorLock : this.lock = lockNoOp;
      this.jwks || (this.jwks = {keys:[]}, this.jwks_cached_at = Number.MIN_SAFE_INTEGER);
      this.mfa = {verify:this._verify.bind(this), enroll:this._enroll.bind(this), unenroll:this._unenroll.bind(this), challenge:this._challenge.bind(this), listFactors:this._listFactors.bind(this), challengeAndVerify:this._challengeAndVerify.bind(this), getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this), webauthn:new webauthn_1.WebAuthnApi(this)};
      this.oauth = {getAuthorizationDetails:this._getAuthorizationDetails.bind(this), approveAuthorization:this._approveAuthorization.bind(this), denyAuthorization:this._denyAuthorization.bind(this), listGrants:this._listOAuthGrants.bind(this), revokeGrant:this._revokeOAuthGrant.bind(this)};
      this.persistSession ? (options.storage ? this.storage = options.storage : (0,helpers_1.supportsLocalStorage)() ? this.storage = globalThis.localStorage : (this.memoryStorage = {}, this.storage = (0,local_storage_1.memoryLocalStorageAdapter)(this.memoryStorage)), options.userStorage && (this.userStorage = options.userStorage)) : (this.memoryStorage = {}, this.storage = (0,local_storage_1.memoryLocalStorageAdapter)(this.memoryStorage));
      if ((0,helpers_1.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
        try {
          this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
        } catch (e) {
          console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
        }
        (_c = this.broadcastChannel) === null || _c === void 0 || _c.addEventListener("message", async event => {
          this._debug("received broadcast notification from other tab or client", event);
          try {
            await this._notifyAllSubscribers(event.data.event, event.data.session, !1);
          } catch (error) {
            this._debug("#broadcastChannel", "error", error);
          }
        });
      }
      options.skipAutoInitialize || this.initialize().catch(error => {
        this._debug("#initialize()", "error", error);
      });
    }
    isThrowOnErrorEnabled() {
      return this.throwOnError;
    }
    _returnResult(result) {
      if (this.throwOnError && result && result.error) {
        throw result.error;
      }
      return result;
    }
    _logPrefix() {
      return "GoTrueClient@" + `${this.storageKey}:${this.instanceID} (${version_1.version}) ${(new Date()).toISOString()}`;
    }
    _debug(...args) {
      this.logDebugMessages && this.logger(this._logPrefix(), ...args);
      return this;
    }
    async initialize() {
      if (this.initializePromise) {
        return await this.initializePromise;
      }
      this.initializePromise = (async() => await this._acquireLock(this.lockAcquireTimeout, async() => await this._initialize()))();
      return await this.initializePromise;
    }
    async _initialize() {
      try {
        let params = {}, callbackUrlType = "none";
        (0,helpers_1.isBrowser)() && (params = (0,helpers_1.parseParametersFromURL)(window.location.href), this._isImplicitGrantCallback(params) ? callbackUrlType = "implicit" : await this._isPKCECallback(params) && (callbackUrlType = "pkce"));
        if ((0,helpers_1.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== "none") {
          const {data, error} = await this._getSessionFromURL(params, callbackUrlType);
          if (error) {
            return this._debug("#_initialize()", "error detecting session from URL", error), (0,errors_1.isAuthImplicitGrantRedirectError)(error), {error};
          }
          const {session, redirectType} = data;
          this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
          await this._saveSession(session);
          setTimeout(async() => {
            redirectType === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", session) : await this._notifyAllSubscribers("SIGNED_IN", session);
          }, 0);
          return {error:null};
        }
        await this._recoverAndRefresh();
        return {error:null};
      } catch (error) {
        return (0,errors_1.isAuthError)(error) ? this._returnResult({error}) : this._returnResult({error:new errors_1.AuthUnknownError("Unexpected error during initialization", error)});
      } finally {
        await this._handleVisibilityChange(), this._debug("#_initialize()", "end");
      }
    }
    async signInAnonymously(credentials) {
      var _a, _b, _c;
      try {
        const res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/signup`, {headers:this.headers, body:{data:(_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {}, gotrue_meta_security:{captcha_token:(_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken}}, xform:fetch_1._sessionResponse}), 
        {data, error} = res;
        if (error || !data) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        const session = data.session, user = data.user;
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", session));
        return this._returnResult({data:{user, session}, error:null});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async signUp(credentials) {
      var _a, _c;
      try {
        let res;
        if ("email" in credentials) {
          const {email, password, options} = credentials;
          var _b = credentials = null;
          this.flowType === "pkce" && ([credentials, _b] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey));
          res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/signup`, {headers:this.headers, redirectTo:options === null || options === void 0 ? void 0 : options.emailRedirectTo, body:{email, password, data:(_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {}, gotrue_meta_security:{captcha_token:options === null || options === void 0 ? void 0 : options.captchaToken}, code_challenge:credentials, code_challenge_method:_b}, xform:fetch_1._sessionResponse});
        } else if ("phone" in credentials) {
          const {phone, password, options} = credentials;
          res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/signup`, {headers:this.headers, body:{phone, password, data:(_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {}, channel:(_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms", gotrue_meta_security:{captcha_token:options === null || options === void 0 ? void 0 : options.captchaToken}}, xform:fetch_1._sessionResponse});
        } else {
          throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const {data, error} = res;
        if (error || !data) {
          return await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`), this._returnResult({data:{user:null, session:null}, error});
        }
        const session = data.session, user = data.user;
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", session));
        return this._returnResult({data:{user, session}, error:null});
      } catch (error) {
        await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async signInWithPassword(credentials) {
      try {
        let res;
        if ("email" in credentials) {
          const {email, password, options} = credentials;
          res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=password`, {headers:this.headers, body:{email, password, gotrue_meta_security:{captcha_token:options === null || options === void 0 ? void 0 : options.captchaToken}}, xform:fetch_1._sessionResponsePassword});
        } else if ("phone" in credentials) {
          const {phone, password, options} = credentials;
          res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=password`, {headers:this.headers, body:{phone, password, gotrue_meta_security:{captcha_token:options === null || options === void 0 ? void 0 : options.captchaToken}}, xform:fetch_1._sessionResponsePassword});
        } else {
          throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const {data, error} = res;
        if (error) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new errors_1.AuthInvalidTokenResponseError();
          return this._returnResult({data:{user:null, session:null}, error:invalidTokenError});
        }
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", data.session));
        return this._returnResult({data:Object.assign({user:data.user, session:data.session}, data.weak_password ? {weakPassword:data.weak_password} : null), error});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async signInWithOAuth(credentials) {
      var _a, _b, _c, _d;
      return await this._handleProviderSignIn(credentials.provider, {redirectTo:(_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo, scopes:(_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes, queryParams:(_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams, skipBrowserRedirect:(_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect});
    }
    async exchangeCodeForSession(authCode) {
      await this.initializePromise;
      return this._acquireLock(this.lockAcquireTimeout, async() => this._exchangeCodeForSession(authCode));
    }
    async signInWithWeb3(credentials) {
      const {chain} = credentials;
      switch(chain) {
        case "ethereum":
          return await this.signInWithEthereum(credentials);
        case "solana":
          return await this.signInWithSolana(credentials);
        default:
          throw Error(`@supabase/auth-js: Unsupported chain "${chain}"`);
      }
    }
    async signInWithEthereum(credentials) {
      var _a, _b, _e, _f, _g, _h, _j, _k, _l;
      if ("message" in credentials) {
        var _c = credentials.message;
        var _d = credentials.signature;
      } else {
        const {wallet, statement, options} = credentials;
        if ((0,helpers_1.isBrowser)()) {
          if (typeof wallet === "object") {
            var resolvedWallet = wallet;
          } else {
            if (resolvedWallet = window, "ethereum" in resolvedWallet && typeof resolvedWallet.ethereum === "object" && "request" in resolvedWallet.ethereum && typeof resolvedWallet.ethereum.request === "function") {
              resolvedWallet = resolvedWallet.ethereum;
            } else {
              throw Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.");
            }
          }
        } else {
          if (typeof wallet !== "object" || options === null || options === void 0 || !options.url) {
            throw Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          }
          resolvedWallet = wallet;
        }
        const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);
        _a = await resolvedWallet.request({method:"eth_requestAccounts"}).then(accs => accs).catch(() => {
          throw Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid");
        });
        if (!_a || _a.length === 0) {
          throw Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");
        }
        _a = (0,ethereum_1.getAddress)(_a[0]);
        let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;
        chainId || (_b = await resolvedWallet.request({method:"eth_chainId"}), chainId = (0,ethereum_1.fromHex)(_b));
        _b = {domain:url.host, address:_a, statement, uri:url.href, version:"1", chainId, nonce:(_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce, issuedAt:(_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : new Date(), expirationTime:(_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === 
        null || _f === void 0 ? void 0 : _f.expirationTime, notBefore:(_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore, requestId:(_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId, resources:(_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources};
        _c = (0,ethereum_1.createSiweMessage)(_b);
        _d = await resolvedWallet.request({method:"personal_sign", params:[(0,ethereum_1.toHex)(_c), _a]});
      }
      try {
        const {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {headers:this.headers, body:Object.assign({chain:"ethereum", message:_c, signature:_d}, ((_k = credentials.options) === null || _k === void 0 ? 0 : _k.captchaToken) ? {gotrue_meta_security:{captcha_token:(_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken}} : null), xform:fetch_1._sessionResponse});
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new errors_1.AuthInvalidTokenResponseError();
          return this._returnResult({data:{user:null, session:null}, error:invalidTokenError});
        }
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", data.session));
        return this._returnResult({data:Object.assign({}, data), error});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async signInWithSolana(credentials) {
      var _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      if ("message" in credentials) {
        var _a = credentials.message;
        var _b = credentials.signature;
      } else {
        const {wallet, statement, options} = credentials;
        if ((0,helpers_1.isBrowser)()) {
          if (typeof wallet === "object") {
            var resolvedWallet = wallet;
          } else {
            if (resolvedWallet = window, "solana" in resolvedWallet && typeof resolvedWallet.solana === "object" && ("signIn" in resolvedWallet.solana && typeof resolvedWallet.solana.signIn === "function" || "signMessage" in resolvedWallet.solana && typeof resolvedWallet.solana.signMessage === "function")) {
              resolvedWallet = resolvedWallet.solana;
            } else {
              throw Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.");
            }
          }
        } else {
          if (typeof wallet !== "object" || options === null || options === void 0 || !options.url) {
            throw Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          }
          resolvedWallet = wallet;
        }
        const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);
        if ("signIn" in resolvedWallet && resolvedWallet.signIn) {
          _b = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({issuedAt:(new Date()).toISOString()}, options === null || options === void 0 ? void 0 : options.signInWithSolana), {version:"1", domain:url.host, uri:url.href}), statement ? {statement} : null));
          if (Array.isArray(_b) && _b[0] && typeof _b[0] === "object") {
            _b = _b[0];
          } else if (!(_b && typeof _b === "object" && "signedMessage" in _b && "signature" in _b)) {
            throw Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
          }
          if ("signedMessage" in _b && "signature" in _b && (typeof _b.signedMessage === "string" || _b.signedMessage instanceof Uint8Array) && _b.signature instanceof Uint8Array) {
            _a = typeof _b.signedMessage === "string" ? _b.signedMessage : (new TextDecoder()).decode(_b.signedMessage), _b = _b.signature;
          } else {
            throw Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");
          }
        } else {
          if (!("signMessage" in resolvedWallet && typeof resolvedWallet.signMessage === "function" && "publicKey" in resolvedWallet && typeof resolvedWallet === "object" && resolvedWallet.publicKey && "toBase58" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== "function") {
            throw Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
          }
          _a = [`${url.host} wants you to sign in with your Solana account:`, resolvedWallet.publicKey.toBase58(), ...(statement ? ["", statement, ""] : [""]), "Version: 1", `URI: ${url.href}`, `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : (new Date()).toISOString()}`, ...(((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || 
          _d === void 0 ? 0 : _d.notBefore) ? [`Not Before: ${options.signInWithSolana.notBefore}`] : []), ...(((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? 0 : _e.expirationTime) ? [`Expiration Time: ${options.signInWithSolana.expirationTime}`] : []), ...(((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? 0 : _f.chainId) ? [`Chain ID: ${options.signInWithSolana.chainId}`] : 
          []), ...(((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? 0 : _g.nonce) ? [`Nonce: ${options.signInWithSolana.nonce}`] : []), ...(((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? 0 : _h.requestId) ? [`Request ID: ${options.signInWithSolana.requestId}`] : []), ...(((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === 
          void 0 ? void 0 : _j.resources) === null || _k === void 0 ? 0 : _k.length) ? ["Resources", ...options.signInWithSolana.resources.map(resource => `- ${resource}`)] : [])].join("\n");
          _b = await resolvedWallet.signMessage((new TextEncoder()).encode(_a), "utf8");
          if (!(_b && _b instanceof Uint8Array)) {
            throw Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
          }
        }
      }
      try {
        const {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {headers:this.headers, body:Object.assign({chain:"solana", message:_a, signature:(0,base64url_1.bytesToBase64URL)(_b)}, ((_l = credentials.options) === null || _l === void 0 ? 0 : _l.captchaToken) ? {gotrue_meta_security:{captcha_token:(_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken}} : null), xform:fetch_1._sessionResponse});
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new errors_1.AuthInvalidTokenResponseError();
          return this._returnResult({data:{user:null, session:null}, error:invalidTokenError});
        }
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", data.session));
        return this._returnResult({data:Object.assign({}, data), error});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async _exchangeCodeForSession(authCode) {
      const storageItem = await (0,helpers_1.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`), [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
      try {
        if (!codeVerifier && this.flowType === "pkce") {
          throw new errors_1.AuthPKCECodeVerifierMissingError();
        }
        const {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {headers:this.headers, body:{auth_code:authCode, code_verifier:codeVerifier}, xform:fetch_1._sessionResponse});
        await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new errors_1.AuthInvalidTokenResponseError();
          return this._returnResult({data:{user:null, session:null, redirectType:null}, error:invalidTokenError});
        }
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", data.session));
        return this._returnResult({data:Object.assign(Object.assign({}, data), {redirectType:redirectType !== null && redirectType !== void 0 ? redirectType : null}), error});
      } catch (error) {
        await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null, redirectType:null}, error});
        }
        throw error;
      }
    }
    async signInWithIdToken(credentials) {
      try {
        const {options, provider, token, access_token, nonce} = credentials, res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {headers:this.headers, body:{provider, id_token:token, access_token, nonce, gotrue_meta_security:{captcha_token:options === null || options === void 0 ? void 0 : options.captchaToken}}, xform:fetch_1._sessionResponse}), {data, error} = res;
        if (error) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new errors_1.AuthInvalidTokenResponseError();
          return this._returnResult({data:{user:null, session:null}, error:invalidTokenError});
        }
        data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("SIGNED_IN", data.session));
        return this._returnResult({data, error});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async signInWithOtp(credentials) {
      var _a, _b, _d, _e;
      try {
        if ("email" in credentials) {
          const {email, options} = credentials;
          var _c = credentials = null;
          this.flowType === "pkce" && ([credentials, _c] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey));
          const {error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/otp`, {headers:this.headers, body:{email, data:(_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {}, create_user:(_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : !0, gotrue_meta_security:{captcha_token:options === null || options === void 0 ? void 0 : options.captchaToken}, code_challenge:credentials, 
          code_challenge_method:_c}, redirectTo:options === null || options === void 0 ? void 0 : options.emailRedirectTo});
          return this._returnResult({data:{user:null, session:null}, error});
        }
        if ("phone" in credentials) {
          const {phone, options} = credentials, {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/otp`, {headers:this.headers, body:{phone, data:(_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {}, create_user:(_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : !0, gotrue_meta_security:{captcha_token:options === null || options === void 0 ? void 0 : options.captchaToken}, 
          channel:(_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"}});
          return this._returnResult({data:{user:null, session:null, messageId:data === null || data === void 0 ? void 0 : data.message_id}, error});
        }
        throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number.");
      } catch (error) {
        await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async verifyOtp(params) {
      var _a, _b;
      try {
        let redirectTo = void 0, captchaToken = void 0;
        "options" in params && (redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo, captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken);
        const {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/verify`, {headers:this.headers, body:Object.assign(Object.assign({}, params), {gotrue_meta_security:{captcha_token:captchaToken}}), redirectTo, xform:fetch_1._sessionResponse});
        if (error) {
          throw error;
        }
        if (!data) {
          throw Error("An error occurred on token verification.");
        }
        const session = data.session, user = data.user;
        if (session === null || session === void 0 ? 0 : session.access_token) {
          await this._saveSession(session), await this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
        }
        return this._returnResult({data:{user, session}, error:null});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async signInWithSSO(params) {
      var _a, _b, _c, _d, _e;
      try {
        let codeChallenge = null, codeChallengeMethod = null;
        this.flowType === "pkce" && ([codeChallenge, codeChallengeMethod] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey));
        const result = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/sso`, {body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? {provider_id:params.providerId} : null), "domain" in params ? {domain:params.domain} : null), {redirect_to:(_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : void 0}), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || 
        _c === void 0 ? 0 : _c.captchaToken) ? {gotrue_meta_security:{captcha_token:params.options.captchaToken}} : null), {skip_http_redirect:!0, code_challenge:codeChallenge, code_challenge_method:codeChallengeMethod}), headers:this.headers, xform:fetch_1._ssoResponse});
        ((_d = result.data) === null || _d === void 0 ? 0 : _d.url) && (0,helpers_1.isBrowser)() && ((_e = params.options) === null || _e === void 0 || !_e.skipBrowserRedirect) && window.location.assign(result.data.url);
        return this._returnResult(result);
      } catch (error) {
        await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async reauthenticate() {
      await this.initializePromise;
      return await this._acquireLock(this.lockAcquireTimeout, async() => await this._reauthenticate());
    }
    async _reauthenticate() {
      try {
        return await this._useSession(async result => {
          const {data:{session}, error:sessionError} = result;
          if (sessionError) {
            throw sessionError;
          }
          if (!session) {
            throw new errors_1.AuthSessionMissingError();
          }
          ({error:result} = await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/reauthenticate`, {headers:this.headers, jwt:session.access_token}));
          return this._returnResult({data:{user:null, session:null}, error:result});
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async resend(credentials) {
      try {
        const endpoint = `${this.url}/resend`;
        if ("email" in credentials) {
          const {email, type, options} = credentials, {error} = await (0,fetch_1._request)(this.fetch, "POST", endpoint, {headers:this.headers, body:{email, type, gotrue_meta_security:{captcha_token:options === null || options === void 0 ? void 0 : options.captchaToken}}, redirectTo:options === null || options === void 0 ? void 0 : options.emailRedirectTo});
          return this._returnResult({data:{user:null, session:null}, error});
        }
        if ("phone" in credentials) {
          const {phone, type, options} = credentials, {data, error} = await (0,fetch_1._request)(this.fetch, "POST", endpoint, {headers:this.headers, body:{phone, type, gotrue_meta_security:{captcha_token:options === null || options === void 0 ? void 0 : options.captchaToken}}});
          return this._returnResult({data:{user:null, session:null, messageId:data === null || data === void 0 ? void 0 : data.message_id}, error});
        }
        throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async getSession() {
      await this.initializePromise;
      return await this._acquireLock(this.lockAcquireTimeout, async() => this._useSession(async result => result));
    }
    async _acquireLock(acquireTimeout, fn) {
      this._debug("#_acquireLock", "begin", acquireTimeout);
      try {
        if (this.lockAcquired) {
          const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(), result = (async() => {
            await last;
            return await fn();
          })();
          this.pendingInLock.push((async() => {
            try {
              await result;
            } catch (e) {
            }
          })());
          return result;
        }
        return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async() => {
          this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
          try {
            this.lockAcquired = !0;
            const result = fn();
            this.pendingInLock.push((async() => {
              try {
                await result;
              } catch (e) {
              }
            })());
            for (await result; this.pendingInLock.length;) {
              const waitOn = [...this.pendingInLock];
              await Promise.all(waitOn);
              this.pendingInLock.splice(0, waitOn.length);
            }
            return await result;
          } finally {
            this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1;
          }
        });
      } finally {
        this._debug("#_acquireLock", "end");
      }
    }
    async _useSession(fn) {
      this._debug("#_useSession", "begin");
      try {
        const result = await this.__loadSession();
        return await fn(result);
      } finally {
        this._debug("#_useSession", "end");
      }
    }
    async __loadSession() {
      this._debug("#__loadSession()", "begin");
      this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", Error().stack);
      try {
        let currentSession = null;
        const maybeSession = await (0,helpers_1.getItemAsync)(this.storage, this.storageKey);
        this._debug("#getSession()", "session from storage", maybeSession);
        maybeSession !== null && (this._isValidSession(maybeSession) ? currentSession = maybeSession : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession()));
        if (!currentSession) {
          return {data:{session:null}, error:null};
        }
        const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < constants_1.EXPIRY_MARGIN_MS : !1;
        this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
        if (!hasExpired) {
          if (this.userStorage) {
            const maybeUser = await (0,helpers_1.getItemAsync)(this.userStorage, this.storageKey + "-user");
            currentSession.user = (maybeUser === null || maybeUser === void 0 ? 0 : maybeUser.user) ? maybeUser.user : (0,helpers_1.userNotAvailableProxy)();
          }
          if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {
            const suppressWarningRef = {value:this.suppressGetSessionWarning};
            currentSession.user = (0,helpers_1.insecureUserWarningProxy)(currentSession.user, suppressWarningRef);
            suppressWarningRef.value && (this.suppressGetSessionWarning = !0);
          }
          return {data:{session:currentSession}, error:null};
        }
        const {data:session, error} = await this._callRefreshToken(currentSession.refresh_token);
        return error ? this._returnResult({data:{session:null}, error}) : this._returnResult({data:{session}, error:null});
      } finally {
        this._debug("#__loadSession()", "end");
      }
    }
    async getUser(jwt) {
      if (jwt) {
        return await this._getUser(jwt);
      }
      await this.initializePromise;
      jwt = await this._acquireLock(this.lockAcquireTimeout, async() => await this._getUser());
      jwt.data.user && (this.suppressGetSessionWarning = !0);
      return jwt;
    }
    async _getUser(jwt) {
      try {
        return jwt ? await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/user`, {headers:this.headers, jwt, xform:fetch_1._userResponse}) : await this._useSession(async result => {
          var _a, _b, _c;
          const {data, error} = result;
          if (error) {
            throw error;
          }
          return (_a = data.session) !== null && _a !== void 0 && _a.access_token || this.hasCustomAuthorizationHeader ? await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/user`, {headers:this.headers, jwt:(_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0, xform:fetch_1._userResponse}) : {data:{user:null}, error:new errors_1.AuthSessionMissingError()};
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return (0,errors_1.isAuthSessionMissingError)(error) && (await this._removeSession(), await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`)), this._returnResult({data:{user:null}, error});
        }
        throw error;
      }
    }
    async updateUser(attributes, options = {}) {
      await this.initializePromise;
      return await this._acquireLock(this.lockAcquireTimeout, async() => await this._updateUser(attributes, options));
    }
    async _updateUser(attributes, options = {}) {
      try {
        return await this._useSession(async result => {
          const {data:sessionData, error:sessionError} = result;
          if (sessionError) {
            throw sessionError;
          }
          if (!sessionData.session) {
            throw new errors_1.AuthSessionMissingError();
          }
          result = sessionData.session;
          let codeChallenge = null, codeChallengeMethod = null;
          this.flowType === "pkce" && attributes.email != null && ([codeChallenge, codeChallengeMethod] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey));
          const {data, error:userError} = await (0,fetch_1._request)(this.fetch, "PUT", `${this.url}/user`, {headers:this.headers, redirectTo:options === null || options === void 0 ? void 0 : options.emailRedirectTo, body:Object.assign(Object.assign({}, attributes), {code_challenge:codeChallenge, code_challenge_method:codeChallengeMethod}), jwt:result.access_token, xform:fetch_1._userResponse});
          if (userError) {
            throw userError;
          }
          result.user = data.user;
          await this._saveSession(result);
          await this._notifyAllSubscribers("USER_UPDATED", result);
          return this._returnResult({data:{user:result.user}, error:null});
        });
      } catch (error) {
        await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null}, error});
        }
        throw error;
      }
    }
    async setSession(currentSession) {
      await this.initializePromise;
      return await this._acquireLock(this.lockAcquireTimeout, async() => await this._setSession(currentSession));
    }
    async _setSession(currentSession) {
      try {
        if (!currentSession.access_token || !currentSession.refresh_token) {
          throw new errors_1.AuthSessionMissingError();
        }
        const timeNow = Date.now() / 1000;
        let expiresAt = timeNow, hasExpired = !0, session = null;
        const {payload} = (0,helpers_1.decodeJWT)(currentSession.access_token);
        payload.exp && (expiresAt = payload.exp, hasExpired = expiresAt <= timeNow);
        if (hasExpired) {
          const {data:refreshedSession, error} = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            return this._returnResult({data:{user:null, session:null}, error});
          }
          if (!refreshedSession) {
            return {data:{user:null, session:null}, error:null};
          }
          session = refreshedSession;
        } else {
          const {data, error} = await this._getUser(currentSession.access_token);
          if (error) {
            return this._returnResult({data:{user:null, session:null}, error});
          }
          session = {access_token:currentSession.access_token, refresh_token:currentSession.refresh_token, user:data.user, token_type:"bearer", expires_in:expiresAt - timeNow, expires_at:expiresAt};
          await this._saveSession(session);
          await this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return this._returnResult({data:{user:session.user, session}, error:null});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{session:null, user:null}, error});
        }
        throw error;
      }
    }
    async refreshSession(currentSession) {
      await this.initializePromise;
      return await this._acquireLock(this.lockAcquireTimeout, async() => await this._refreshSession(currentSession));
    }
    async _refreshSession(currentSession) {
      try {
        return await this._useSession(async result => {
          var _a;
          if (!currentSession) {
            const {data, error} = result;
            if (error) {
              throw error;
            }
            currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : void 0;
          }
          if (currentSession === null || currentSession === void 0 || !currentSession.refresh_token) {
            throw new errors_1.AuthSessionMissingError();
          }
          const {data:session, error} = await this._callRefreshToken(currentSession.refresh_token);
          return error ? this._returnResult({data:{user:null, session:null}, error}) : session ? this._returnResult({data:{user:session.user, session}, error:null}) : this._returnResult({data:{user:null, session:null}, error:null});
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{user:null, session:null}, error});
        }
        throw error;
      }
    }
    async _getSessionFromURL(params, callbackUrlType) {
      try {
        if (!(0,helpers_1.isBrowser)()) {
          throw new errors_1.AuthImplicitGrantRedirectError("No browser detected.");
        }
        if (params.error || params.error_description || params.error_code) {
          throw new errors_1.AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {error:params.error || "unspecified_error", code:params.error_code || "unspecified_code"});
        }
        switch(callbackUrlType) {
          case "implicit":
            if (this.flowType === "pkce") {
              throw new errors_1.AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
            }
            break;
          case "pkce":
            if (this.flowType === "implicit") {
              throw new errors_1.AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
            }
        }
        if (callbackUrlType === "pkce") {
          this._debug("#_initialize()", "begin", "is PKCE flow", !0);
          if (!params.code) {
            throw new errors_1.AuthPKCEGrantCodeExchangeError("No code detected.");
          }
          const {data, error} = await this._exchangeCodeForSession(params.code);
          if (error) {
            throw error;
          }
          var url = new URL(window.location.href);
          url.searchParams.delete("code");
          window.history.replaceState(window.history.state, "", url.toString());
          return {data:{session:data.session, redirectType:null}, error:null};
        }
        const {provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type} = params;
        if (!(access_token && expires_in && refresh_token && token_type)) {
          throw new errors_1.AuthImplicitGrantRedirectError("No session defined in URL");
        }
        const timeNow = Math.round(Date.now() / 1000), expiresIn = parseInt(expires_in);
        callbackUrlType = timeNow + expiresIn;
        expires_at && (callbackUrlType = parseInt(expires_at));
        url = callbackUrlType - timeNow;
        url * 1000 <= constants_1.AUTO_REFRESH_TICK_DURATION_MS && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${url}s, should have been closer to ${expiresIn}s`);
        url = callbackUrlType - expiresIn;
        timeNow - url >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", url, callbackUrlType, timeNow) : timeNow - url < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", url, callbackUrlType, timeNow);
        const {data, error} = await this._getUser(access_token);
        if (error) {
          throw error;
        }
        const session = {provider_token, provider_refresh_token, access_token, expires_in:expiresIn, expires_at:callbackUrlType, refresh_token, token_type, user:data.user};
        window.location.hash = "";
        this._debug("#_getSessionFromURL()", "clearing window.location.hash");
        return this._returnResult({data:{session, redirectType:params.type}, error:null});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{session:null, redirectType:null}, error});
        }
        throw error;
      }
    }
    _isImplicitGrantCallback(params) {
      return typeof this.detectSessionInUrl === "function" ? this.detectSessionInUrl(new URL(window.location.href), params) : !(!params.access_token && !params.error_description);
    }
    async _isPKCECallback(params) {
      const currentStorageContent = await (0,helpers_1.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
      return !(!params.code || !currentStorageContent);
    }
    async signOut(options = {scope:"global"}) {
      await this.initializePromise;
      return await this._acquireLock(this.lockAcquireTimeout, async() => await this._signOut(options));
    }
    async _signOut({scope} = {scope:"global"}) {
      return await this._useSession(async result => {
        var _a;
        const {data, error:sessionError} = result;
        if (sessionError && !(0,errors_1.isAuthSessionMissingError)(sessionError)) {
          return this._returnResult({error:sessionError});
        }
        if (result = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) {
          if ({error:_a} = await this.admin.signOut(result, scope), _a && (!(0,errors_1.isAuthApiError)(_a) || _a.status !== 404 && _a.status !== 401 && _a.status !== 403) && !(0,errors_1.isAuthSessionMissingError)(_a)) {
            return this._returnResult({error:_a});
          }
        }
        scope !== "others" && (await this._removeSession(), await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`));
        return this._returnResult({error:null});
      });
    }
    onAuthStateChange(callback) {
      const id = (0,helpers_1.generateCallbackId)();
      callback = {id, callback, unsubscribe:() => {
        this._debug("#unsubscribe()", "state change callback with id removed", id);
        this.stateChangeEmitters.delete(id);
      }};
      this._debug("#onAuthStateChange()", "registered callback with id", id);
      this.stateChangeEmitters.set(id, callback);
      (async() => {
        await this.initializePromise;
        await this._acquireLock(this.lockAcquireTimeout, async() => {
          this._emitInitialSession(id);
        });
      })();
      return {data:{subscription:callback}};
    }
    async _emitInitialSession(id) {
      return await this._useSession(async result => {
        var _a, _b;
        try {
          const {data:{session}, error} = result;
          if (error) {
            throw error;
          }
          await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback("INITIAL_SESSION", session));
          this._debug("INITIAL_SESSION", "callback id", id, "session", session);
        } catch (err) {
          await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", id, "error", err), console.error(err);
        }
      });
    }
    async resetPasswordForEmail(email, options = {}) {
      let codeChallenge = null, codeChallengeMethod = null;
      this.flowType === "pkce" && ([codeChallenge, codeChallengeMethod] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey, !0));
      try {
        return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/recover`, {body:{email, code_challenge:codeChallenge, code_challenge_method:codeChallengeMethod, gotrue_meta_security:{captcha_token:options.captchaToken}}, headers:this.headers, redirectTo:options.redirectTo});
      } catch (error) {
        await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async getUserIdentities() {
      var _a;
      try {
        const {data, error} = await this.getUser();
        if (error) {
          throw error;
        }
        return this._returnResult({data:{identities:(_a = data.user.identities) !== null && _a !== void 0 ? _a : []}, error:null});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async linkIdentity(credentials) {
      return "token" in credentials ? this.linkIdentityIdToken(credentials) : this.linkIdentityOAuth(credentials);
    }
    async linkIdentityOAuth(credentials) {
      var _a;
      try {
        const {data, error} = await this._useSession(async result => {
          var _a, _b, _c, _d, _e;
          const {data, error} = result;
          if (error) {
            throw error;
          }
          result = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {redirectTo:(_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo, scopes:(_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes, queryParams:(_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams, skipBrowserRedirect:!0});
          return await (0,fetch_1._request)(this.fetch, "GET", result, {headers:this.headers, jwt:(_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : void 0});
        });
        if (error) {
          throw error;
        }
        !(0,helpers_1.isBrowser)() || ((_a = credentials.options) === null || _a === void 0 ? 0 : _a.skipBrowserRedirect) || window.location.assign(data === null || data === void 0 ? void 0 : data.url);
        return this._returnResult({data:{provider:credentials.provider, url:data === null || data === void 0 ? void 0 : data.url}, error:null});
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{provider:credentials.provider, url:null}, error});
        }
        throw error;
      }
    }
    async linkIdentityIdToken(credentials) {
      return await this._useSession(async result => {
        var _a;
        try {
          const {error:sessionError, data:{session}} = result;
          if (sessionError) {
            throw sessionError;
          }
          const {options, provider, token, access_token, nonce} = credentials, res = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {headers:this.headers, jwt:(_a = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a !== void 0 ? _a : void 0, body:{provider, id_token:token, access_token, nonce, link_identity:!0, gotrue_meta_security:{captcha_token:options === null || options === void 0 ? void 0 : options.captchaToken}}, xform:fetch_1._sessionResponse}), 
          {data, error} = res;
          if (error) {
            return this._returnResult({data:{user:null, session:null}, error});
          }
          if (!data || !data.session || !data.user) {
            return this._returnResult({data:{user:null, session:null}, error:new errors_1.AuthInvalidTokenResponseError()});
          }
          data.session && (await this._saveSession(data.session), await this._notifyAllSubscribers("USER_UPDATED", data.session));
          return this._returnResult({data, error});
        } catch (error) {
          await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
          if ((0,errors_1.isAuthError)(error)) {
            return this._returnResult({data:{user:null, session:null}, error});
          }
          throw error;
        }
      });
    }
    async unlinkIdentity(identity) {
      try {
        return await this._useSession(async result => {
          var _a, _b;
          const {data, error} = result;
          if (error) {
            throw error;
          }
          return await (0,fetch_1._request)(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {headers:this.headers, jwt:(_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : void 0});
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async _refreshAccessToken(refreshToken) {
      const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        const startedAt = Date.now();
        return await (0,helpers_1.retryable)(async attempt => {
          attempt > 0 && await (0,helpers_1.sleep)(200 * Math.pow(2, attempt - 1));
          this._debug(debugName, "refreshing attempt", attempt);
          return await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {body:{refresh_token:refreshToken}, headers:this.headers, xform:fetch_1._sessionResponse});
        }, (attempt, error) => {
          attempt = 200 * Math.pow(2, attempt);
          return error && (0,errors_1.isAuthRetryableFetchError)(error) && Date.now() + attempt - startedAt < constants_1.AUTO_REFRESH_TICK_DURATION_MS;
        });
      } catch (error) {
        this._debug(debugName, "error", error);
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:{session:null, user:null}, error});
        }
        throw error;
      } finally {
        this._debug(debugName, "end");
      }
    }
    _isValidSession(maybeSession) {
      return typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    }
    async _handleProviderSignIn(provider, options) {
      const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {redirectTo:options.redirectTo, scopes:options.scopes, queryParams:options.queryParams});
      this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
      (0,helpers_1.isBrowser)() && !options.skipBrowserRedirect && window.location.assign(url);
      return {data:{provider, url}, error:null};
    }
    async _recoverAndRefresh() {
      var _a, _b;
      this._debug("#_recoverAndRefresh()", "begin");
      try {
        const currentSession = await (0,helpers_1.getItemAsync)(this.storage, this.storageKey);
        if (currentSession && this.userStorage) {
          let maybeUser = await (0,helpers_1.getItemAsync)(this.userStorage, this.storageKey + "-user");
          this.storage.isServer || !Object.is(this.storage, this.userStorage) || maybeUser || (maybeUser = {user:currentSession.user}, await (0,helpers_1.setItemAsync)(this.userStorage, this.storageKey + "-user", maybeUser));
          currentSession.user = (_a = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a !== void 0 ? _a : (0,helpers_1.userNotAvailableProxy)();
        } else if (currentSession && !currentSession.user && !currentSession.user) {
          const separateUser = await (0,helpers_1.getItemAsync)(this.storage, this.storageKey + "-user");
          separateUser && (separateUser === null || separateUser === void 0 ? 0 : separateUser.user) ? (currentSession.user = separateUser.user, await (0,helpers_1.removeItemAsync)(this.storage, this.storageKey + "-user"), await (0,helpers_1.setItemAsync)(this.storage, this.storageKey, currentSession)) : currentSession.user = (0,helpers_1.userNotAvailableProxy)();
        }
        this._debug("#_recoverAndRefresh()", "session from storage", currentSession);
        if (this._isValidSession(currentSession)) {
          var expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1000 - Date.now() < constants_1.EXPIRY_MARGIN_MS;
          this._debug("#_recoverAndRefresh()", `session has${expiresWithMargin ? "" : " not"} expired with margin of ${constants_1.EXPIRY_MARGIN_MS}s`);
          if (expiresWithMargin) {
            if (this.autoRefreshToken && currentSession.refresh_token) {
              const {error} = await this._callRefreshToken(currentSession.refresh_token);
              error && (console.error(error), (0,errors_1.isAuthRetryableFetchError)(error) || (this._debug("#_recoverAndRefresh()", "refresh failed with a non-retryable error, removing the session", error), await this._removeSession()));
            }
          } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === !0) {
            try {
              const {data, error:userError} = await this._getUser(currentSession.access_token);
              !userError && (data === null || data === void 0 ? 0 : data.user) ? (currentSession.user = data.user, await this._saveSession(currentSession), await this._notifyAllSubscribers("SIGNED_IN", currentSession)) : this._debug("#_recoverAndRefresh()", "could not get user data, skipping SIGNED_IN notification");
            } catch (getUserError) {
              console.error("Error getting user data:", getUserError), this._debug("#_recoverAndRefresh()", "error getting user data, skipping SIGNED_IN notification", getUserError);
            }
          } else {
            await this._notifyAllSubscribers("SIGNED_IN", currentSession);
          }
        } else {
          this._debug("#_recoverAndRefresh()", "session is not valid"), currentSession !== null && await this._removeSession();
        }
      } catch (err) {
        this._debug("#_recoverAndRefresh()", "error", err), console.error(err);
      } finally {
        this._debug("#_recoverAndRefresh()", "end");
      }
    }
    async _callRefreshToken(refreshToken) {
      var _a, _b;
      if (!refreshToken) {
        throw new errors_1.AuthSessionMissingError();
      }
      if (this.refreshingDeferred) {
        return this.refreshingDeferred.promise;
      }
      const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        this.refreshingDeferred = new helpers_1.Deferred();
        const {data, error} = await this._refreshAccessToken(refreshToken);
        if (error) {
          throw error;
        }
        if (!data.session) {
          throw new errors_1.AuthSessionMissingError();
        }
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
        const result = {data:data.session, error:null};
        this.refreshingDeferred.resolve(result);
        return result;
      } catch (error) {
        this._debug(debugName, "error", error);
        if ((0,errors_1.isAuthError)(error)) {
          return refreshToken = {data:null, error}, (0,errors_1.isAuthRetryableFetchError)(error) || await this._removeSession(), (_a = this.refreshingDeferred) === null || _a === void 0 || _a.resolve(refreshToken), refreshToken;
        }
        (_b = this.refreshingDeferred) === null || _b === void 0 || _b.reject(error);
        throw error;
      } finally {
        this.refreshingDeferred = null, this._debug(debugName, "end");
      }
    }
    async _notifyAllSubscribers(event, session, broadcast = !0) {
      const debugName = `#_notifyAllSubscribers(${event})`;
      this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
      try {
        this.broadcastChannel && broadcast && this.broadcastChannel.postMessage({event, session});
        const errors = [], promises = Array.from(this.stateChangeEmitters.values()).map(async x => {
          try {
            await x.callback(event, session);
          } catch (e) {
            errors.push(e);
          }
        });
        await Promise.all(promises);
        if (errors.length > 0) {
          for (broadcast = 0; broadcast < errors.length; broadcast += 1) {
            console.error(errors[broadcast]);
          }
          throw errors[0];
        }
      } finally {
        this._debug(debugName, "end");
      }
    }
    async _saveSession(session) {
      this._debug("#_saveSession()", session);
      this.suppressGetSessionWarning = !0;
      await (0,helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
      session = Object.assign({}, session);
      const userIsProxy = session.user && session.user.__isUserNotAvailableProxy === !0;
      this.userStorage ? (!userIsProxy && session.user && await (0,helpers_1.setItemAsync)(this.userStorage, this.storageKey + "-user", {user:session.user}), session = Object.assign({}, session), delete session.user, session = (0,helpers_1.deepClone)(session), await (0,helpers_1.setItemAsync)(this.storage, this.storageKey, session)) : (session = (0,helpers_1.deepClone)(session), await (0,helpers_1.setItemAsync)(this.storage, this.storageKey, session));
    }
    async _removeSession() {
      this._debug("#_removeSession()");
      this.suppressGetSessionWarning = !1;
      await (0,helpers_1.removeItemAsync)(this.storage, this.storageKey);
      await (0,helpers_1.removeItemAsync)(this.storage, this.storageKey + "-code-verifier");
      await (0,helpers_1.removeItemAsync)(this.storage, this.storageKey + "-user");
      this.userStorage && await (0,helpers_1.removeItemAsync)(this.userStorage, this.storageKey + "-user");
      await this._notifyAllSubscribers("SIGNED_OUT", null);
    }
    _removeVisibilityChangedCallback() {
      this._debug("#_removeVisibilityChangedCallback()");
      const callback = this.visibilityChangedCallback;
      this.visibilityChangedCallback = null;
      try {
        callback && (0,helpers_1.isBrowser)() && (window === null || window === void 0 ? 0 : window.removeEventListener) && window.removeEventListener("visibilitychange", callback);
      } catch (e) {
        console.error("removing visibilitychange callback failed", e);
      }
    }
    async _startAutoRefresh() {
      await this._stopAutoRefresh();
      this._debug("#_startAutoRefresh()");
      var ticker = setInterval(() => this._autoRefreshTokenTick(), constants_1.AUTO_REFRESH_TICK_DURATION_MS);
      (this.autoRefreshTicker = ticker) && typeof ticker === "object" && typeof ticker.unref === "function" ? ticker.unref() : typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function" && Deno.unrefTimer(ticker);
      (this.autoRefreshTickTimeout = ticker = setTimeout(async() => {
        await this.initializePromise;
        await this._autoRefreshTokenTick();
      }, 0)) && typeof ticker === "object" && typeof ticker.unref === "function" ? ticker.unref() : typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function" && Deno.unrefTimer(ticker);
    }
    async _stopAutoRefresh() {
      this._debug("#_stopAutoRefresh()");
      var ticker = this.autoRefreshTicker;
      this.autoRefreshTicker = null;
      ticker && clearInterval(ticker);
      ticker = this.autoRefreshTickTimeout;
      this.autoRefreshTickTimeout = null;
      ticker && clearTimeout(ticker);
    }
    async startAutoRefresh() {
      this._removeVisibilityChangedCallback();
      await this._startAutoRefresh();
    }
    async stopAutoRefresh() {
      this._removeVisibilityChangedCallback();
      await this._stopAutoRefresh();
    }
    async _autoRefreshTokenTick() {
      this._debug("#_autoRefreshTokenTick()", "begin");
      try {
        await this._acquireLock(0, async() => {
          try {
            const now = Date.now();
            try {
              return await this._useSession(async result => {
                ({data:{session:result}} = result);
                if (result && result.refresh_token && result.expires_at) {
                  var expiresInTicks = Math.floor((result.expires_at * 1000 - now) / constants_1.AUTO_REFRESH_TICK_DURATION_MS);
                  this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${constants_1.AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${constants_1.AUTO_REFRESH_TICK_THRESHOLD} ticks`);
                  expiresInTicks <= constants_1.AUTO_REFRESH_TICK_THRESHOLD && await this._callRefreshToken(result.refresh_token);
                } else {
                  this._debug("#_autoRefreshTokenTick()", "no session");
                }
              });
            } catch (e) {
              console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
            }
          } finally {
            this._debug("#_autoRefreshTokenTick()", "end");
          }
        });
      } catch (e) {
        if (e.isAcquireTimeout || e instanceof locks_1.LockAcquireTimeoutError) {
          this._debug("auto refresh token tick lock not available");
        } else {
          throw e;
        }
      }
    }
    async _handleVisibilityChange() {
      this._debug("#_handleVisibilityChange()");
      if (!(0,helpers_1.isBrowser)() || window === null || window === void 0 || !window.addEventListener) {
        return this.autoRefreshToken && this.startAutoRefresh(), !1;
      }
      try {
        this.visibilityChangedCallback = async() => {
          try {
            await this._onVisibilityChanged(!1);
          } catch (error) {
            this._debug("#visibilityChangedCallback", "error", error);
          }
        }, window === null || window === void 0 || window.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0);
      } catch (error) {
        console.error("_handleVisibilityChange", error);
      }
    }
    async _onVisibilityChanged(calledFromInitialize) {
      const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
      this._debug(methodName, "visibilityState", document.visibilityState);
      document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(), calledFromInitialize || (await this.initializePromise, await this._acquireLock(this.lockAcquireTimeout, async() => {
        document.visibilityState !== "visible" ? this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting") : await this._recoverAndRefresh();
      }))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh();
    }
    async _getUrlForProvider(url, provider, options) {
      provider = [`provider=${encodeURIComponent(provider)}`];
      (options === null || options === void 0 ? 0 : options.redirectTo) && provider.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
      (options === null || options === void 0 ? 0 : options.scopes) && provider.push(`scopes=${encodeURIComponent(options.scopes)}`);
      if (this.flowType === "pkce") {
        const [codeChallenge, codeChallengeMethod] = await (0,helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);
        var flowParams = new URLSearchParams({code_challenge:`${encodeURIComponent(codeChallenge)}`, code_challenge_method:`${encodeURIComponent(codeChallengeMethod)}`});
        provider.push(flowParams.toString());
      }
      if (options === null || options === void 0 ? 0 : options.queryParams) {
        flowParams = new URLSearchParams(options.queryParams), provider.push(flowParams.toString());
      }
      (options === null || options === void 0 ? 0 : options.skipBrowserRedirect) && provider.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
      return `${url}?${provider.join("\x26")}`;
    }
    async _unenroll(params) {
      try {
        return await this._useSession(async result => {
          var _a;
          const {data:sessionData, error:sessionError} = result;
          return sessionError ? this._returnResult({data:null, error:sessionError}) : await (0,fetch_1._request)(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {headers:this.headers, jwt:(_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token});
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async _enroll(params) {
      try {
        return await this._useSession(async result => {
          var _a, _b;
          const {data:sessionData, error:sessionError} = result;
          if (sessionError) {
            return this._returnResult({data:null, error:sessionError});
          }
          result = Object.assign({friendly_name:params.friendlyName, factor_type:params.factorType}, params.factorType === "phone" ? {phone:params.phone} : params.factorType === "totp" ? {issuer:params.issuer} : {});
          const {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/factors`, {body:result, headers:this.headers, jwt:(_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token});
          if (error) {
            return this._returnResult({data:null, error});
          }
          params.factorType === "totp" && data.type === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? 0 : _b.qr_code) && (data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`);
          return this._returnResult({data, error:null});
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async _verify(params) {
      return this._acquireLock(this.lockAcquireTimeout, async() => {
        try {
          return await this._useSession(async result => {
            var _a;
            const {data:sessionData, error:sessionError} = result;
            if (sessionError) {
              return this._returnResult({data:null, error:sessionError});
            }
            result = Object.assign({challenge_id:params.challengeId}, "webauthn" in params ? {webauthn:Object.assign(Object.assign({}, params.webauthn), {credential_response:params.webauthn.type === "create" ? (0,webauthn_1.serializeCredentialCreationResponse)(params.webauthn.credential_response) : (0,webauthn_1.serializeCredentialRequestResponse)(params.webauthn.credential_response)})} : {code:params.code});
            const {data, error} = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {body:result, headers:this.headers, jwt:(_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token});
            if (error) {
              return this._returnResult({data:null, error});
            }
            await this._saveSession(Object.assign({expires_at:Math.round(Date.now() / 1000) + data.expires_in}, data));
            await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
            return this._returnResult({data, error});
          });
        } catch (error) {
          if ((0,errors_1.isAuthError)(error)) {
            return this._returnResult({data:null, error});
          }
          throw error;
        }
      });
    }
    async _challenge(params) {
      return this._acquireLock(this.lockAcquireTimeout, async() => {
        try {
          return await this._useSession(async result => {
            var _a;
            const {data:sessionData, error:sessionError} = result;
            if (sessionError) {
              return this._returnResult({data:null, error:sessionError});
            }
            result = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {body:params, headers:this.headers, jwt:(_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token});
            if (result.error) {
              return result;
            }
            ({data:_a} = result);
            if (_a.type !== "webauthn") {
              return {data:_a, error:null};
            }
            switch(_a.webauthn.type) {
              case "create":
                return {data:Object.assign(Object.assign({}, _a), {webauthn:Object.assign(Object.assign({}, _a.webauthn), {credential_options:Object.assign(Object.assign({}, _a.webauthn.credential_options), {publicKey:(0,webauthn_1.deserializeCredentialCreationOptions)(_a.webauthn.credential_options.publicKey)})})}), error:null};
              case "request":
                return {data:Object.assign(Object.assign({}, _a), {webauthn:Object.assign(Object.assign({}, _a.webauthn), {credential_options:Object.assign(Object.assign({}, _a.webauthn.credential_options), {publicKey:(0,webauthn_1.deserializeCredentialRequestOptions)(_a.webauthn.credential_options.publicKey)})})}), error:null};
            }
          });
        } catch (error) {
          if ((0,errors_1.isAuthError)(error)) {
            return this._returnResult({data:null, error});
          }
          throw error;
        }
      });
    }
    async _challengeAndVerify(params) {
      const {data:challengeData, error:challengeError} = await this._challenge({factorId:params.factorId});
      return challengeError ? this._returnResult({data:null, error:challengeError}) : await this._verify({factorId:params.factorId, challengeId:challengeData.id, code:params.code});
    }
    async _listFactors() {
      var _a;
      const {data:{user}, error:userError} = await this.getUser();
      if (userError) {
        return {data:null, error:userError};
      }
      const data = {all:[], phone:[], totp:[], webauthn:[]};
      for (const factor of (_a = user === null || user === void 0 ? void 0 : user.factors) !== null && _a !== void 0 ? _a : []) {
        data.all.push(factor), factor.status === "verified" && data[factor.factor_type].push(factor);
      }
      return {data, error:null};
    }
    async _getAuthenticatorAssuranceLevel(jwt) {
      var _a, _b;
      if (jwt) {
        try {
          const {payload} = (0,helpers_1.decodeJWT)(jwt);
          var _c = null;
          payload.aal && (_c = payload.aal);
          var _d = _c;
          const {data:{user}, error:userError} = await this.getUser(jwt);
          if (userError) {
            return this._returnResult({data:null, error:userError});
          }
          ((_b = (_a = user === null || user === void 0 ? void 0 : user.factors) === null || _a === void 0 ? void 0 : _a.filter(factor => factor.status === "verified")) !== null && _b !== void 0 ? _b : []).length > 0 && (_d = "aal2");
          return {data:{currentLevel:_c, nextLevel:_d, currentAuthenticationMethods:payload.amr || []}, error:null};
        } catch (error) {
          if ((0,errors_1.isAuthError)(error)) {
            return this._returnResult({data:null, error});
          }
          throw error;
        }
      }
      const {data:{session}, error:sessionError} = await this.getSession();
      if (sessionError) {
        return this._returnResult({data:null, error:sessionError});
      }
      if (!session) {
        return {data:{currentLevel:null, nextLevel:null, currentAuthenticationMethods:[]}, error:null};
      }
      ({payload:jwt} = (0,helpers_1.decodeJWT)(session.access_token));
      _a = null;
      jwt.aal && (_a = jwt.aal);
      _b = _a;
      ((_d = (_c = session.user.factors) === null || _c === void 0 ? void 0 : _c.filter(factor => factor.status === "verified")) !== null && _d !== void 0 ? _d : []).length > 0 && (_b = "aal2");
      return {data:{currentLevel:_a, nextLevel:_b, currentAuthenticationMethods:jwt.amr || []}, error:null};
    }
    async _getAuthorizationDetails(authorizationId) {
      try {
        return await this._useSession(async result => {
          const {data:{session}, error:sessionError} = result;
          return sessionError ? this._returnResult({data:null, error:sessionError}) : session ? await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/oauth/authorizations/${authorizationId}`, {headers:this.headers, jwt:session.access_token, xform:data => ({data, error:null})}) : this._returnResult({data:null, error:new errors_1.AuthSessionMissingError()});
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async _approveAuthorization(authorizationId, options) {
      try {
        return await this._useSession(async result => {
          const {data:{session}, error:sessionError} = result;
          if (sessionError) {
            return this._returnResult({data:null, error:sessionError});
          }
          if (!session) {
            return this._returnResult({data:null, error:new errors_1.AuthSessionMissingError()});
          }
          result = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {headers:this.headers, jwt:session.access_token, body:{action:"approve"}, xform:data => ({data, error:null})});
          result.data && result.data.redirect_url && (!(0,helpers_1.isBrowser)() || (options === null || options === void 0 ? 0 : options.skipBrowserRedirect) || window.location.assign(result.data.redirect_url));
          return result;
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async _denyAuthorization(authorizationId, options) {
      try {
        return await this._useSession(async result => {
          const {data:{session}, error:sessionError} = result;
          if (sessionError) {
            return this._returnResult({data:null, error:sessionError});
          }
          if (!session) {
            return this._returnResult({data:null, error:new errors_1.AuthSessionMissingError()});
          }
          result = await (0,fetch_1._request)(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {headers:this.headers, jwt:session.access_token, body:{action:"deny"}, xform:data => ({data, error:null})});
          result.data && result.data.redirect_url && (!(0,helpers_1.isBrowser)() || (options === null || options === void 0 ? 0 : options.skipBrowserRedirect) || window.location.assign(result.data.redirect_url));
          return result;
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async _listOAuthGrants() {
      try {
        return await this._useSession(async result => {
          const {data:{session}, error:sessionError} = result;
          return sessionError ? this._returnResult({data:null, error:sessionError}) : session ? await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/user/oauth/grants`, {headers:this.headers, jwt:session.access_token, xform:data => ({data, error:null})}) : this._returnResult({data:null, error:new errors_1.AuthSessionMissingError()});
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async _revokeOAuthGrant(options) {
      try {
        return await this._useSession(async result => {
          const {data:{session}, error:sessionError} = result;
          if (sessionError) {
            return this._returnResult({data:null, error:sessionError});
          }
          if (!session) {
            return this._returnResult({data:null, error:new errors_1.AuthSessionMissingError()});
          }
          await (0,fetch_1._request)(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {headers:this.headers, jwt:session.access_token, query:{client_id:options.clientId}, noResolveJson:!0});
          return {data:{}, error:null};
        });
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
    async fetchJwk(kid, jwks = {keys:[]}) {
      if (jwks = jwks.keys.find(key => key.kid === kid)) {
        return jwks;
      }
      const now = Date.now();
      if ((jwks = this.jwks.keys.find(key => key.kid === kid)) && this.jwks_cached_at + constants_1.JWKS_TTL > now) {
        return jwks;
      }
      const {data, error} = await (0,fetch_1._request)(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {headers:this.headers});
      if (error) {
        throw error;
      }
      if (!data.keys || data.keys.length === 0) {
        return null;
      }
      this.jwks = data;
      this.jwks_cached_at = now;
      return (jwks = data.keys.find(key => key.kid === kid)) ? jwks : null;
    }
    async getClaims(jwt, options = {}) {
      try {
        if (!jwt) {
          const {data, error} = await this.getSession();
          if (error || !data.session) {
            return this._returnResult({data:null, error});
          }
          jwt = data.session.access_token;
        }
        const {header, payload, signature, raw:{header:rawHeader, payload:rawPayload}} = (0,helpers_1.decodeJWT)(jwt);
        (options === null || options === void 0 ? 0 : options.allowExpired) || (0,helpers_1.validateExp)(payload.exp);
        const signingKey = header.alg && !header.alg.startsWith("HS") && header.kid && "crypto" in globalThis && "subtle" in globalThis.crypto ? await this.fetchJwk(header.kid, (options === null || options === void 0 ? 0 : options.keys) ? {keys:options.keys} : options === null || options === void 0 ? void 0 : options.jwks) : null;
        if (!signingKey) {
          const {error} = await this.getUser(jwt);
          if (error) {
            throw error;
          }
          return {data:{claims:payload, header, signature}, error:null};
        }
        const algorithm = (0,helpers_1.getAlgorithm)(header.alg), publicKey = await crypto.subtle.importKey("jwk", signingKey, algorithm, !0, ["verify"]);
        if (!await crypto.subtle.verify(algorithm, publicKey, signature, (0,base64url_1.stringToUint8Array)(`${rawHeader}.${rawPayload}`))) {
          throw new errors_1.AuthInvalidJwtError("Invalid JWT signature");
        }
        return {data:{claims:payload, header, signature}, error:null};
      } catch (error) {
        if ((0,errors_1.isAuthError)(error)) {
          return this._returnResult({data:null, error});
        }
        throw error;
      }
    }
  }
  GoTrueClient.nextInstanceID = {};
  exports.default = GoTrueClient;
};

//# sourceMappingURL=module$node_modules$$supabase$auth_js$dist$main$GoTrueClient.js.map
